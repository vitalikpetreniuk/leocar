/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (function() { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "../../../themes/leocar/assets/src/scripts/index.js":
/*!**********************************************************!*\
  !*** ../../../themes/leocar/assets/src/scripts/index.js ***!
  \**********************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ init; }\n/* harmony export */ });\n/* harmony import */ var _utils_swiper__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils/swiper */ \"../../../themes/leocar/assets/src/scripts/utils/swiper.js\");\n/* harmony import */ var _utils_imask__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils/imask */ \"../../../themes/leocar/assets/src/scripts/utils/imask.js\");\n/* harmony import */ var _utils_imask__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_utils_imask__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _utils_datepicker_full__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils/datepicker-full */ \"../../../themes/leocar/assets/src/scripts/utils/datepicker-full.js\");\n/* harmony import */ var _utils_datepicker_full__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_utils_datepicker_full__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _utils_header__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./utils/header */ \"../../../themes/leocar/assets/src/scripts/utils/header.js\");\n/* harmony import */ var _utils_modal__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./utils/modal */ \"../../../themes/leocar/assets/src/scripts/utils/modal.js\");\n/* harmony import */ var _utils_home__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./utils/home */ \"../../../themes/leocar/assets/src/scripts/utils/home.js\");\n/* harmony import */ var _utils_catalog__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./utils/catalog */ \"../../../themes/leocar/assets/src/scripts/utils/catalog.js\");\n/* harmony import */ var _utils_reviews__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./utils/reviews */ \"../../../themes/leocar/assets/src/scripts/utils/reviews.js\");\n/* harmony import */ var _utils_faq__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./utils/faq */ \"../../../themes/leocar/assets/src/scripts/utils/faq.js\");\n/* harmony import */ var _utils_seo__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./utils/seo */ \"../../../themes/leocar/assets/src/scripts/utils/seo.js\");\n/* harmony import */ var _utils_popup__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./utils/popup */ \"../../../themes/leocar/assets/src/scripts/utils/popup.js\");\n// import \"../../../../../plugins/brainwave/assembly/node_modules/jquery/dist/jquery.min.js\";\n\n// /*!\n//  * Masonry PACKAGED v4.2.2\n//  * Cascading grid layout library\n//  * https://masonry.desandro.com\n//  * MIT License\n//  * by David DeSandro\n//  */\n// !function(t,e){\"function\"==typeof define&&define.amd?define(\"jquery-bridget/jquery-bridget\",[\"jquery\"],function(i){return e(t,i)}):\"object\"==typeof module&&module.exports?module.exports=e(t,require(\"jquery\")):t.jQueryBridget=e(t,t.jQuery)}(window,function(t,e){\"use strict\";function i(i,r,a){function h(t,e,n){var o,r=\"$().\"+i+'(\"'+e+'\")';return t.each(function(t,h){var u=a.data(h,i);if(!u)return void s(i+\" not initialized. Cannot call methods, i.e. \"+r);var d=u[e];if(!d||\"_\"==e.charAt(0))return void s(r+\" is not a valid method\");var l=d.apply(u,n);o=void 0===o?l:o}),void 0!==o?o:t}function u(t,e){t.each(function(t,n){var o=a.data(n,i);o?(o.option(e),o._init()):(o=new r(n,e),a.data(n,i,o))})}a=a||e||t.jQuery,a&&(r.prototype.option||(r.prototype.option=function(t){a.isPlainObject(t)&&(this.options=a.extend(!0,this.options,t))}),a.fn[i]=function(t){if(\"string\"==typeof t){var e=o.call(arguments,1);return h(this,t,e)}return u(this,t),this},n(a))}function n(t){!t||t&&t.bridget||(t.bridget=i)}var o=Array.prototype.slice,r=t.console,s=\"undefined\"==typeof r?function(){}:function(t){r.error(t)};return n(e||t.jQuery),i}),function(t,e){\"function\"==typeof define&&define.amd?define(\"ev-emitter/ev-emitter\",e):\"object\"==typeof module&&module.exports?module.exports=e():t.EvEmitter=e()}(\"undefined\"!=typeof window?window:this,function(){function t(){}var e=t.prototype;return e.on=function(t,e){if(t&&e){var i=this._events=this._events||{},n=i[t]=i[t]||[];return-1==n.indexOf(e)&&n.push(e),this}},e.once=function(t,e){if(t&&e){this.on(t,e);var i=this._onceEvents=this._onceEvents||{},n=i[t]=i[t]||{};return n[e]=!0,this}},e.off=function(t,e){var i=this._events&&this._events[t];if(i&&i.length){var n=i.indexOf(e);return-1!=n&&i.splice(n,1),this}},e.emitEvent=function(t,e){var i=this._events&&this._events[t];if(i&&i.length){i=i.slice(0),e=e||[];for(var n=this._onceEvents&&this._onceEvents[t],o=0;o<i.length;o++){var r=i[o],s=n&&n[r];s&&(this.off(t,r),delete n[r]),r.apply(this,e)}return this}},e.allOff=function(){delete this._events,delete this._onceEvents},t}),function(t,e){\"function\"==typeof define&&define.amd?define(\"get-size/get-size\",e):\"object\"==typeof module&&module.exports?module.exports=e():t.getSize=e()}(window,function(){\"use strict\";function t(t){var e=parseFloat(t),i=-1==t.indexOf(\"%\")&&!isNaN(e);return i&&e}function e(){}function i(){for(var t={width:0,height:0,innerWidth:0,innerHeight:0,outerWidth:0,outerHeight:0},e=0;u>e;e++){var i=h[e];t[i]=0}return t}function n(t){var e=getComputedStyle(t);return e||a(\"Style returned \"+e+\". Are you running this code in a hidden iframe on Firefox? See https://bit.ly/getsizebug1\"),e}function o(){if(!d){d=!0;var e=document.createElement(\"div\");e.style.width=\"200px\",e.style.padding=\"1px 2px 3px 4px\",e.style.borderStyle=\"solid\",e.style.borderWidth=\"1px 2px 3px 4px\",e.style.boxSizing=\"border-box\";var i=document.body||document.documentElement;i.appendChild(e);var o=n(e);s=200==Math.round(t(o.width)),r.isBoxSizeOuter=s,i.removeChild(e)}}function r(e){if(o(),\"string\"==typeof e&&(e=document.querySelector(e)),e&&\"object\"==typeof e&&e.nodeType){var r=n(e);if(\"none\"==r.display)return i();var a={};a.width=e.offsetWidth,a.height=e.offsetHeight;for(var d=a.isBorderBox=\"border-box\"==r.boxSizing,l=0;u>l;l++){var c=h[l],f=r[c],m=parseFloat(f);a[c]=isNaN(m)?0:m}var p=a.paddingLeft+a.paddingRight,g=a.paddingTop+a.paddingBottom,y=a.marginLeft+a.marginRight,v=a.marginTop+a.marginBottom,_=a.borderLeftWidth+a.borderRightWidth,z=a.borderTopWidth+a.borderBottomWidth,E=d&&s,b=t(r.width);b!==!1&&(a.width=b+(E?0:p+_));var x=t(r.height);return x!==!1&&(a.height=x+(E?0:g+z)),a.innerWidth=a.width-(p+_),a.innerHeight=a.height-(g+z),a.outerWidth=a.width+y,a.outerHeight=a.height+v,a}}var s,a=\"undefined\"==typeof console?e:function(t){console.error(t)},h=[\"paddingLeft\",\"paddingRight\",\"paddingTop\",\"paddingBottom\",\"marginLeft\",\"marginRight\",\"marginTop\",\"marginBottom\",\"borderLeftWidth\",\"borderRightWidth\",\"borderTopWidth\",\"borderBottomWidth\"],u=h.length,d=!1;return r}),function(t,e){\"use strict\";\"function\"==typeof define&&define.amd?define(\"desandro-matches-selector/matches-selector\",e):\"object\"==typeof module&&module.exports?module.exports=e():t.matchesSelector=e()}(window,function(){\"use strict\";var t=function(){var t=window.Element.prototype;if(t.matches)return\"matches\";if(t.matchesSelector)return\"matchesSelector\";for(var e=[\"webkit\",\"moz\",\"ms\",\"o\"],i=0;i<e.length;i++){var n=e[i],o=n+\"MatchesSelector\";if(t[o])return o}}();return function(e,i){return e[t](i)}}),function(t,e){\"function\"==typeof define&&define.amd?define(\"fizzy-ui-utils/utils\",[\"desandro-matches-selector/matches-selector\"],function(i){return e(t,i)}):\"object\"==typeof module&&module.exports?module.exports=e(t,require(\"desandro-matches-selector\")):t.fizzyUIUtils=e(t,t.matchesSelector)}(window,function(t,e){var i={};i.extend=function(t,e){for(var i in e)t[i]=e[i];return t},i.modulo=function(t,e){return(t%e+e)%e};var n=Array.prototype.slice;i.makeArray=function(t){if(Array.isArray(t))return t;if(null===t||void 0===t)return[];var e=\"object\"==typeof t&&\"number\"==typeof t.length;return e?n.call(t):[t]},i.removeFrom=function(t,e){var i=t.indexOf(e);-1!=i&&t.splice(i,1)},i.getParent=function(t,i){for(;t.parentNode&&t!=document.body;)if(t=t.parentNode,e(t,i))return t},i.getQueryElement=function(t){return\"string\"==typeof t?document.querySelector(t):t},i.handleEvent=function(t){var e=\"on\"+t.type;this[e]&&this[e](t)},i.filterFindElements=function(t,n){t=i.makeArray(t);var o=[];return t.forEach(function(t){if(t instanceof HTMLElement){if(!n)return void o.push(t);e(t,n)&&o.push(t);for(var i=t.querySelectorAll(n),r=0;r<i.length;r++)o.push(i[r])}}),o},i.debounceMethod=function(t,e,i){i=i||100;var n=t.prototype[e],o=e+\"Timeout\";t.prototype[e]=function(){var t=this[o];clearTimeout(t);var e=arguments,r=this;this[o]=setTimeout(function(){n.apply(r,e),delete r[o]},i)}},i.docReady=function(t){var e=document.readyState;\"complete\"==e||\"interactive\"==e?setTimeout(t):document.addEventListener(\"DOMContentLoaded\",t)},i.toDashed=function(t){return t.replace(/(.)([A-Z])/g,function(t,e,i){return e+\"-\"+i}).toLowerCase()};var o=t.console;return i.htmlInit=function(e,n){i.docReady(function(){var r=i.toDashed(n),s=\"data-\"+r,a=document.querySelectorAll(\"[\"+s+\"]\"),h=document.querySelectorAll(\".js-\"+r),u=i.makeArray(a).concat(i.makeArray(h)),d=s+\"-options\",l=t.jQuery;u.forEach(function(t){var i,r=t.getAttribute(s)||t.getAttribute(d);try{i=r&&JSON.parse(r)}catch(a){return void(o&&o.error(\"Error parsing \"+s+\" on \"+t.className+\": \"+a))}var h=new e(t,i);l&&l.data(t,n,h)})})},i}),function(t,e){\"function\"==typeof define&&define.amd?define(\"outlayer/item\",[\"ev-emitter/ev-emitter\",\"get-size/get-size\"],e):\"object\"==typeof module&&module.exports?module.exports=e(require(\"ev-emitter\"),require(\"get-size\")):(t.Outlayer={},t.Outlayer.Item=e(t.EvEmitter,t.getSize))}(window,function(t,e){\"use strict\";function i(t){for(var e in t)return!1;return e=null,!0}function n(t,e){t&&(this.element=t,this.layout=e,this.position={x:0,y:0},this._create())}function o(t){return t.replace(/([A-Z])/g,function(t){return\"-\"+t.toLowerCase()})}var r=document.documentElement.style,s=\"string\"==typeof r.transition?\"transition\":\"WebkitTransition\",a=\"string\"==typeof r.transform?\"transform\":\"WebkitTransform\",h={WebkitTransition:\"webkitTransitionEnd\",transition:\"transitionend\"}[s],u={transform:a,transition:s,transitionDuration:s+\"Duration\",transitionProperty:s+\"Property\",transitionDelay:s+\"Delay\"},d=n.prototype=Object.create(t.prototype);d.constructor=n,d._create=function(){this._transn={ingProperties:{},clean:{},onEnd:{}},this.css({position:\"absolute\"})},d.handleEvent=function(t){var e=\"on\"+t.type;this[e]&&this[e](t)},d.getSize=function(){this.size=e(this.element)},d.css=function(t){var e=this.element.style;for(var i in t){var n=u[i]||i;e[n]=t[i]}},d.getPosition=function(){var t=getComputedStyle(this.element),e=this.layout._getOption(\"originLeft\"),i=this.layout._getOption(\"originTop\"),n=t[e?\"left\":\"right\"],o=t[i?\"top\":\"bottom\"],r=parseFloat(n),s=parseFloat(o),a=this.layout.size;-1!=n.indexOf(\"%\")&&(r=r/100*a.width),-1!=o.indexOf(\"%\")&&(s=s/100*a.height),r=isNaN(r)?0:r,s=isNaN(s)?0:s,r-=e?a.paddingLeft:a.paddingRight,s-=i?a.paddingTop:a.paddingBottom,this.position.x=r,this.position.y=s},d.layoutPosition=function(){var t=this.layout.size,e={},i=this.layout._getOption(\"originLeft\"),n=this.layout._getOption(\"originTop\"),o=i?\"paddingLeft\":\"paddingRight\",r=i?\"left\":\"right\",s=i?\"right\":\"left\",a=this.position.x+t[o];e[r]=this.getXValue(a),e[s]=\"\";var h=n?\"paddingTop\":\"paddingBottom\",u=n?\"top\":\"bottom\",d=n?\"bottom\":\"top\",l=this.position.y+t[h];e[u]=this.getYValue(l),e[d]=\"\",this.css(e),this.emitEvent(\"layout\",[this])},d.getXValue=function(t){var e=this.layout._getOption(\"horizontal\");return this.layout.options.percentPosition&&!e?t/this.layout.size.width*100+\"%\":t+\"px\"},d.getYValue=function(t){var e=this.layout._getOption(\"horizontal\");return this.layout.options.percentPosition&&e?t/this.layout.size.height*100+\"%\":t+\"px\"},d._transitionTo=function(t,e){this.getPosition();var i=this.position.x,n=this.position.y,o=t==this.position.x&&e==this.position.y;if(this.setPosition(t,e),o&&!this.isTransitioning)return void this.layoutPosition();var r=t-i,s=e-n,a={};a.transform=this.getTranslate(r,s),this.transition({to:a,onTransitionEnd:{transform:this.layoutPosition},isCleaning:!0})},d.getTranslate=function(t,e){var i=this.layout._getOption(\"originLeft\"),n=this.layout._getOption(\"originTop\");return t=i?t:-t,e=n?e:-e,\"translate3d(\"+t+\"px, \"+e+\"px, 0)\"},d.goTo=function(t,e){this.setPosition(t,e),this.layoutPosition()},d.moveTo=d._transitionTo,d.setPosition=function(t,e){this.position.x=parseFloat(t),this.position.y=parseFloat(e)},d._nonTransition=function(t){this.css(t.to),t.isCleaning&&this._removeStyles(t.to);for(var e in t.onTransitionEnd)t.onTransitionEnd[e].call(this)},d.transition=function(t){if(!parseFloat(this.layout.options.transitionDuration))return void this._nonTransition(t);var e=this._transn;for(var i in t.onTransitionEnd)e.onEnd[i]=t.onTransitionEnd[i];for(i in t.to)e.ingProperties[i]=!0,t.isCleaning&&(e.clean[i]=!0);if(t.from){this.css(t.from);var n=this.element.offsetHeight;n=null}this.enableTransition(t.to),this.css(t.to),this.isTransitioning=!0};var l=\"opacity,\"+o(a);d.enableTransition=function(){if(!this.isTransitioning){var t=this.layout.options.transitionDuration;t=\"number\"==typeof t?t+\"ms\":t,this.css({transitionProperty:l,transitionDuration:t,transitionDelay:this.staggerDelay||0}),this.element.addEventListener(h,this,!1)}},d.onwebkitTransitionEnd=function(t){this.ontransitionend(t)},d.onotransitionend=function(t){this.ontransitionend(t)};var c={\"-webkit-transform\":\"transform\"};d.ontransitionend=function(t){if(t.target===this.element){var e=this._transn,n=c[t.propertyName]||t.propertyName;if(delete e.ingProperties[n],i(e.ingProperties)&&this.disableTransition(),n in e.clean&&(this.element.style[t.propertyName]=\"\",delete e.clean[n]),n in e.onEnd){var o=e.onEnd[n];o.call(this),delete e.onEnd[n]}this.emitEvent(\"transitionEnd\",[this])}},d.disableTransition=function(){this.removeTransitionStyles(),this.element.removeEventListener(h,this,!1),this.isTransitioning=!1},d._removeStyles=function(t){var e={};for(var i in t)e[i]=\"\";this.css(e)};var f={transitionProperty:\"\",transitionDuration:\"\",transitionDelay:\"\"};return d.removeTransitionStyles=function(){this.css(f)},d.stagger=function(t){t=isNaN(t)?0:t,this.staggerDelay=t+\"ms\"},d.removeElem=function(){this.element.parentNode.removeChild(this.element),this.css({display:\"\"}),this.emitEvent(\"remove\",[this])},d.remove=function(){return s&&parseFloat(this.layout.options.transitionDuration)?(this.once(\"transitionEnd\",function(){this.removeElem()}),void this.hide()):void this.removeElem()},d.reveal=function(){delete this.isHidden,this.css({display:\"\"});var t=this.layout.options,e={},i=this.getHideRevealTransitionEndProperty(\"visibleStyle\");e[i]=this.onRevealTransitionEnd,this.transition({from:t.hiddenStyle,to:t.visibleStyle,isCleaning:!0,onTransitionEnd:e})},d.onRevealTransitionEnd=function(){this.isHidden||this.emitEvent(\"reveal\")},d.getHideRevealTransitionEndProperty=function(t){var e=this.layout.options[t];if(e.opacity)return\"opacity\";for(var i in e)return i},d.hide=function(){this.isHidden=!0,this.css({display:\"\"});var t=this.layout.options,e={},i=this.getHideRevealTransitionEndProperty(\"hiddenStyle\");e[i]=this.onHideTransitionEnd,this.transition({from:t.visibleStyle,to:t.hiddenStyle,isCleaning:!0,onTransitionEnd:e})},d.onHideTransitionEnd=function(){this.isHidden&&(this.css({display:\"none\"}),this.emitEvent(\"hide\"))},d.destroy=function(){this.css({position:\"\",left:\"\",right:\"\",top:\"\",bottom:\"\",transition:\"\",transform:\"\"})},n}),function(t,e){\"use strict\";\"function\"==typeof define&&define.amd?define(\"outlayer/outlayer\",[\"ev-emitter/ev-emitter\",\"get-size/get-size\",\"fizzy-ui-utils/utils\",\"./item\"],function(i,n,o,r){return e(t,i,n,o,r)}):\"object\"==typeof module&&module.exports?module.exports=e(t,require(\"ev-emitter\"),require(\"get-size\"),require(\"fizzy-ui-utils\"),require(\"./item\")):t.Outlayer=e(t,t.EvEmitter,t.getSize,t.fizzyUIUtils,t.Outlayer.Item)}(window,function(t,e,i,n,o){\"use strict\";function r(t,e){var i=n.getQueryElement(t);if(!i)return void(h&&h.error(\"Bad element for \"+this.constructor.namespace+\": \"+(i||t)));this.element=i,u&&(this.$element=u(this.element)),this.options=n.extend({},this.constructor.defaults),this.option(e);var o=++l;this.element.outlayerGUID=o,c[o]=this,this._create();var r=this._getOption(\"initLayout\");r&&this.layout()}function s(t){function e(){t.apply(this,arguments)}return e.prototype=Object.create(t.prototype),e.prototype.constructor=e,e}function a(t){if(\"number\"==typeof t)return t;var e=t.match(/(^\\d*\\.?\\d*)(\\w*)/),i=e&&e[1],n=e&&e[2];if(!i.length)return 0;i=parseFloat(i);var o=m[n]||1;return i*o}var h=t.console,u=t.jQuery,d=function(){},l=0,c={};r.namespace=\"outlayer\",r.Item=o,r.defaults={containerStyle:{position:\"relative\"},initLayout:!0,originLeft:!0,originTop:!0,resize:!0,resizeContainer:!0,transitionDuration:\"0.4s\",hiddenStyle:{opacity:0,transform:\"scale(0.001)\"},visibleStyle:{opacity:1,transform:\"scale(1)\"}};var f=r.prototype;n.extend(f,e.prototype),f.option=function(t){n.extend(this.options,t)},f._getOption=function(t){var e=this.constructor.compatOptions[t];return e&&void 0!==this.options[e]?this.options[e]:this.options[t]},r.compatOptions={initLayout:\"isInitLayout\",horizontal:\"isHorizontal\",layoutInstant:\"isLayoutInstant\",originLeft:\"isOriginLeft\",originTop:\"isOriginTop\",resize:\"isResizeBound\",resizeContainer:\"isResizingContainer\"},f._create=function(){this.reloadItems(),this.stamps=[],this.stamp(this.options.stamp),n.extend(this.element.style,this.options.containerStyle);var t=this._getOption(\"resize\");t&&this.bindResize()},f.reloadItems=function(){this.items=this._itemize(this.element.children)},f._itemize=function(t){for(var e=this._filterFindItemElements(t),i=this.constructor.Item,n=[],o=0;o<e.length;o++){var r=e[o],s=new i(r,this);n.push(s)}return n},f._filterFindItemElements=function(t){return n.filterFindElements(t,this.options.itemSelector)},f.getItemElements=function(){return this.items.map(function(t){return t.element})},f.layout=function(){this._resetLayout(),this._manageStamps();var t=this._getOption(\"layoutInstant\"),e=void 0!==t?t:!this._isLayoutInited;this.layoutItems(this.items,e),this._isLayoutInited=!0},f._init=f.layout,f._resetLayout=function(){this.getSize()},f.getSize=function(){this.size=i(this.element)},f._getMeasurement=function(t,e){var n,o=this.options[t];o?(\"string\"==typeof o?n=this.element.querySelector(o):o instanceof HTMLElement&&(n=o),this[t]=n?i(n)[e]:o):this[t]=0},f.layoutItems=function(t,e){t=this._getItemsForLayout(t),this._layoutItems(t,e),this._postLayout()},f._getItemsForLayout=function(t){return t.filter(function(t){return!t.isIgnored})},f._layoutItems=function(t,e){if(this._emitCompleteOnItems(\"layout\",t),t&&t.length){var i=[];t.forEach(function(t){var n=this._getItemLayoutPosition(t);n.item=t,n.isInstant=e||t.isLayoutInstant,i.push(n)},this),this._processLayoutQueue(i)}},f._getItemLayoutPosition=function(){return{x:0,y:0}},f._processLayoutQueue=function(t){this.updateStagger(),t.forEach(function(t,e){this._positionItem(t.item,t.x,t.y,t.isInstant,e)},this)},f.updateStagger=function(){var t=this.options.stagger;return null===t||void 0===t?void(this.stagger=0):(this.stagger=a(t),this.stagger)},f._positionItem=function(t,e,i,n,o){n?t.goTo(e,i):(t.stagger(o*this.stagger),t.moveTo(e,i))},f._postLayout=function(){this.resizeContainer()},f.resizeContainer=function(){var t=this._getOption(\"resizeContainer\");if(t){var e=this._getContainerSize();e&&(this._setContainerMeasure(e.width,!0),this._setContainerMeasure(e.height,!1))}},f._getContainerSize=d,f._setContainerMeasure=function(t,e){if(void 0!==t){var i=this.size;i.isBorderBox&&(t+=e?i.paddingLeft+i.paddingRight+i.borderLeftWidth+i.borderRightWidth:i.paddingBottom+i.paddingTop+i.borderTopWidth+i.borderBottomWidth),t=Math.max(t,0),this.element.style[e?\"width\":\"height\"]=t+\"px\"}},f._emitCompleteOnItems=function(t,e){function i(){o.dispatchEvent(t+\"Complete\",null,[e])}function n(){s++,s==r&&i()}var o=this,r=e.length;if(!e||!r)return void i();var s=0;e.forEach(function(e){e.once(t,n)})},f.dispatchEvent=function(t,e,i){var n=e?[e].concat(i):i;if(this.emitEvent(t,n),u)if(this.$element=this.$element||u(this.element),e){var o=u.Event(e);o.type=t,this.$element.trigger(o,i)}else this.$element.trigger(t,i)},f.ignore=function(t){var e=this.getItem(t);e&&(e.isIgnored=!0)},f.unignore=function(t){var e=this.getItem(t);e&&delete e.isIgnored},f.stamp=function(t){t=this._find(t),t&&(this.stamps=this.stamps.concat(t),t.forEach(this.ignore,this))},f.unstamp=function(t){t=this._find(t),t&&t.forEach(function(t){n.removeFrom(this.stamps,t),this.unignore(t)},this)},f._find=function(t){return t?(\"string\"==typeof t&&(t=this.element.querySelectorAll(t)),t=n.makeArray(t)):void 0},f._manageStamps=function(){this.stamps&&this.stamps.length&&(this._getBoundingRect(),this.stamps.forEach(this._manageStamp,this))},f._getBoundingRect=function(){var t=this.element.getBoundingClientRect(),e=this.size;this._boundingRect={left:t.left+e.paddingLeft+e.borderLeftWidth,top:t.top+e.paddingTop+e.borderTopWidth,right:t.right-(e.paddingRight+e.borderRightWidth),bottom:t.bottom-(e.paddingBottom+e.borderBottomWidth)}},f._manageStamp=d,f._getElementOffset=function(t){var e=t.getBoundingClientRect(),n=this._boundingRect,o=i(t),r={left:e.left-n.left-o.marginLeft,top:e.top-n.top-o.marginTop,right:n.right-e.right-o.marginRight,bottom:n.bottom-e.bottom-o.marginBottom};return r},f.handleEvent=n.handleEvent,f.bindResize=function(){t.addEventListener(\"resize\",this),this.isResizeBound=!0},f.unbindResize=function(){t.removeEventListener(\"resize\",this),this.isResizeBound=!1},f.onresize=function(){this.resize()},n.debounceMethod(r,\"onresize\",100),f.resize=function(){this.isResizeBound&&this.needsResizeLayout()&&this.layout()},f.needsResizeLayout=function(){var t=i(this.element),e=this.size&&t;return e&&t.innerWidth!==this.size.innerWidth},f.addItems=function(t){var e=this._itemize(t);return e.length&&(this.items=this.items.concat(e)),e},f.appended=function(t){var e=this.addItems(t);e.length&&(this.layoutItems(e,!0),this.reveal(e))},f.prepended=function(t){var e=this._itemize(t);if(e.length){var i=this.items.slice(0);this.items=e.concat(i),this._resetLayout(),this._manageStamps(),this.layoutItems(e,!0),this.reveal(e),this.layoutItems(i)}},f.reveal=function(t){if(this._emitCompleteOnItems(\"reveal\",t),t&&t.length){var e=this.updateStagger();t.forEach(function(t,i){t.stagger(i*e),t.reveal()})}},f.hide=function(t){if(this._emitCompleteOnItems(\"hide\",t),t&&t.length){var e=this.updateStagger();t.forEach(function(t,i){t.stagger(i*e),t.hide()})}},f.revealItemElements=function(t){var e=this.getItems(t);this.reveal(e)},f.hideItemElements=function(t){var e=this.getItems(t);this.hide(e)},f.getItem=function(t){for(var e=0;e<this.items.length;e++){var i=this.items[e];if(i.element==t)return i}},f.getItems=function(t){t=n.makeArray(t);var e=[];return t.forEach(function(t){var i=this.getItem(t);i&&e.push(i)},this),e},f.remove=function(t){var e=this.getItems(t);this._emitCompleteOnItems(\"remove\",e),e&&e.length&&e.forEach(function(t){t.remove(),n.removeFrom(this.items,t)},this)},f.destroy=function(){var t=this.element.style;t.height=\"\",t.position=\"\",t.width=\"\",this.items.forEach(function(t){t.destroy()}),this.unbindResize();var e=this.element.outlayerGUID;delete c[e],delete this.element.outlayerGUID,u&&u.removeData(this.element,this.constructor.namespace)},r.data=function(t){t=n.getQueryElement(t);var e=t&&t.outlayerGUID;return e&&c[e]},r.create=function(t,e){var i=s(r);return i.defaults=n.extend({},r.defaults),n.extend(i.defaults,e),i.compatOptions=n.extend({},r.compatOptions),i.namespace=t,i.data=r.data,i.Item=s(o),n.htmlInit(i,t),u&&u.bridget&&u.bridget(t,i),i};var m={ms:1,s:1e3};return r.Item=o,r}),function(t,e){\"function\"==typeof define&&define.amd?define([\"outlayer/outlayer\",\"get-size/get-size\"],e):\"object\"==typeof module&&module.exports?module.exports=e(require(\"outlayer\"),require(\"get-size\")):t.Masonry=e(t.Outlayer,t.getSize)}(window,function(t,e){var i=t.create(\"masonry\");i.compatOptions.fitWidth=\"isFitWidth\";var n=i.prototype;return n._resetLayout=function(){this.getSize(),this._getMeasurement(\"columnWidth\",\"outerWidth\"),this._getMeasurement(\"gutter\",\"outerWidth\"),this.measureColumns(),this.colYs=[];for(var t=0;t<this.cols;t++)this.colYs.push(0);this.maxY=0,this.horizontalColIndex=0},n.measureColumns=function(){if(this.getContainerWidth(),!this.columnWidth){var t=this.items[0],i=t&&t.element;this.columnWidth=i&&e(i).outerWidth||this.containerWidth}var n=this.columnWidth+=this.gutter,o=this.containerWidth+this.gutter,r=o/n,s=n-o%n,a=s&&1>s?\"round\":\"floor\";r=Math[a](r),this.cols=Math.max(r,1)},n.getContainerWidth=function(){var t=this._getOption(\"fitWidth\"),i=t?this.element.parentNode:this.element,n=e(i);this.containerWidth=n&&n.innerWidth},n._getItemLayoutPosition=function(t){t.getSize();var e=t.size.outerWidth%this.columnWidth,i=e&&1>e?\"round\":\"ceil\",n=Math[i](t.size.outerWidth/this.columnWidth);n=Math.min(n,this.cols);for(var o=this.options.horizontalOrder?\"_getHorizontalColPosition\":\"_getTopColPosition\",r=this[o](n,t),s={x:this.columnWidth*r.col,y:r.y},a=r.y+t.size.outerHeight,h=n+r.col,u=r.col;h>u;u++)this.colYs[u]=a;return s},n._getTopColPosition=function(t){var e=this._getTopColGroup(t),i=Math.min.apply(Math,e);return{col:e.indexOf(i),y:i}},n._getTopColGroup=function(t){if(2>t)return this.colYs;for(var e=[],i=this.cols+1-t,n=0;i>n;n++)e[n]=this._getColGroupY(n,t);return e},n._getColGroupY=function(t,e){if(2>e)return this.colYs[t];var i=this.colYs.slice(t,t+e);return Math.max.apply(Math,i)},n._getHorizontalColPosition=function(t,e){var i=this.horizontalColIndex%this.cols,n=t>1&&i+t>this.cols;i=n?0:i;var o=e.size.outerWidth&&e.size.outerHeight;return this.horizontalColIndex=o?i+t:this.horizontalColIndex,{col:i,y:this._getColGroupY(i,t)}},n._manageStamp=function(t){var i=e(t),n=this._getElementOffset(t),o=this._getOption(\"originLeft\"),r=o?n.left:n.right,s=r+i.outerWidth,a=Math.floor(r/this.columnWidth);a=Math.max(0,a);var h=Math.floor(s/this.columnWidth);h-=s%this.columnWidth?0:1,h=Math.min(this.cols-1,h);for(var u=this._getOption(\"originTop\"),d=(u?n.top:n.bottom)+i.outerHeight,l=a;h>=l;l++)this.colYs[l]=Math.max(d,this.colYs[l])},n._getContainerSize=function(){this.maxY=Math.max.apply(Math,this.colYs);var t={height:this.maxY};return this._getOption(\"fitWidth\")&&(t.width=this._getContainerFitWidth()),t},n._getContainerFitWidth=function(){for(var t=0,e=this.cols;--e&&0===this.colYs[e];)t++;return(this.cols-t)*this.columnWidth-this.gutter},n.needsResizeLayout=function(){var t=this.containerWidth;return this.getContainerWidth(),t!=this.containerWidth},i});\n\n\n\n\n\n\n\n\n\n\n\n\nfunction init() {\n  (0,_utils_header__WEBPACK_IMPORTED_MODULE_3__[\"default\"])();\n  (0,_utils_modal__WEBPACK_IMPORTED_MODULE_4__[\"default\"])();\n  (0,_utils_catalog__WEBPACK_IMPORTED_MODULE_6__[\"default\"])();\n  (0,_utils_reviews__WEBPACK_IMPORTED_MODULE_7__[\"default\"])();\n  (0,_utils_faq__WEBPACK_IMPORTED_MODULE_8__[\"default\"])();\n  (0,_utils_seo__WEBPACK_IMPORTED_MODULE_9__[\"default\"])();\n  (0,_utils_popup__WEBPACK_IMPORTED_MODULE_10__[\"default\"])();\n  (0,_utils_home__WEBPACK_IMPORTED_MODULE_5__[\"default\"])();\n}\ndocument.addEventListener('DOMContentLoaded', function () {\n  init();\n  let inputTel = document.querySelector('section.leo-consult form input[type=\"tel\"]');\n  let callTel = document.querySelector('#leo-modals .modal.call input[type=\"tel\"]');\n  let driveTel = document.querySelector('#leo-modals .modal.drive input[type=\"tel\"]');\n  const maskOptions = {\n    mask: '+{38} (000) 000-00-00'\n  };\n  const timeOptions = {\n    mask: '00:00'\n  };\n  if (inputTel) {\n    let mask = IMask(inputTel, maskOptions);\n  }\n  if (callTel) {\n    let mask = IMask(callTel, maskOptions);\n  }\n  if (driveTel) {\n    let mask = IMask(driveTel, maskOptions);\n  }\n});\n\n//# sourceURL=webpack://brainwave/../../../themes/leocar/assets/src/scripts/index.js?");

/***/ }),

/***/ "../../../themes/leocar/assets/src/scripts/utils/catalog.js":
/*!******************************************************************!*\
  !*** ../../../themes/leocar/assets/src/scripts/utils/catalog.js ***!
  \******************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ catalog; }\n/* harmony export */ });\nfunction catalog() {\n  let body = document.body;\n  let catalog = document.querySelector('.leo-catalog .catalog-list');\n  if (catalog) {\n    let catalogItems = catalog.querySelectorAll('.catalog-item:not(.catalog-item-require)');\n    catalogItems.forEach(item => {\n      let leaseItems = item.querySelectorAll('ul.lease li');\n      item.querySelector('.amount').innerHTML = item.querySelector('ul.lease li.active').getAttribute('data-price');\n      leaseItems.forEach(lease => {\n        let price = lease.getAttribute('data-price');\n        lease.addEventListener('click', () => {\n          leaseItems.forEach(allItems => allItems.classList.remove('active'));\n          lease.classList.add('active');\n          item.querySelector('.amount').innerHTML = lease.getAttribute('data-price');\n        });\n      });\n    });\n  }\n  let catalogBtn = document.querySelector('.leo-catalog .show-catalog');\n  if (catalogBtn) {\n    catalogBtn.addEventListener('click', () => {\n      catalog.classList.toggle('open');\n      if (catalogBtn.textContent === \"Показати все\") {\n        catalogBtn.textContent = \"Приховати\";\n      } else {\n        catalogBtn.textContent = \"Показати все\";\n      }\n    });\n  }\n  //\n  // let flipItems = document.querySelectorAll('.leo-catalog .flip-card');\n  // if(flipItems) {\n  //     flipItems.forEach(item => {\n  //         item.addEventListener('click', () => {\n  //             flipItems.forEach(allItems => allItems.classList.remove('flipped'));\n  //             item.classList.toggle('flipped');\n  //         });\n  //     });\n  // }\n\n  let chooseCar = document.querySelector('button.choose-car');\n}\n\n//# sourceURL=webpack://brainwave/../../../themes/leocar/assets/src/scripts/utils/catalog.js?");

/***/ }),

/***/ "../../../themes/leocar/assets/src/scripts/utils/datepicker-full.js":
/*!**************************************************************************!*\
  !*** ../../../themes/leocar/assets/src/scripts/utils/datepicker-full.js ***!
  \**************************************************************************/
/***/ (function() {

eval("(function () {\n  'use strict';\n\n  function lastItemOf(arr) {\n    return arr[arr.length - 1];\n  }\n\n  // push only the items not included in the array\n  function pushUnique(arr) {\n    for (var _len = arguments.length, items = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      items[_key - 1] = arguments[_key];\n    }\n    items.forEach(item => {\n      if (arr.includes(item)) {\n        return;\n      }\n      arr.push(item);\n    });\n    return arr;\n  }\n  function stringToArray(str, separator) {\n    // convert empty string to an empty array\n    return str ? str.split(separator) : [];\n  }\n  function isInRange(testVal, min, max) {\n    const minOK = min === undefined || testVal >= min;\n    const maxOK = max === undefined || testVal <= max;\n    return minOK && maxOK;\n  }\n  function limitToRange(val, min, max) {\n    if (val < min) {\n      return min;\n    }\n    if (val > max) {\n      return max;\n    }\n    return val;\n  }\n  function createTagRepeat(tagName, repeat) {\n    let attributes = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    let index = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n    let html = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : '';\n    const openTagSrc = Object.keys(attributes).reduce((src, attr) => {\n      let val = attributes[attr];\n      if (typeof val === 'function') {\n        val = val(index);\n      }\n      return `${src} ${attr}=\"${val}\"`;\n    }, tagName);\n    html += `<${openTagSrc}></${tagName}>`;\n    const next = index + 1;\n    return next < repeat ? createTagRepeat(tagName, repeat, attributes, next, html) : html;\n  }\n\n  // Remove the spacing surrounding tags for HTML parser not to create text nodes\n  // before/after elements\n  function optimizeTemplateHTML(html) {\n    return html.replace(/>\\s+/g, '>').replace(/\\s+</, '<');\n  }\n  function stripTime(timeValue) {\n    return new Date(timeValue).setHours(0, 0, 0, 0);\n  }\n  function today() {\n    return new Date().setHours(0, 0, 0, 0);\n  }\n\n  // Get the time value of the start of given date or year, month and day\n  function dateValue() {\n    switch (arguments.length) {\n      case 0:\n        return today();\n      case 1:\n        return stripTime(arguments.length <= 0 ? undefined : arguments[0]);\n    }\n\n    // use setFullYear() to keep 2-digit year from being mapped to 1900-1999\n    const newDate = new Date(0);\n    newDate.setFullYear(...arguments);\n    return newDate.setHours(0, 0, 0, 0);\n  }\n  function addDays(date, amount) {\n    const newDate = new Date(date);\n    return newDate.setDate(newDate.getDate() + amount);\n  }\n  function addWeeks(date, amount) {\n    return addDays(date, amount * 7);\n  }\n  function addMonths(date, amount) {\n    // If the day of the date is not in the new month, the last day of the new\n    // month will be returned. e.g. Jan 31 + 1 month → Feb 28 (not Mar 03)\n    const newDate = new Date(date);\n    const monthsToSet = newDate.getMonth() + amount;\n    let expectedMonth = monthsToSet % 12;\n    if (expectedMonth < 0) {\n      expectedMonth += 12;\n    }\n    const time = newDate.setMonth(monthsToSet);\n    return newDate.getMonth() !== expectedMonth ? newDate.setDate(0) : time;\n  }\n  function addYears(date, amount) {\n    // If the date is Feb 29 and the new year is not a leap year, Feb 28 of the\n    // new year will be returned.\n    const newDate = new Date(date);\n    const expectedMonth = newDate.getMonth();\n    const time = newDate.setFullYear(newDate.getFullYear() + amount);\n    return expectedMonth === 1 && newDate.getMonth() === 2 ? newDate.setDate(0) : time;\n  }\n\n  // Calculate the distance bettwen 2 days of the week\n  function dayDiff(day, from) {\n    return (day - from + 7) % 7;\n  }\n\n  // Get the date of the specified day of the week of given base date\n  function dayOfTheWeekOf(baseDate, dayOfWeek) {\n    let weekStart = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n    const baseDay = new Date(baseDate).getDay();\n    return addDays(baseDate, dayDiff(dayOfWeek, weekStart) - dayDiff(baseDay, weekStart));\n  }\n  function calcWeekNum(dayOfTheWeek, sameDayOfFirstWeek) {\n    return Math.round((dayOfTheWeek - sameDayOfFirstWeek) / 604800000) + 1;\n  }\n\n  // Get the ISO week number of a date\n  function getIsoWeek(date) {\n    // - Start of ISO week is Monday\n    // - Use Thursday for culculation because the first Thursday of ISO week is\n    //   always in January\n    const thuOfTheWeek = dayOfTheWeekOf(date, 4, 1);\n    // - Week 1 in ISO week is the week including Jan 04\n    // - Use the Thu of given date's week (instead of given date itself) to\n    //   calculate week 1 of the year so that Jan 01 - 03 won't be miscalculated\n    //   as week 0 when Jan 04 is Mon - Wed\n    const firstThu = dayOfTheWeekOf(new Date(thuOfTheWeek).setMonth(0, 4), 4, 1);\n    // return Math.round((thuOfTheWeek - firstThu) / 604800000) + 1;\n    return calcWeekNum(thuOfTheWeek, firstThu);\n  }\n\n  // Calculate week number in traditional week number system\n  // @see https://en.wikipedia.org/wiki/Week#Other_week_numbering_systems\n  function calcTraditionalWeekNumber(date, weekStart) {\n    // - Week 1 of traditional week is the week including the Jan 01\n    // - Use Jan 01 of given date's year to calculate the start of week 1\n    const startOfFirstWeek = dayOfTheWeekOf(new Date(date).setMonth(0, 1), weekStart, weekStart);\n    const startOfTheWeek = dayOfTheWeekOf(date, weekStart, weekStart);\n    const weekNum = calcWeekNum(startOfTheWeek, startOfFirstWeek);\n    if (weekNum < 53) {\n      return weekNum;\n    }\n    // If the 53rd week includes Jan 01, it's actually next year's week 1\n    const weekOneOfNextYear = dayOfTheWeekOf(new Date(date).setDate(32), weekStart, weekStart);\n    return startOfTheWeek === weekOneOfNextYear ? 1 : weekNum;\n  }\n\n  // Get the Western traditional week number of a date\n  function getWesternTradWeek(date) {\n    // Start of Western traditionl week is Sunday\n    return calcTraditionalWeekNumber(date, 0);\n  }\n\n  // Get the Middle Eastern week number of a date\n  function getMidEasternWeek(date) {\n    // Start of Middle Eastern week is Saturday\n    return calcTraditionalWeekNumber(date, 6);\n  }\n\n  // Get the start year of the period of years that includes given date\n  // years: length of the year period\n  function startOfYearPeriod(date, years) {\n    /* @see https://en.wikipedia.org/wiki/Year_zero#ISO_8601 */\n    const year = new Date(date).getFullYear();\n    return Math.floor(year / years) * years;\n  }\n\n  // Convert date to the first/last date of the month/year of the date\n  function regularizeDate(date, timeSpan, useLastDate) {\n    if (timeSpan !== 1 && timeSpan !== 2) {\n      return date;\n    }\n    const newDate = new Date(date);\n    if (timeSpan === 1) {\n      useLastDate ? newDate.setMonth(newDate.getMonth() + 1, 0) : newDate.setDate(1);\n    } else {\n      useLastDate ? newDate.setFullYear(newDate.getFullYear() + 1, 0, 0) : newDate.setMonth(0, 1);\n    }\n    return newDate.setHours(0, 0, 0, 0);\n  }\n\n  // pattern for format parts\n  const reFormatTokens = /dd?|DD?|mm?|MM?|yy?(?:yy)?/;\n  // pattern for non date parts\n  const reNonDateParts = /[\\s!-/:-@[-`{-~年月日]+/;\n  // cache for persed formats\n  let knownFormats = {};\n  // parse funtions for date parts\n  const parseFns = {\n    y(date, year) {\n      return new Date(date).setFullYear(parseInt(year, 10));\n    },\n    m(date, month, locale) {\n      const newDate = new Date(date);\n      let monthIndex = parseInt(month, 10) - 1;\n      if (isNaN(monthIndex)) {\n        if (!month) {\n          return NaN;\n        }\n        const monthName = month.toLowerCase();\n        const compareNames = name => name.toLowerCase().startsWith(monthName);\n        // compare with both short and full names because some locales have periods\n        // in the short names (not equal to the first X letters of the full names)\n        monthIndex = locale.monthsShort.findIndex(compareNames);\n        if (monthIndex < 0) {\n          monthIndex = locale.months.findIndex(compareNames);\n        }\n        if (monthIndex < 0) {\n          return NaN;\n        }\n      }\n      newDate.setMonth(monthIndex);\n      return newDate.getMonth() !== normalizeMonth(monthIndex) ? newDate.setDate(0) : newDate.getTime();\n    },\n    d(date, day) {\n      return new Date(date).setDate(parseInt(day, 10));\n    }\n  };\n  // format functions for date parts\n  const formatFns = {\n    d(date) {\n      return date.getDate();\n    },\n    dd(date) {\n      return padZero(date.getDate(), 2);\n    },\n    D(date, locale) {\n      return locale.daysShort[date.getDay()];\n    },\n    DD(date, locale) {\n      return locale.days[date.getDay()];\n    },\n    m(date) {\n      return date.getMonth() + 1;\n    },\n    mm(date) {\n      return padZero(date.getMonth() + 1, 2);\n    },\n    M(date, locale) {\n      return locale.monthsShort[date.getMonth()];\n    },\n    MM(date, locale) {\n      return locale.months[date.getMonth()];\n    },\n    y(date) {\n      return date.getFullYear();\n    },\n    yy(date) {\n      return padZero(date.getFullYear(), 2).slice(-2);\n    },\n    yyyy(date) {\n      return padZero(date.getFullYear(), 4);\n    }\n  };\n\n  // get month index in normal range (0 - 11) from any number\n  function normalizeMonth(monthIndex) {\n    return monthIndex > -1 ? monthIndex % 12 : normalizeMonth(monthIndex + 12);\n  }\n  function padZero(num, length) {\n    return num.toString().padStart(length, '0');\n  }\n  function parseFormatString(format) {\n    if (typeof format !== 'string') {\n      throw new Error(\"Invalid date format.\");\n    }\n    if (format in knownFormats) {\n      return knownFormats[format];\n    }\n\n    // sprit the format string into parts and seprators\n    const separators = format.split(reFormatTokens);\n    const parts = format.match(new RegExp(reFormatTokens, 'g'));\n    if (separators.length === 0 || !parts) {\n      throw new Error(\"Invalid date format.\");\n    }\n\n    // collect format functions used in the format\n    const partFormatters = parts.map(token => formatFns[token]);\n\n    // collect parse function keys used in the format\n    // iterate over parseFns' keys in order to keep the order of the keys.\n    const partParserKeys = Object.keys(parseFns).reduce((keys, key) => {\n      const token = parts.find(part => part[0] !== 'D' && part[0].toLowerCase() === key);\n      if (token) {\n        keys.push(key);\n      }\n      return keys;\n    }, []);\n    return knownFormats[format] = {\n      parser(dateStr, locale) {\n        const dateParts = dateStr.split(reNonDateParts).reduce((dtParts, part, index) => {\n          if (part.length > 0 && parts[index]) {\n            const token = parts[index][0];\n            if (token === 'M') {\n              dtParts.m = part;\n            } else if (token !== 'D') {\n              dtParts[token] = part;\n            }\n          }\n          return dtParts;\n        }, {});\n\n        // iterate over partParserkeys so that the parsing is made in the oder\n        // of year, month and day to prevent the day parser from correcting last\n        // day of month wrongly\n        return partParserKeys.reduce((origDate, key) => {\n          const newDate = parseFns[key](origDate, dateParts[key], locale);\n          // ingnore the part failed to parse\n          return isNaN(newDate) ? origDate : newDate;\n        }, today());\n      },\n      formatter(date, locale) {\n        let dateStr = partFormatters.reduce((str, fn, index) => {\n          return str += `${separators[index]}${fn(date, locale)}`;\n        }, '');\n        // separators' length is always parts' length + 1,\n        return dateStr += lastItemOf(separators);\n      }\n    };\n  }\n  function parseDate(dateStr, format, locale) {\n    if (dateStr instanceof Date || typeof dateStr === 'number') {\n      const date = stripTime(dateStr);\n      return isNaN(date) ? undefined : date;\n    }\n    if (!dateStr) {\n      return undefined;\n    }\n    if (dateStr === 'today') {\n      return today();\n    }\n    if (format && format.toValue) {\n      const date = format.toValue(dateStr, format, locale);\n      return isNaN(date) ? undefined : stripTime(date);\n    }\n    return parseFormatString(format).parser(dateStr, locale);\n  }\n  function formatDate(date, format, locale) {\n    if (isNaN(date) || !date && date !== 0) {\n      return '';\n    }\n    const dateObj = typeof date === 'number' ? new Date(date) : date;\n    if (format.toDisplay) {\n      return format.toDisplay(dateObj, format, locale);\n    }\n    return parseFormatString(format).formatter(dateObj, locale);\n  }\n  const range = document.createRange();\n  function parseHTML(html) {\n    return range.createContextualFragment(html);\n  }\n  function getParent(el) {\n    return el.parentElement || (el.parentNode instanceof ShadowRoot ? el.parentNode.host : undefined);\n  }\n  function isActiveElement(el) {\n    return el.getRootNode().activeElement === el;\n  }\n  function hideElement(el) {\n    if (el.style.display === 'none') {\n      return;\n    }\n    // back up the existing display setting in data-style-display\n    if (el.style.display) {\n      el.dataset.styleDisplay = el.style.display;\n    }\n    el.style.display = 'none';\n  }\n  function showElement(el) {\n    if (el.style.display !== 'none') {\n      return;\n    }\n    if (el.dataset.styleDisplay) {\n      // restore backed-up dispay property\n      el.style.display = el.dataset.styleDisplay;\n      delete el.dataset.styleDisplay;\n    } else {\n      el.style.display = '';\n    }\n  }\n  function emptyChildNodes(el) {\n    if (el.firstChild) {\n      el.removeChild(el.firstChild);\n      emptyChildNodes(el);\n    }\n  }\n  function replaceChildNodes(el, newChildNodes) {\n    emptyChildNodes(el);\n    if (newChildNodes instanceof DocumentFragment) {\n      el.appendChild(newChildNodes);\n    } else if (typeof newChildNodes === 'string') {\n      el.appendChild(parseHTML(newChildNodes));\n    } else if (typeof newChildNodes.forEach === 'function') {\n      newChildNodes.forEach(node => {\n        el.appendChild(node);\n      });\n    }\n  }\n  const listenerRegistry = new WeakMap();\n  const {\n    addEventListener,\n    removeEventListener\n  } = EventTarget.prototype;\n\n  // Register event listeners to a key object\n  // listeners: array of listener definitions;\n  //   - each definition must be a flat array of event target and the arguments\n  //     used to call addEventListener() on the target\n  function registerListeners(keyObj, listeners) {\n    let registered = listenerRegistry.get(keyObj);\n    if (!registered) {\n      registered = [];\n      listenerRegistry.set(keyObj, registered);\n    }\n    listeners.forEach(listener => {\n      addEventListener.call(...listener);\n      registered.push(listener);\n    });\n  }\n  function unregisterListeners(keyObj) {\n    let listeners = listenerRegistry.get(keyObj);\n    if (!listeners) {\n      return;\n    }\n    listeners.forEach(listener => {\n      removeEventListener.call(...listener);\n    });\n    listenerRegistry.delete(keyObj);\n  }\n\n  // Event.composedPath() polyfill for Edge\n  // based on https://gist.github.com/kleinfreund/e9787d73776c0e3750dcfcdc89f100ec\n  if (!Event.prototype.composedPath) {\n    const getComposedPath = function (node) {\n      let path = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n      path.push(node);\n      let parent;\n      if (node.parentNode) {\n        parent = node.parentNode;\n      } else if (node.host) {\n        // ShadowRoot\n        parent = node.host;\n      } else if (node.defaultView) {\n        // Document\n        parent = node.defaultView;\n      }\n      return parent ? getComposedPath(parent, path) : path;\n    };\n    Event.prototype.composedPath = function () {\n      return getComposedPath(this.target);\n    };\n  }\n  function findFromPath(path, criteria, currentTarget) {\n    const [node, ...rest] = path;\n    if (criteria(node)) {\n      return node;\n    }\n    if (node === currentTarget || node.tagName === 'HTML' || rest.length === 0) {\n      // stop when reaching currentTarget or <html>\n      return;\n    }\n    return findFromPath(rest, criteria, currentTarget);\n  }\n\n  // Search for the actual target of a delegated event\n  function findElementInEventPath(ev, selector) {\n    const criteria = typeof selector === 'function' ? selector : el => el instanceof Element && el.matches(selector);\n    return findFromPath(ev.composedPath(), criteria, ev.currentTarget);\n  }\n\n  // default locales\n  const locales = {\n    en: {\n      days: [\"Неділя\", \"Понеділок\", \"Вівторок\", \"Середа\", \"Четвер\", \"П'ятниця\", \"Субота\"],\n      daysShort: [\"Нед\", \"Пон\", \"Вів\", \"Сер\", \"Чет\", \"П'ят\", \"Суб\"],\n      daysMin: [\"Нд\", \"Пн\", \"Вт\", \"Ср\", \"Чт\", \"Пт\", \"Сб\"],\n      months: [\"Січень\", \"Лютий\", \"Березень\", \"Квітень\", \"Травень\", \"Червень\", \"Липень\", \"Серпень\", \"Вересень\", \"Жовтень\", \"Листопад\", \"Грудень\"],\n      monthsShort: [\"Січ\", \"Лют\", \"Бер\", \"Кві\", \"Тра\", \"Чер\", \"Лип\", \"Сер\", \"Вер\", \"Жов\", \"Лис\", \"Гру\"],\n      today: \"Сьогодні\",\n      clear: \"Очистити\",\n      titleFormat: \"MM y\"\n    }\n  };\n\n  // config options updatable by setOptions() and their default values\n  const defaultOptions = {\n    autohide: false,\n    beforeShowDay: null,\n    beforeShowDecade: null,\n    beforeShowMonth: null,\n    beforeShowYear: null,\n    clearButton: false,\n    dateDelimiter: ',',\n    datesDisabled: [],\n    daysOfWeekDisabled: [],\n    daysOfWeekHighlighted: [],\n    defaultViewDate: undefined,\n    // placeholder, defaults to today() by the program\n    disableTouchKeyboard: false,\n    enableOnReadonly: true,\n    format: 'mm/dd/yyyy',\n    language: 'en',\n    maxDate: null,\n    maxNumberOfDates: 1,\n    maxView: 3,\n    minDate: null,\n    nextArrow: '»',\n    orientation: 'auto',\n    pickLevel: 0,\n    prevArrow: '«',\n    showDaysOfWeek: true,\n    showOnClick: true,\n    showOnFocus: true,\n    startView: 0,\n    title: '',\n    todayButton: false,\n    todayButtonMode: 0,\n    todayHighlight: false,\n    updateOnBlur: true,\n    weekNumbers: 0,\n    weekStart: 0\n  };\n  const {\n    language: defaultLang,\n    format: defaultFormat,\n    weekStart: defaultWeekStart\n  } = defaultOptions;\n\n  // Reducer function to filter out invalid day-of-week from the input\n  function sanitizeDOW(dow, day) {\n    return dow.length < 6 && day >= 0 && day < 7 ? pushUnique(dow, day) : dow;\n  }\n  function determineGetWeekMethod(numberingMode, weekStart) {\n    const methodId = numberingMode === 4 ? weekStart === 6 ? 3 : !weekStart + 1 : numberingMode;\n    switch (methodId) {\n      case 1:\n        return getIsoWeek;\n      case 2:\n        return getWesternTradWeek;\n      case 3:\n        return getMidEasternWeek;\n    }\n  }\n  function updateWeekStart(newValue, config, weekNumbers) {\n    config.weekStart = newValue;\n    config.weekEnd = (newValue + 6) % 7;\n    if (weekNumbers === 4) {\n      config.getWeekNumber = determineGetWeekMethod(4, newValue);\n    }\n    return newValue;\n  }\n\n  // validate input date. if invalid, fallback to the original value\n  function validateDate(value, format, locale, origValue) {\n    const date = parseDate(value, format, locale);\n    return date !== undefined ? date : origValue;\n  }\n\n  // Validate viewId. if invalid, fallback to the original value\n  function validateViewId(value, origValue) {\n    let max = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 3;\n    const viewId = parseInt(value, 10);\n    return viewId >= 0 && viewId <= max ? viewId : origValue;\n  }\n  function replaceOptions(options, from, to) {\n    let convert = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : undefined;\n    if (from in options) {\n      if (!(to in options)) {\n        options[to] = convert ? convert(options[from]) : options[from];\n      }\n      delete options[from];\n    }\n  }\n\n  // Create Datepicker configuration to set\n  function processOptions(options, datepicker) {\n    const inOpts = Object.assign({}, options);\n    const config = {};\n    const locales = datepicker.constructor.locales;\n    const rangeEnd = !!datepicker.rangeSideIndex;\n    let {\n      datesDisabled,\n      format,\n      language,\n      locale,\n      maxDate,\n      maxView,\n      minDate,\n      pickLevel,\n      startView,\n      weekNumbers,\n      weekStart\n    } = datepicker.config || {};\n\n    // for backword compatibility\n    replaceOptions(inOpts, 'calendarWeeks', 'weekNumbers', val => val ? 1 : 0);\n    replaceOptions(inOpts, 'clearBtn', 'clearButton');\n    replaceOptions(inOpts, 'todayBtn', 'todayButton');\n    replaceOptions(inOpts, 'todayBtnMode', 'todayButtonMode');\n    if (inOpts.language) {\n      let lang;\n      if (inOpts.language !== language) {\n        if (locales[inOpts.language]) {\n          lang = inOpts.language;\n        } else {\n          // Check if langauge + region tag can fallback to the one without\n          // region (e.g. fr-CA → fr)\n          lang = inOpts.language.split('-')[0];\n          if (!locales[lang]) {\n            lang = false;\n          }\n        }\n      }\n      delete inOpts.language;\n      if (lang) {\n        language = config.language = lang;\n\n        // update locale as well when updating language\n        const origLocale = locale || locales[defaultLang];\n        // use default language's properties for the fallback\n        locale = Object.assign({\n          format: defaultFormat,\n          weekStart: defaultWeekStart\n        }, locales[defaultLang]);\n        if (language !== defaultLang) {\n          Object.assign(locale, locales[language]);\n        }\n        config.locale = locale;\n        // if format and/or weekStart are the same as old locale's defaults,\n        // update them to new locale's defaults\n        if (format === origLocale.format) {\n          format = config.format = locale.format;\n        }\n        if (weekStart === origLocale.weekStart) {\n          weekStart = updateWeekStart(locale.weekStart, config, weekNumbers);\n        }\n      }\n    }\n    if (inOpts.format) {\n      const hasToDisplay = typeof inOpts.format.toDisplay === 'function';\n      const hasToValue = typeof inOpts.format.toValue === 'function';\n      const validFormatString = reFormatTokens.test(inOpts.format);\n      if (hasToDisplay && hasToValue || validFormatString) {\n        format = config.format = inOpts.format;\n      }\n      delete inOpts.format;\n    }\n\n    //*** pick level ***//\n    let newPickLevel = pickLevel;\n    if ('pickLevel' in inOpts) {\n      newPickLevel = validateViewId(inOpts.pickLevel, pickLevel, 2);\n      delete inOpts.pickLevel;\n    }\n    if (newPickLevel !== pickLevel) {\n      if (newPickLevel > pickLevel) {\n        // complement current minDate/madDate so that the existing range will be\n        // expanded to fit the new level later\n        if (!('minDate' in inOpts)) {\n          inOpts.minDate = minDate;\n        }\n        if (!('maxDate' in inOpts)) {\n          inOpts.maxDate = maxDate;\n        }\n      }\n      // complement datesDisabled so that it will be reset later\n      if (datesDisabled && !inOpts.datesDisabled) {\n        inOpts.datesDisabled = [];\n      }\n      pickLevel = config.pickLevel = newPickLevel;\n    }\n\n    //*** dates ***//\n    // while min and maxDate for \"no limit\" in the options are better to be null\n    // (especially when updating), the ones in the config have to be undefined\n    // because null is treated as 0 (= unix epoch) when comparing with time value\n    let minDt = minDate;\n    let maxDt = maxDate;\n    if ('minDate' in inOpts) {\n      const defaultMinDt = dateValue(0, 0, 1);\n      minDt = inOpts.minDate === null ? defaultMinDt // set 0000-01-01 to prevent negative values for year\n      : validateDate(inOpts.minDate, format, locale, minDt);\n      if (minDt !== defaultMinDt) {\n        minDt = regularizeDate(minDt, pickLevel, false);\n      }\n      delete inOpts.minDate;\n    }\n    if ('maxDate' in inOpts) {\n      maxDt = inOpts.maxDate === null ? undefined : validateDate(inOpts.maxDate, format, locale, maxDt);\n      if (maxDt !== undefined) {\n        maxDt = regularizeDate(maxDt, pickLevel, true);\n      }\n      delete inOpts.maxDate;\n    }\n    if (maxDt < minDt) {\n      minDate = config.minDate = maxDt;\n      maxDate = config.maxDate = minDt;\n    } else {\n      if (minDate !== minDt) {\n        minDate = config.minDate = minDt;\n      }\n      if (maxDate !== maxDt) {\n        maxDate = config.maxDate = maxDt;\n      }\n    }\n    if (inOpts.datesDisabled) {\n      const dtsDisabled = inOpts.datesDisabled;\n      if (typeof dtsDisabled === 'function') {\n        config.datesDisabled = null;\n        config.checkDisabled = (timeValue, viewId) => dtsDisabled(new Date(timeValue), viewId, rangeEnd);\n      } else {\n        const disabled = config.datesDisabled = dtsDisabled.reduce((dates, dt) => {\n          const date = parseDate(dt, format, locale);\n          return date !== undefined ? pushUnique(dates, regularizeDate(date, pickLevel, rangeEnd)) : dates;\n        }, []);\n        config.checkDisabled = timeValue => disabled.includes(timeValue);\n      }\n      delete inOpts.datesDisabled;\n    }\n    if ('defaultViewDate' in inOpts) {\n      const viewDate = parseDate(inOpts.defaultViewDate, format, locale);\n      if (viewDate !== undefined) {\n        config.defaultViewDate = viewDate;\n      }\n      delete inOpts.defaultViewDate;\n    }\n\n    //*** days of week ***//\n    if ('weekStart' in inOpts) {\n      const wkStart = Number(inOpts.weekStart) % 7;\n      if (!isNaN(wkStart)) {\n        weekStart = updateWeekStart(wkStart, config, weekNumbers);\n      }\n      delete inOpts.weekStart;\n    }\n    if (inOpts.daysOfWeekDisabled) {\n      config.daysOfWeekDisabled = inOpts.daysOfWeekDisabled.reduce(sanitizeDOW, []);\n      delete inOpts.daysOfWeekDisabled;\n    }\n    if (inOpts.daysOfWeekHighlighted) {\n      config.daysOfWeekHighlighted = inOpts.daysOfWeekHighlighted.reduce(sanitizeDOW, []);\n      delete inOpts.daysOfWeekHighlighted;\n    }\n\n    //*** week numbers ***//\n    if ('weekNumbers' in inOpts) {\n      let method = inOpts.weekNumbers;\n      if (method) {\n        const getWeekNumber = typeof method === 'function' ? (timeValue, startOfWeek) => method(new Date(timeValue), startOfWeek) : determineGetWeekMethod(method = parseInt(method, 10), weekStart);\n        if (getWeekNumber) {\n          weekNumbers = config.weekNumbers = method;\n          config.getWeekNumber = getWeekNumber;\n        }\n      } else {\n        weekNumbers = config.weekNumbers = 0;\n        config.getWeekNumber = null;\n      }\n      delete inOpts.weekNumbers;\n    }\n\n    //*** multi date ***//\n    if ('maxNumberOfDates' in inOpts) {\n      const maxNumberOfDates = parseInt(inOpts.maxNumberOfDates, 10);\n      if (maxNumberOfDates >= 0) {\n        config.maxNumberOfDates = maxNumberOfDates;\n        config.multidate = maxNumberOfDates !== 1;\n      }\n      delete inOpts.maxNumberOfDates;\n    }\n    if (inOpts.dateDelimiter) {\n      config.dateDelimiter = String(inOpts.dateDelimiter);\n      delete inOpts.dateDelimiter;\n    }\n\n    //*** view ***//\n    let newMaxView = maxView;\n    if ('maxView' in inOpts) {\n      newMaxView = validateViewId(inOpts.maxView, maxView);\n      delete inOpts.maxView;\n    }\n    // ensure max view >= pick level\n    newMaxView = pickLevel > newMaxView ? pickLevel : newMaxView;\n    if (newMaxView !== maxView) {\n      maxView = config.maxView = newMaxView;\n    }\n    let newStartView = startView;\n    if ('startView' in inOpts) {\n      newStartView = validateViewId(inOpts.startView, newStartView);\n      delete inOpts.startView;\n    }\n    // ensure pick level <= start view <= max view\n    if (newStartView < pickLevel) {\n      newStartView = pickLevel;\n    } else if (newStartView > maxView) {\n      newStartView = maxView;\n    }\n    if (newStartView !== startView) {\n      config.startView = newStartView;\n    }\n\n    //*** template ***//\n    if (inOpts.prevArrow) {\n      const prevArrow = parseHTML(inOpts.prevArrow);\n      if (prevArrow.childNodes.length > 0) {\n        config.prevArrow = prevArrow.childNodes;\n      }\n      delete inOpts.prevArrow;\n    }\n    if (inOpts.nextArrow) {\n      const nextArrow = parseHTML(inOpts.nextArrow);\n      if (nextArrow.childNodes.length > 0) {\n        config.nextArrow = nextArrow.childNodes;\n      }\n      delete inOpts.nextArrow;\n    }\n\n    //*** misc ***//\n    if ('disableTouchKeyboard' in inOpts) {\n      config.disableTouchKeyboard = 'ontouchstart' in document && !!inOpts.disableTouchKeyboard;\n      delete inOpts.disableTouchKeyboard;\n    }\n    if (inOpts.orientation) {\n      const orientation = inOpts.orientation.toLowerCase().split(/\\s+/g);\n      config.orientation = {\n        x: orientation.find(x => x === 'left' || x === 'right') || 'auto',\n        y: orientation.find(y => y === 'top' || y === 'bottom') || 'auto'\n      };\n      delete inOpts.orientation;\n    }\n    if ('todayButtonMode' in inOpts) {\n      switch (inOpts.todayButtonMode) {\n        case 0:\n        case 1:\n          config.todayButtonMode = inOpts.todayButtonMode;\n      }\n      delete inOpts.todayButtonMode;\n    }\n\n    //*** copy the rest ***//\n    Object.entries(inOpts).forEach(_ref => {\n      let [key, value] = _ref;\n      if (value !== undefined && key in defaultOptions) {\n        config[key] = value;\n      }\n    });\n    return config;\n  }\n  const defaultShortcutKeys = {\n    show: {\n      key: 'ArrowDown'\n    },\n    hide: null,\n    toggle: {\n      key: 'Escape'\n    },\n    prevButton: {\n      key: 'ArrowLeft',\n      ctrlOrMetaKey: true\n    },\n    nextButton: {\n      key: 'ArrowRight',\n      ctrlOrMetaKey: true\n    },\n    viewSwitch: {\n      key: 'ArrowUp',\n      ctrlOrMetaKey: true\n    },\n    clearButton: {\n      key: 'Backspace',\n      ctrlOrMetaKey: true\n    },\n    todayButton: {\n      key: '.',\n      ctrlOrMetaKey: true\n    },\n    exitEditMode: {\n      key: 'ArrowDown',\n      ctrlOrMetaKey: true\n    }\n  };\n  function createShortcutKeyConfig(options) {\n    return Object.keys(defaultShortcutKeys).reduce((keyDefs, shortcut) => {\n      const keyDef = options[shortcut] === undefined ? defaultShortcutKeys[shortcut] : options[shortcut];\n      const key = keyDef && keyDef.key;\n      if (!key || typeof key !== 'string') {\n        return keyDefs;\n      }\n      const normalizedDef = {\n        key,\n        ctrlOrMetaKey: !!(keyDef.ctrlOrMetaKey || keyDef.ctrlKey || keyDef.metaKey)\n      };\n      if (key.length > 1) {\n        normalizedDef.altKey = !!keyDef.altKey;\n        normalizedDef.shiftKey = !!keyDef.shiftKey;\n      }\n      keyDefs[shortcut] = normalizedDef;\n      return keyDefs;\n    }, {});\n  }\n  const getButtons = buttonList => buttonList.map(classes => `<button type=\"button\" class=\"%buttonClass% ${classes}\" tabindex=\"-1\"></button>`).join('');\n  const pickerTemplate = optimizeTemplateHTML(`<div class=\"datepicker\">\n  <div class=\"datepicker-picker\">\n    <div class=\"datepicker-header\">\n      <div class=\"datepicker-title\"></div>\n      <div class=\"datepicker-controls\">\n        ${getButtons(['prev-button prev-btn', 'view-switch', 'next-button next-btn'])}\n      </div>\n    </div>\n    <div class=\"datepicker-main\"></div>\n    <div class=\"datepicker-footer\">\n      <div class=\"datepicker-controls\">\n        ${getButtons(['today-button today-btn', 'clear-button clear-btn'])}\n      </div>\n    </div>\n  </div>\n</div>`);\n  const daysTemplate = optimizeTemplateHTML(`<div class=\"days\">\n  <div class=\"days-of-week\">${createTagRepeat('span', 7, {\n    class: 'dow'\n  })}</div>\n  <div class=\"datepicker-grid\">${createTagRepeat('span', 42)}</div>\n</div>`);\n  const weekNumbersTemplate = optimizeTemplateHTML(`<div class=\"week-numbers calendar-weeks\">\n  <div class=\"days-of-week\"><span class=\"dow\"></span></div>\n  <div class=\"weeks\">${createTagRepeat('span', 6, {\n    class: 'week'\n  })}</div>\n</div>`);\n\n  // Base class of the view classes\n  class View {\n    constructor(picker, config) {\n      Object.assign(this, config, {\n        picker,\n        element: parseHTML(`<div class=\"datepicker-view\"></div>`).firstChild,\n        selected: [],\n        isRangeEnd: !!picker.datepicker.rangeSideIndex\n      });\n      this.init(this.picker.datepicker.config);\n    }\n    init(options) {\n      if ('pickLevel' in options) {\n        this.isMinView = this.id === options.pickLevel;\n      }\n      this.setOptions(options);\n      this.updateFocus();\n      this.updateSelection();\n    }\n    prepareForRender(switchLabel, prevButtonDisabled, nextButtonDisabled) {\n      // refresh disabled years on every render in order to clear the ones added\n      // by beforeShow hook at previous render\n      this.disabled = [];\n      const picker = this.picker;\n      picker.setViewSwitchLabel(switchLabel);\n      picker.setPrevButtonDisabled(prevButtonDisabled);\n      picker.setNextButtonDisabled(nextButtonDisabled);\n    }\n    setDisabled(date, classList) {\n      classList.add('disabled');\n      pushUnique(this.disabled, date);\n    }\n\n    // Execute beforeShow() callback and apply the result to the element\n    // args:\n    performBeforeHook(el, timeValue) {\n      let result = this.beforeShow(new Date(timeValue));\n      switch (typeof result) {\n        case 'boolean':\n          result = {\n            enabled: result\n          };\n          break;\n        case 'string':\n          result = {\n            classes: result\n          };\n      }\n      if (result) {\n        const classList = el.classList;\n        if (result.enabled === false) {\n          this.setDisabled(timeValue, classList);\n        }\n        if (result.classes) {\n          const extraClasses = result.classes.split(/\\s+/);\n          classList.add(...extraClasses);\n          if (extraClasses.includes('disabled')) {\n            this.setDisabled(timeValue, classList);\n          }\n        }\n        if (result.content) {\n          replaceChildNodes(el, result.content);\n        }\n      }\n    }\n    renderCell(el, content, cellVal, date, _ref2, outOfScope) {\n      let {\n        selected,\n        range\n      } = _ref2;\n      let extraClasses = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : [];\n      el.textContent = content;\n      if (this.isMinView) {\n        el.dataset.date = date;\n      }\n      const classList = el.classList;\n      el.className = `datepicker-cell ${this.cellClass}`;\n      if (cellVal < this.first) {\n        classList.add('prev');\n      } else if (cellVal > this.last) {\n        classList.add('next');\n      }\n      classList.add(...extraClasses);\n      if (outOfScope || this.checkDisabled(date, this.id)) {\n        this.setDisabled(date, classList);\n      }\n      if (range) {\n        const [rangeStart, rangeEnd] = range;\n        if (cellVal > rangeStart && cellVal < rangeEnd) {\n          classList.add('range');\n        }\n        if (cellVal === rangeStart) {\n          classList.add('range-start');\n        }\n        if (cellVal === rangeEnd) {\n          classList.add('range-end');\n        }\n      }\n      if (selected.includes(cellVal)) {\n        classList.add('selected');\n      }\n      if (cellVal === this.focused) {\n        classList.add('focused');\n      }\n      if (this.beforeShow) {\n        this.performBeforeHook(el, date);\n      }\n    }\n    refreshCell(el, cellVal, selected, _ref3) {\n      let [rangeStart, rangeEnd] = _ref3;\n      const classList = el.classList;\n      classList.remove('range', 'range-start', 'range-end', 'selected', 'focused');\n      if (cellVal > rangeStart && cellVal < rangeEnd) {\n        classList.add('range');\n      }\n      if (cellVal === rangeStart) {\n        classList.add('range-start');\n      }\n      if (cellVal === rangeEnd) {\n        classList.add('range-end');\n      }\n      if (selected.includes(cellVal)) {\n        classList.add('selected');\n      }\n      if (cellVal === this.focused) {\n        classList.add('focused');\n      }\n    }\n    changeFocusedCell(cellIndex) {\n      this.grid.querySelectorAll('.focused').forEach(el => {\n        el.classList.remove('focused');\n      });\n      this.grid.children[cellIndex].classList.add('focused');\n    }\n  }\n  class DaysView extends View {\n    constructor(picker) {\n      super(picker, {\n        id: 0,\n        name: 'days',\n        cellClass: 'day'\n      });\n    }\n    init(options) {\n      let onConstruction = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n      if (onConstruction) {\n        const inner = parseHTML(daysTemplate).firstChild;\n        this.dow = inner.firstChild;\n        this.grid = inner.lastChild;\n        this.element.appendChild(inner);\n      }\n      super.init(options);\n    }\n    setOptions(options) {\n      let updateDOW;\n      if ('minDate' in options) {\n        this.minDate = options.minDate;\n      }\n      if ('maxDate' in options) {\n        this.maxDate = options.maxDate;\n      }\n      if (options.checkDisabled) {\n        this.checkDisabled = options.checkDisabled;\n      }\n      if (options.daysOfWeekDisabled) {\n        this.daysOfWeekDisabled = options.daysOfWeekDisabled;\n        updateDOW = true;\n      }\n      if (options.daysOfWeekHighlighted) {\n        this.daysOfWeekHighlighted = options.daysOfWeekHighlighted;\n      }\n      if ('todayHighlight' in options) {\n        this.todayHighlight = options.todayHighlight;\n      }\n      if ('weekStart' in options) {\n        this.weekStart = options.weekStart;\n        this.weekEnd = options.weekEnd;\n        updateDOW = true;\n      }\n      if (options.locale) {\n        const locale = this.locale = options.locale;\n        this.dayNames = locale.daysMin;\n        this.switchLabelFormat = locale.titleFormat;\n        updateDOW = true;\n      }\n      if ('beforeShowDay' in options) {\n        this.beforeShow = typeof options.beforeShowDay === 'function' ? options.beforeShowDay : undefined;\n      }\n      if ('weekNumbers' in options) {\n        if (options.weekNumbers && !this.weekNumbers) {\n          const weeksElem = parseHTML(weekNumbersTemplate).firstChild;\n          this.weekNumbers = {\n            element: weeksElem,\n            dow: weeksElem.firstChild,\n            weeks: weeksElem.lastChild\n          };\n          this.element.insertBefore(weeksElem, this.element.firstChild);\n        } else if (this.weekNumbers && !options.weekNumbers) {\n          this.element.removeChild(this.weekNumbers.element);\n          this.weekNumbers = null;\n        }\n      }\n      if ('getWeekNumber' in options) {\n        this.getWeekNumber = options.getWeekNumber;\n      }\n      if ('showDaysOfWeek' in options) {\n        if (options.showDaysOfWeek) {\n          showElement(this.dow);\n          if (this.weekNumbers) {\n            showElement(this.weekNumbers.dow);\n          }\n        } else {\n          hideElement(this.dow);\n          if (this.weekNumbers) {\n            hideElement(this.weekNumbers.dow);\n          }\n        }\n      }\n\n      // update days-of-week when locale, daysOfweekDisabled or weekStart is changed\n      if (updateDOW) {\n        Array.from(this.dow.children).forEach((el, index) => {\n          const dow = (this.weekStart + index) % 7;\n          el.textContent = this.dayNames[dow];\n          el.className = this.daysOfWeekDisabled.includes(dow) ? 'dow disabled' : 'dow';\n        });\n      }\n    }\n\n    // Apply update on the focused date to view's settings\n    updateFocus() {\n      const viewDate = new Date(this.picker.viewDate);\n      const viewYear = viewDate.getFullYear();\n      const viewMonth = viewDate.getMonth();\n      const firstOfMonth = dateValue(viewYear, viewMonth, 1);\n      const start = dayOfTheWeekOf(firstOfMonth, this.weekStart, this.weekStart);\n      this.first = firstOfMonth;\n      this.last = dateValue(viewYear, viewMonth + 1, 0);\n      this.start = start;\n      this.focused = this.picker.viewDate;\n    }\n\n    // Apply update on the selected dates to view's settings\n    updateSelection() {\n      const {\n        dates,\n        rangepicker\n      } = this.picker.datepicker;\n      this.selected = dates;\n      if (rangepicker) {\n        this.range = rangepicker.dates;\n      }\n    }\n\n    // Update the entire view UI\n    render() {\n      // update today marker on ever render\n      this.today = this.todayHighlight ? today() : undefined;\n      this.prepareForRender(formatDate(this.focused, this.switchLabelFormat, this.locale), this.first <= this.minDate, this.last >= this.maxDate);\n      if (this.weekNumbers) {\n        const weekStart = this.weekStart;\n        const startOfWeek = dayOfTheWeekOf(this.first, weekStart, weekStart);\n        Array.from(this.weekNumbers.weeks.children).forEach((el, index) => {\n          const dateOfWeekStart = addWeeks(startOfWeek, index);\n          el.textContent = this.getWeekNumber(dateOfWeekStart, weekStart);\n          if (index > 3) {\n            el.classList[dateOfWeekStart > this.last ? 'add' : 'remove']('next');\n          }\n        });\n      }\n      Array.from(this.grid.children).forEach((el, index) => {\n        const current = addDays(this.start, index);\n        const dateObj = new Date(current);\n        const day = dateObj.getDay();\n        const extraClasses = [];\n        if (this.today === current) {\n          extraClasses.push('today');\n        }\n        if (this.daysOfWeekHighlighted.includes(day)) {\n          extraClasses.push('highlighted');\n        }\n        this.renderCell(el, dateObj.getDate(), current, current, this, current < this.minDate || current > this.maxDate || this.daysOfWeekDisabled.includes(day), extraClasses);\n      });\n    }\n\n    // Update the view UI by applying the changes of selected and focused items\n    refresh() {\n      const range = this.range || [];\n      Array.from(this.grid.children).forEach(el => {\n        this.refreshCell(el, Number(el.dataset.date), this.selected, range);\n      });\n    }\n\n    // Update the view UI by applying the change of focused item\n    refreshFocus() {\n      this.changeFocusedCell(Math.round((this.focused - this.start) / 86400000));\n    }\n  }\n  function computeMonthRange(range, thisYear) {\n    if (!range || !range[0] || !range[1]) {\n      return;\n    }\n    const [[startY, startM], [endY, endM]] = range;\n    if (startY > thisYear || endY < thisYear) {\n      return;\n    }\n    return [startY === thisYear ? startM : -1, endY === thisYear ? endM : 12];\n  }\n  class MonthsView extends View {\n    constructor(picker) {\n      super(picker, {\n        id: 1,\n        name: 'months',\n        cellClass: 'month'\n      });\n    }\n    init(options) {\n      let onConstruction = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n      if (onConstruction) {\n        this.grid = this.element;\n        this.element.classList.add('months', 'datepicker-grid');\n        this.grid.appendChild(parseHTML(createTagRepeat('span', 12, {\n          'data-month': ix => ix\n        })));\n        this.first = 0;\n        this.last = 11;\n      }\n      super.init(options);\n    }\n    setOptions(options) {\n      if (options.locale) {\n        this.monthNames = options.locale.monthsShort;\n      }\n      if ('minDate' in options) {\n        if (options.minDate === undefined) {\n          this.minYear = this.minMonth = this.minDate = undefined;\n        } else {\n          const minDateObj = new Date(options.minDate);\n          this.minYear = minDateObj.getFullYear();\n          this.minMonth = minDateObj.getMonth();\n          this.minDate = minDateObj.setDate(1);\n        }\n      }\n      if ('maxDate' in options) {\n        if (options.maxDate === undefined) {\n          this.maxYear = this.maxMonth = this.maxDate = undefined;\n        } else {\n          const maxDateObj = new Date(options.maxDate);\n          this.maxYear = maxDateObj.getFullYear();\n          this.maxMonth = maxDateObj.getMonth();\n          this.maxDate = dateValue(this.maxYear, this.maxMonth + 1, 0);\n        }\n      }\n      if (options.checkDisabled) {\n        this.checkDisabled = this.isMinView || options.datesDisabled === null ? options.checkDisabled : () => false;\n      }\n      if ('beforeShowMonth' in options) {\n        this.beforeShow = typeof options.beforeShowMonth === 'function' ? options.beforeShowMonth : undefined;\n      }\n    }\n\n    // Update view's settings to reflect the viewDate set on the picker\n    updateFocus() {\n      const viewDate = new Date(this.picker.viewDate);\n      this.year = viewDate.getFullYear();\n      this.focused = viewDate.getMonth();\n    }\n\n    // Update view's settings to reflect the selected dates\n    updateSelection() {\n      const {\n        dates,\n        rangepicker\n      } = this.picker.datepicker;\n      this.selected = dates.reduce((selected, timeValue) => {\n        const date = new Date(timeValue);\n        const year = date.getFullYear();\n        const month = date.getMonth();\n        if (selected[year] === undefined) {\n          selected[year] = [month];\n        } else {\n          pushUnique(selected[year], month);\n        }\n        return selected;\n      }, {});\n      if (rangepicker && rangepicker.dates) {\n        this.range = rangepicker.dates.map(timeValue => {\n          const date = new Date(timeValue);\n          return isNaN(date) ? undefined : [date.getFullYear(), date.getMonth()];\n        });\n      }\n    }\n\n    // Update the entire view UI\n    render() {\n      this.prepareForRender(this.year, this.year <= this.minYear, this.year >= this.maxYear);\n      const selected = this.selected[this.year] || [];\n      const yrOutOfRange = this.year < this.minYear || this.year > this.maxYear;\n      const isMinYear = this.year === this.minYear;\n      const isMaxYear = this.year === this.maxYear;\n      const range = computeMonthRange(this.range, this.year);\n      Array.from(this.grid.children).forEach((el, index) => {\n        const date = regularizeDate(new Date(this.year, index, 1), 1, this.isRangeEnd);\n        this.renderCell(el, this.monthNames[index], index, date, {\n          selected,\n          range\n        }, yrOutOfRange || isMinYear && index < this.minMonth || isMaxYear && index > this.maxMonth);\n      });\n    }\n\n    // Update the view UI by applying the changes of selected and focused items\n    refresh() {\n      const selected = this.selected[this.year] || [];\n      const range = computeMonthRange(this.range, this.year) || [];\n      Array.from(this.grid.children).forEach((el, index) => {\n        this.refreshCell(el, index, selected, range);\n      });\n    }\n\n    // Update the view UI by applying the change of focused item\n    refreshFocus() {\n      this.changeFocusedCell(this.focused);\n    }\n  }\n  function toTitleCase(word) {\n    return [...word].reduce((str, ch, ix) => str += ix ? ch : ch.toUpperCase(), '');\n  }\n\n  // Class representing the years and decades view elements\n  class YearsView extends View {\n    constructor(picker, config) {\n      super(picker, config);\n    }\n    init(options) {\n      let onConstruction = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n      if (onConstruction) {\n        this.navStep = this.step * 10;\n        this.beforeShowOption = `beforeShow${toTitleCase(this.cellClass)}`;\n        this.grid = this.element;\n        this.element.classList.add(this.name, 'datepicker-grid');\n        this.grid.appendChild(parseHTML(createTagRepeat('span', 12)));\n      }\n      super.init(options);\n    }\n    setOptions(options) {\n      if ('minDate' in options) {\n        if (options.minDate === undefined) {\n          this.minYear = this.minDate = undefined;\n        } else {\n          this.minYear = startOfYearPeriod(options.minDate, this.step);\n          this.minDate = dateValue(this.minYear, 0, 1);\n        }\n      }\n      if ('maxDate' in options) {\n        if (options.maxDate === undefined) {\n          this.maxYear = this.maxDate = undefined;\n        } else {\n          this.maxYear = startOfYearPeriod(options.maxDate, this.step);\n          this.maxDate = dateValue(this.maxYear, 11, 31);\n        }\n      }\n      if (options.checkDisabled) {\n        this.checkDisabled = this.isMinView || options.datesDisabled === null ? options.checkDisabled : () => false;\n      }\n      if (this.beforeShowOption in options) {\n        const beforeShow = options[this.beforeShowOption];\n        this.beforeShow = typeof beforeShow === 'function' ? beforeShow : undefined;\n      }\n    }\n\n    // Update view's settings to reflect the viewDate set on the picker\n    updateFocus() {\n      const viewDate = new Date(this.picker.viewDate);\n      const first = startOfYearPeriod(viewDate, this.navStep);\n      const last = first + 9 * this.step;\n      this.first = first;\n      this.last = last;\n      this.start = first - this.step;\n      this.focused = startOfYearPeriod(viewDate, this.step);\n    }\n\n    // Update view's settings to reflect the selected dates\n    updateSelection() {\n      const {\n        dates,\n        rangepicker\n      } = this.picker.datepicker;\n      this.selected = dates.reduce((years, timeValue) => {\n        return pushUnique(years, startOfYearPeriod(timeValue, this.step));\n      }, []);\n      if (rangepicker && rangepicker.dates) {\n        this.range = rangepicker.dates.map(timeValue => {\n          if (timeValue !== undefined) {\n            return startOfYearPeriod(timeValue, this.step);\n          }\n        });\n      }\n    }\n\n    // Update the entire view UI\n    render() {\n      this.prepareForRender(`${this.first}-${this.last}`, this.first <= this.minYear, this.last >= this.maxYear);\n      Array.from(this.grid.children).forEach((el, index) => {\n        const current = this.start + index * this.step;\n        const date = regularizeDate(new Date(current, 0, 1), 2, this.isRangeEnd);\n        el.dataset.year = current;\n        this.renderCell(el, current, current, date, this, current < this.minYear || current > this.maxYear);\n      });\n    }\n\n    // Update the view UI by applying the changes of selected and focused items\n    refresh() {\n      const range = this.range || [];\n      Array.from(this.grid.children).forEach(el => {\n        this.refreshCell(el, Number(el.textContent), this.selected, range);\n      });\n    }\n\n    // Update the view UI by applying the change of focused item\n    refreshFocus() {\n      this.changeFocusedCell(Math.round((this.focused - this.start) / this.step));\n    }\n  }\n  function triggerDatepickerEvent(datepicker, type) {\n    const options = {\n      bubbles: true,\n      cancelable: true,\n      detail: {\n        date: datepicker.getDate(),\n        viewDate: new Date(datepicker.picker.viewDate),\n        viewId: datepicker.picker.currentView.id,\n        datepicker\n      }\n    };\n    datepicker.element.dispatchEvent(new CustomEvent(type, options));\n  }\n\n  // direction: -1 (to previous), 1 (to next)\n  function goToPrevOrNext(datepicker, direction) {\n    const {\n      config,\n      picker\n    } = datepicker;\n    const {\n      currentView,\n      viewDate\n    } = picker;\n    let newViewDate;\n    switch (currentView.id) {\n      case 0:\n        newViewDate = addMonths(viewDate, direction);\n        break;\n      case 1:\n        newViewDate = addYears(viewDate, direction);\n        break;\n      default:\n        newViewDate = addYears(viewDate, direction * currentView.navStep);\n    }\n    newViewDate = limitToRange(newViewDate, config.minDate, config.maxDate);\n    picker.changeFocus(newViewDate).render();\n  }\n  function switchView(datepicker) {\n    const viewId = datepicker.picker.currentView.id;\n    if (viewId === datepicker.config.maxView) {\n      return;\n    }\n    datepicker.picker.changeView(viewId + 1).render();\n  }\n  function clearSelection(datepicker) {\n    datepicker.setDate({\n      clear: true\n    });\n  }\n  function goToOrSelectToday(datepicker) {\n    const currentDate = today();\n    if (datepicker.config.todayButtonMode === 1) {\n      datepicker.setDate(currentDate, {\n        forceRefresh: true,\n        viewDate: currentDate\n      });\n    } else {\n      datepicker.setFocusedDate(currentDate, true);\n    }\n  }\n  function unfocus(datepicker) {\n    const onBlur = () => {\n      if (datepicker.config.updateOnBlur) {\n        datepicker.update({\n          revert: true\n        });\n      } else {\n        datepicker.refresh('input');\n      }\n      datepicker.hide();\n    };\n    const element = datepicker.element;\n    if (isActiveElement(element)) {\n      element.addEventListener('blur', onBlur, {\n        once: true\n      });\n    } else {\n      onBlur();\n    }\n  }\n  function goToSelectedMonthOrYear(datepicker, selection) {\n    const picker = datepicker.picker;\n    const viewDate = new Date(picker.viewDate);\n    const viewId = picker.currentView.id;\n    const newDate = viewId === 1 ? addMonths(viewDate, selection - viewDate.getMonth()) : addYears(viewDate, selection - viewDate.getFullYear());\n    picker.changeFocus(newDate).changeView(viewId - 1).render();\n  }\n  function onClickViewSwitch(datepicker) {\n    switchView(datepicker);\n  }\n  function onClickPrevButton(datepicker) {\n    goToPrevOrNext(datepicker, -1);\n  }\n  function onClickNextButton(datepicker) {\n    goToPrevOrNext(datepicker, 1);\n  }\n\n  // For the picker's main block to delegete the events from `datepicker-cell`s\n  function onClickView(datepicker, ev) {\n    const target = findElementInEventPath(ev, '.datepicker-cell');\n    if (!target || target.classList.contains('disabled')) {\n      return;\n    }\n    const {\n      id,\n      isMinView\n    } = datepicker.picker.currentView;\n    const data = target.dataset;\n    if (isMinView) {\n      datepicker.setDate(Number(data.date));\n    } else if (id === 1) {\n      goToSelectedMonthOrYear(datepicker, Number(data.month));\n    } else {\n      goToSelectedMonthOrYear(datepicker, Number(data.year));\n    }\n  }\n  function onMousedownPicker(ev) {\n    ev.preventDefault();\n  }\n  const orientClasses = ['left', 'top', 'right', 'bottom'].reduce((obj, key) => {\n    obj[key] = `datepicker-orient-${key}`;\n    return obj;\n  }, {});\n  const toPx = num => num ? `${num}px` : num;\n  function processPickerOptions(picker, options) {\n    if ('title' in options) {\n      if (options.title) {\n        picker.controls.title.textContent = options.title;\n        showElement(picker.controls.title);\n      } else {\n        picker.controls.title.textContent = '';\n        hideElement(picker.controls.title);\n      }\n    }\n    if (options.prevArrow) {\n      const prevButton = picker.controls.prevButton;\n      emptyChildNodes(prevButton);\n      options.prevArrow.forEach(node => {\n        prevButton.appendChild(node.cloneNode(true));\n      });\n    }\n    if (options.nextArrow) {\n      const nextButton = picker.controls.nextButton;\n      emptyChildNodes(nextButton);\n      options.nextArrow.forEach(node => {\n        nextButton.appendChild(node.cloneNode(true));\n      });\n    }\n    if (options.locale) {\n      picker.controls.todayButton.textContent = options.locale.today;\n      picker.controls.clearButton.textContent = options.locale.clear;\n    }\n    if ('todayButton' in options) {\n      if (options.todayButton) {\n        showElement(picker.controls.todayButton);\n      } else {\n        hideElement(picker.controls.todayButton);\n      }\n    }\n    if ('minDate' in options || 'maxDate' in options) {\n      const {\n        minDate,\n        maxDate\n      } = picker.datepicker.config;\n      picker.controls.todayButton.disabled = !isInRange(today(), minDate, maxDate);\n    }\n    if ('clearButton' in options) {\n      if (options.clearButton) {\n        showElement(picker.controls.clearButton);\n      } else {\n        hideElement(picker.controls.clearButton);\n      }\n    }\n  }\n\n  // Compute view date to reset, which will be...\n  // - the last item of the selected dates or defaultViewDate if no selection\n  // - limitted to minDate or maxDate if it exceeds the range\n  function computeResetViewDate(datepicker) {\n    const {\n      dates,\n      config,\n      rangeSideIndex\n    } = datepicker;\n    const viewDate = dates.length > 0 ? lastItemOf(dates) : regularizeDate(config.defaultViewDate, config.pickLevel, rangeSideIndex);\n    return limitToRange(viewDate, config.minDate, config.maxDate);\n  }\n\n  // Change current view's view date\n  function setViewDate(picker, newDate) {\n    if (!('_oldViewDate' in picker) && newDate !== picker.viewDate) {\n      picker._oldViewDate = picker.viewDate;\n    }\n    picker.viewDate = newDate;\n\n    // return whether the new date is in different period on time from the one\n    // displayed in the current view\n    // when true, the view needs to be re-rendered on the next UI refresh.\n    const {\n      id,\n      year,\n      first,\n      last\n    } = picker.currentView;\n    const viewYear = new Date(newDate).getFullYear();\n    switch (id) {\n      case 0:\n        return newDate < first || newDate > last;\n      case 1:\n        return viewYear !== year;\n      default:\n        return viewYear < first || viewYear > last;\n    }\n  }\n  function getTextDirection(el) {\n    return window.getComputedStyle(el).direction;\n  }\n\n  // find the closet scrollable ancestor elemnt under the body\n  function findScrollParents(el) {\n    const parent = getParent(el);\n    if (parent === document.body || !parent) {\n      return;\n    }\n\n    // checking overflow only is enough because computed overflow cannot be\n    // visible or a combination of visible and other when either axis is set\n    // to other than visible.\n    // (Setting one axis to other than 'visible' while the other is 'visible'\n    // results in the other axis turning to 'auto')\n    return window.getComputedStyle(parent).overflow !== 'visible' ? parent : findScrollParents(parent);\n  }\n\n  // Class representing the picker UI\n  class Picker {\n    constructor(datepicker) {\n      const {\n        config,\n        inputField\n      } = this.datepicker = datepicker;\n      const template = pickerTemplate.replace(/%buttonClass%/g, config.buttonClass);\n      const element = this.element = parseHTML(template).firstChild;\n      const [header, main, footer] = element.firstChild.children;\n      const title = header.firstElementChild;\n      const [prevButton, viewSwitch, nextButton] = header.lastElementChild.children;\n      const [todayButton, clearButton] = footer.firstChild.children;\n      const controls = {\n        title,\n        prevButton,\n        viewSwitch,\n        nextButton,\n        todayButton,\n        clearButton\n      };\n      this.main = main;\n      this.controls = controls;\n      const elementClass = inputField ? 'dropdown' : 'inline';\n      element.classList.add(`datepicker-${elementClass}`);\n      processPickerOptions(this, config);\n      this.viewDate = computeResetViewDate(datepicker);\n\n      // set up event listeners\n      registerListeners(datepicker, [[element, 'mousedown', onMousedownPicker], [main, 'click', onClickView.bind(null, datepicker)], [controls.viewSwitch, 'click', onClickViewSwitch.bind(null, datepicker)], [controls.prevButton, 'click', onClickPrevButton.bind(null, datepicker)], [controls.nextButton, 'click', onClickNextButton.bind(null, datepicker)], [controls.todayButton, 'click', goToOrSelectToday.bind(null, datepicker)], [controls.clearButton, 'click', clearSelection.bind(null, datepicker)]]);\n\n      // set up views\n      this.views = [new DaysView(this), new MonthsView(this), new YearsView(this, {\n        id: 2,\n        name: 'years',\n        cellClass: 'year',\n        step: 1\n      }), new YearsView(this, {\n        id: 3,\n        name: 'decades',\n        cellClass: 'decade',\n        step: 10\n      })];\n      this.currentView = this.views[config.startView];\n      this.currentView.render();\n      this.main.appendChild(this.currentView.element);\n      if (config.container) {\n        config.container.appendChild(this.element);\n      } else {\n        inputField.after(this.element);\n      }\n    }\n    setOptions(options) {\n      processPickerOptions(this, options);\n      this.views.forEach(view => {\n        view.init(options, false);\n      });\n      this.currentView.render();\n    }\n    detach() {\n      this.element.remove();\n    }\n    show() {\n      if (this.active) {\n        return;\n      }\n      const {\n        datepicker,\n        element\n      } = this;\n      const inputField = datepicker.inputField;\n      if (inputField) {\n        // ensure picker's direction matches input's\n        const inputDirection = getTextDirection(inputField);\n        if (inputDirection !== getTextDirection(getParent(element))) {\n          element.dir = inputDirection;\n        } else if (element.dir) {\n          element.removeAttribute('dir');\n        }\n\n        // Determine the picker's position first to prevent `orientation: 'auto'`\n        // from being miscalculated to 'bottom' after the picker temporarily\n        // shown below the input field expands the document height if the field\n        // is at the bottom edge of the document\n        this.place();\n        element.classList.add('active');\n        if (datepicker.config.disableTouchKeyboard) {\n          inputField.blur();\n        }\n      } else {\n        element.classList.add('active');\n      }\n      this.active = true;\n      triggerDatepickerEvent(datepicker, 'show');\n    }\n    hide() {\n      if (!this.active) {\n        return;\n      }\n      this.datepicker.exitEditMode();\n      this.element.classList.remove('active');\n      this.active = false;\n      triggerDatepickerEvent(this.datepicker, 'hide');\n    }\n    place() {\n      const {\n        classList,\n        style\n      } = this.element;\n      // temporarily display the picker to get its size and offset parent\n      style.display = 'block';\n      const {\n        width: calendarWidth,\n        height: calendarHeight\n      } = this.element.getBoundingClientRect();\n      const offsetParent = this.element.offsetParent;\n      // turn the picker back to hidden so that the position is determined with\n      // the state before it is shown.\n      style.display = '';\n      const {\n        config,\n        inputField\n      } = this.datepicker;\n      const {\n        left: inputLeft,\n        top: inputTop,\n        right: inputRight,\n        bottom: inputBottom,\n        width: inputWidth,\n        height: inputHeight\n      } = inputField.getBoundingClientRect();\n      let {\n        x: orientX,\n        y: orientY\n      } = config.orientation;\n      let left = inputLeft;\n      let top = inputTop;\n\n      // caliculate offsetLeft/Top of inputField\n      if (offsetParent === document.body || !offsetParent) {\n        left += window.scrollX;\n        top += window.scrollY;\n      } else {\n        const offsetParentRect = offsetParent.getBoundingClientRect();\n        left -= offsetParentRect.left - offsetParent.scrollLeft;\n        top -= offsetParentRect.top - offsetParent.scrollTop;\n      }\n\n      // caliculate the boundaries of the visible area that contains inputField\n      const scrollParent = findScrollParents(inputField);\n      let scrollAreaLeft = 0;\n      let scrollAreaTop = 0;\n      let {\n        clientWidth: scrollAreaRight,\n        clientHeight: scrollAreaBottom\n      } = document.documentElement;\n      if (scrollParent) {\n        const scrollParentRect = scrollParent.getBoundingClientRect();\n        if (scrollParentRect.top > 0) {\n          scrollAreaTop = scrollParentRect.top;\n        }\n        if (scrollParentRect.left > 0) {\n          scrollAreaLeft = scrollParentRect.left;\n        }\n        if (scrollParentRect.right < scrollAreaRight) {\n          scrollAreaRight = scrollParentRect.right;\n        }\n        if (scrollParentRect.bottom < scrollAreaBottom) {\n          scrollAreaBottom = scrollParentRect.bottom;\n        }\n      }\n\n      // determine the horizontal orientation and left position\n      let adjustment = 0;\n      if (orientX === 'auto') {\n        if (inputLeft < scrollAreaLeft) {\n          orientX = 'left';\n          adjustment = scrollAreaLeft - inputLeft;\n        } else if (inputLeft + calendarWidth > scrollAreaRight) {\n          orientX = 'right';\n          if (scrollAreaRight < inputRight) {\n            adjustment = scrollAreaRight - inputRight;\n          }\n        } else if (getTextDirection(inputField) === 'rtl') {\n          orientX = inputRight - calendarWidth < scrollAreaLeft ? 'left' : 'right';\n        } else {\n          orientX = 'left';\n        }\n      }\n      if (orientX === 'right') {\n        left += inputWidth - calendarWidth;\n      }\n      left += adjustment;\n\n      // determine the vertical orientation and top position\n      if (orientY === 'auto') {\n        if (inputTop - calendarHeight > scrollAreaTop) {\n          orientY = inputBottom + calendarHeight > scrollAreaBottom ? 'top' : 'bottom';\n        } else {\n          orientY = 'bottom';\n        }\n      }\n      if (orientY === 'top') {\n        top -= calendarHeight;\n      } else {\n        top += inputHeight;\n      }\n      classList.remove(...Object.values(orientClasses));\n      classList.add(orientClasses[orientX], orientClasses[orientY]);\n      style.left = toPx(left);\n      style.top = toPx(top);\n    }\n    setViewSwitchLabel(labelText) {\n      this.controls.viewSwitch.textContent = labelText;\n    }\n    setPrevButtonDisabled(disabled) {\n      this.controls.prevButton.disabled = disabled;\n    }\n    setNextButtonDisabled(disabled) {\n      this.controls.nextButton.disabled = disabled;\n    }\n    changeView(viewId) {\n      const currentView = this.currentView;\n      if (viewId !== currentView.id) {\n        if (!this._oldView) {\n          this._oldView = currentView;\n        }\n        this.currentView = this.views[viewId];\n        this._renderMethod = 'render';\n      }\n      return this;\n    }\n\n    // Change the focused date (view date)\n    changeFocus(newViewDate) {\n      this._renderMethod = setViewDate(this, newViewDate) ? 'render' : 'refreshFocus';\n      this.views.forEach(view => {\n        view.updateFocus();\n      });\n      return this;\n    }\n\n    // Apply the change of the selected dates\n    update() {\n      let viewDate = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : undefined;\n      const newViewDate = viewDate === undefined ? computeResetViewDate(this.datepicker) : viewDate;\n      this._renderMethod = setViewDate(this, newViewDate) ? 'render' : 'refresh';\n      this.views.forEach(view => {\n        view.updateFocus();\n        view.updateSelection();\n      });\n      return this;\n    }\n\n    // Refresh the picker UI\n    render() {\n      let quickRender = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n      const {\n        currentView,\n        datepicker,\n        _oldView: oldView\n      } = this;\n      const oldViewDate = new Date(this._oldViewDate);\n      const renderMethod = quickRender && this._renderMethod || 'render';\n      delete this._oldView;\n      delete this._oldViewDate;\n      delete this._renderMethod;\n      currentView[renderMethod]();\n      if (oldView) {\n        this.main.replaceChild(currentView.element, oldView.element);\n        triggerDatepickerEvent(datepicker, 'changeView');\n      }\n      if (!isNaN(oldViewDate)) {\n        const newViewDate = new Date(this.viewDate);\n        if (newViewDate.getFullYear() !== oldViewDate.getFullYear()) {\n          triggerDatepickerEvent(datepicker, 'changeYear');\n        }\n        if (newViewDate.getMonth() !== oldViewDate.getMonth()) {\n          triggerDatepickerEvent(datepicker, 'changeMonth');\n        }\n      }\n    }\n  }\n\n  // Find the closest date that doesn't meet the condition for unavailable date\n  // Returns undefined if no available date is found\n  // addFn: function to calculate the next date\n  //   - args: time value, amount\n  // increase: amount to pass to addFn\n  // testFn: function to test the unavailability of the date\n  //   - args: time value; return: true if unavailable\n  function findNextAvailableOne(date, addFn, increase, testFn, min, max) {\n    if (!isInRange(date, min, max)) {\n      return;\n    }\n    if (testFn(date)) {\n      const newDate = addFn(date, increase);\n      return findNextAvailableOne(newDate, addFn, increase, testFn, min, max);\n    }\n    return date;\n  }\n\n  // direction: -1 (left/up), 1 (right/down)\n  // vertical: true for up/down, false for left/right\n  function moveByArrowKey(datepicker, direction, vertical) {\n    const picker = datepicker.picker;\n    const currentView = picker.currentView;\n    const step = currentView.step || 1;\n    let viewDate = picker.viewDate;\n    let addFn;\n    switch (currentView.id) {\n      case 0:\n        viewDate = addDays(viewDate, vertical ? direction * 7 : direction);\n        addFn = addDays;\n        break;\n      case 1:\n        viewDate = addMonths(viewDate, vertical ? direction * 4 : direction);\n        addFn = addMonths;\n        break;\n      default:\n        viewDate = addYears(viewDate, direction * (vertical ? 4 : 1) * step);\n        addFn = addYears;\n    }\n    viewDate = findNextAvailableOne(viewDate, addFn, direction < 0 ? -step : step, date => currentView.disabled.includes(date), currentView.minDate, currentView.maxDate);\n    if (viewDate !== undefined) {\n      picker.changeFocus(viewDate).render();\n    }\n  }\n  function onKeydown(datepicker, ev) {\n    const {\n      config,\n      picker,\n      editMode\n    } = datepicker;\n    const active = picker.active;\n    const {\n      key,\n      altKey,\n      shiftKey\n    } = ev;\n    const ctrlOrMetaKey = ev.ctrlKey || ev.metaKey;\n    const cancelEvent = () => {\n      ev.preventDefault();\n      ev.stopPropagation();\n    };\n\n    // tab/enter keys should not be taken by shortcut keys\n    if (key === 'Tab') {\n      unfocus(datepicker);\n      return;\n    }\n    if (key === 'Enter') {\n      if (!active) {\n        datepicker.update();\n      } else if (editMode) {\n        datepicker.exitEditMode({\n          update: true,\n          autohide: config.autohide\n        });\n      } else {\n        const currentView = picker.currentView;\n        if (currentView.isMinView) {\n          datepicker.setDate(picker.viewDate);\n        } else {\n          picker.changeView(currentView.id - 1).render();\n          cancelEvent();\n        }\n      }\n      return;\n    }\n    const shortcutKeys = config.shortcutKeys;\n    const keyInfo = {\n      key,\n      ctrlOrMetaKey,\n      altKey,\n      shiftKey\n    };\n    const shortcut = Object.keys(shortcutKeys).find(item => {\n      const keyDef = shortcutKeys[item];\n      return !Object.keys(keyDef).find(prop => keyDef[prop] !== keyInfo[prop]);\n    });\n    if (shortcut) {\n      let action;\n      if (shortcut === 'toggle') {\n        action = shortcut;\n      } else if (editMode) {\n        if (shortcut === 'exitEditMode') {\n          action = shortcut;\n        }\n      } else if (active) {\n        if (shortcut === 'hide') {\n          action = shortcut;\n        } else if (shortcut === 'prevButton') {\n          action = [goToPrevOrNext, [datepicker, -1]];\n        } else if (shortcut === 'nextButton') {\n          action = [goToPrevOrNext, [datepicker, 1]];\n        } else if (shortcut === 'viewSwitch') {\n          action = [switchView, [datepicker]];\n        } else if (config.clearButton && shortcut === 'clearButton') {\n          action = [clearSelection, [datepicker]];\n        } else if (config.todayButton && shortcut === 'todayButton') {\n          action = [goToOrSelectToday, [datepicker]];\n        }\n      } else if (shortcut === 'show') {\n        action = shortcut;\n      }\n      if (action) {\n        if (Array.isArray(action)) {\n          action[0].apply(null, action[1]);\n        } else {\n          datepicker[action]();\n        }\n        cancelEvent();\n        return;\n      }\n    }\n\n    // perform as a regular <input> when picker in hidden or in edit mode\n    if (!active || editMode) {\n      return;\n    }\n    const handleArrowKeyPress = (direction, vertical) => {\n      if (shiftKey || ctrlOrMetaKey || altKey) {\n        datepicker.enterEditMode();\n      } else {\n        moveByArrowKey(datepicker, direction, vertical);\n        ev.preventDefault();\n      }\n    };\n    if (key === 'ArrowLeft') {\n      handleArrowKeyPress(-1, false);\n    } else if (key === 'ArrowRight') {\n      handleArrowKeyPress(1, false);\n    } else if (key === 'ArrowUp') {\n      handleArrowKeyPress(-1, true);\n    } else if (key === 'ArrowDown') {\n      handleArrowKeyPress(1, true);\n    } else if (key === 'Backspace' || key === 'Delete'\n    // When autofill is performed, Chromium-based browsers trigger fake\n    // keydown/keyup events that don't have the `key` property (on Edge,\n    // keyup only) in addition to the input event. Therefore, we need to\n    // check the existence of `key`'s value before checking the length.\n    // (issue #144)\n    || key && key.length === 1 && !ctrlOrMetaKey) {\n      datepicker.enterEditMode();\n    }\n  }\n  function onFocus(datepicker) {\n    if (datepicker.config.showOnFocus && !datepicker._showing) {\n      datepicker.show();\n    }\n  }\n\n  // for the prevention for entering edit mode while getting focus on click\n  function onMousedown(datepicker, ev) {\n    const el = ev.target;\n    if (datepicker.picker.active || datepicker.config.showOnClick) {\n      el._active = isActiveElement(el);\n      el._clicking = setTimeout(() => {\n        delete el._active;\n        delete el._clicking;\n      }, 2000);\n    }\n  }\n  function onClickInput(datepicker, ev) {\n    const el = ev.target;\n    if (!el._clicking) {\n      return;\n    }\n    clearTimeout(el._clicking);\n    delete el._clicking;\n    if (el._active) {\n      datepicker.enterEditMode();\n    }\n    delete el._active;\n    if (datepicker.config.showOnClick) {\n      datepicker.show();\n    }\n  }\n  function onPaste(datepicker, ev) {\n    if (ev.clipboardData.types.includes('text/plain')) {\n      datepicker.enterEditMode();\n    }\n  }\n\n  // for the `document` to delegate the events from outside the picker/input field\n  function onClickOutside(datepicker, ev) {\n    const {\n      element,\n      picker\n    } = datepicker;\n    // check both picker's and input's activeness to make updateOnBlur work in\n    // the cases where...\n    // - picker is hidden by ESC key press → input stays focused\n    // - input is unfocused by closing mobile keyboard → piker is kept shown\n    if (!picker.active && !isActiveElement(element)) {\n      return;\n    }\n    const pickerElem = picker.element;\n    if (findElementInEventPath(ev, el => el === element || el === pickerElem)) {\n      return;\n    }\n    unfocus(datepicker);\n  }\n  function stringifyDates(dates, config) {\n    return dates.map(dt => formatDate(dt, config.format, config.locale)).join(config.dateDelimiter);\n  }\n\n  // parse input dates and create an array of time values for selection\n  // returns undefined if there are no valid dates in inputDates\n  // when origDates (current selection) is passed, the function works to mix\n  // the input dates into the current selection\n  function processInputDates(datepicker, inputDates) {\n    let clear = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    if (inputDates.length === 0) {\n      // empty input is considered valid unless origiDates is passed\n      return clear ? [] : undefined;\n    }\n    const {\n      config,\n      dates: origDates,\n      rangeSideIndex\n    } = datepicker;\n    const {\n      pickLevel,\n      maxNumberOfDates\n    } = config;\n    let newDates = inputDates.reduce((dates, dt) => {\n      let date = parseDate(dt, config.format, config.locale);\n      if (date === undefined) {\n        return dates;\n      }\n      // adjust to 1st of the month/Jan 1st of the year\n      // or to the last day of the monh/Dec 31st of the year if the datepicker\n      // is the range-end picker of a rangepicker\n      date = regularizeDate(date, pickLevel, rangeSideIndex);\n      if (isInRange(date, config.minDate, config.maxDate) && !dates.includes(date) && !config.checkDisabled(date, pickLevel) && (pickLevel > 0 || !config.daysOfWeekDisabled.includes(new Date(date).getDay()))) {\n        dates.push(date);\n      }\n      return dates;\n    }, []);\n    if (newDates.length === 0) {\n      return;\n    }\n    if (config.multidate && !clear) {\n      // get the synmetric difference between origDates and newDates\n      newDates = newDates.reduce((dates, date) => {\n        if (!origDates.includes(date)) {\n          dates.push(date);\n        }\n        return dates;\n      }, origDates.filter(date => !newDates.includes(date)));\n    }\n    // do length check always because user can input multiple dates regardless of the mode\n    return maxNumberOfDates && newDates.length > maxNumberOfDates ? newDates.slice(maxNumberOfDates * -1) : newDates;\n  }\n\n  // refresh the UI elements\n  // modes: 1: input only, 2, picker only, 3 both\n  function refreshUI(datepicker) {\n    let mode = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 3;\n    let quickRender = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n    let viewDate = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : undefined;\n    const {\n      config,\n      picker,\n      inputField\n    } = datepicker;\n    if (mode & 2) {\n      const newView = picker.active ? config.pickLevel : config.startView;\n      picker.update(viewDate).changeView(newView).render(quickRender);\n    }\n    if (mode & 1 && inputField) {\n      inputField.value = stringifyDates(datepicker.dates, config);\n    }\n  }\n  function setDate(datepicker, inputDates, options) {\n    const config = datepicker.config;\n    let {\n      clear,\n      render,\n      autohide,\n      revert,\n      forceRefresh,\n      viewDate\n    } = options;\n    if (render === undefined) {\n      render = true;\n    }\n    if (!render) {\n      autohide = forceRefresh = false;\n    } else if (autohide === undefined) {\n      autohide = config.autohide;\n    }\n    viewDate = parseDate(viewDate, config.format, config.locale);\n    const newDates = processInputDates(datepicker, inputDates, clear);\n    if (!newDates && !revert) {\n      return;\n    }\n    if (newDates && newDates.toString() !== datepicker.dates.toString()) {\n      datepicker.dates = newDates;\n      refreshUI(datepicker, render ? 3 : 1, true, viewDate);\n      triggerDatepickerEvent(datepicker, 'changeDate');\n    } else {\n      refreshUI(datepicker, forceRefresh ? 3 : 1, true, viewDate);\n    }\n    if (autohide) {\n      datepicker.hide();\n    }\n  }\n  function getOutputConverter(datepicker, format) {\n    return format ? date => formatDate(date, format, datepicker.config.locale) : date => new Date(date);\n  }\n\n  /**\r\n   * Class representing a date picker\r\n   */\n  class Datepicker {\n    /**\r\n     * Create a date picker\r\n     * @param  {Element} element - element to bind a date picker\r\n     * @param  {Object} [options] - config options\r\n     * @param  {DateRangePicker} [rangepicker] - DateRangePicker instance the\r\n     * date picker belongs to. Use this only when creating date picker as a part\r\n     * of date range picker\r\n     */\n    constructor(element) {\n      let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      let rangepicker = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;\n      element.datepicker = this;\n      this.element = element;\n      this.dates = [];\n\n      // initialize config\n      const config = this.config = Object.assign({\n        buttonClass: options.buttonClass && String(options.buttonClass) || 'button',\n        container: null,\n        defaultViewDate: today(),\n        maxDate: undefined,\n        minDate: undefined\n      }, processOptions(defaultOptions, this));\n\n      // configure by type\n      let inputField;\n      if (element.tagName === 'INPUT') {\n        inputField = this.inputField = element;\n        inputField.classList.add('datepicker-input');\n        if (options.container) {\n          // omit string type check because it doesn't guarantee to avoid errors\n          // (invalid selector string causes abend with sytax error)\n          config.container = options.container instanceof HTMLElement ? options.container : document.querySelector(options.container);\n        }\n      } else {\n        config.container = element;\n      }\n      if (rangepicker) {\n        // check validiry\n        const index = rangepicker.inputs.indexOf(inputField);\n        const datepickers = rangepicker.datepickers;\n        if (index < 0 || index > 1 || !Array.isArray(datepickers)) {\n          throw Error('Invalid rangepicker object.');\n        }\n        // attach itaelf to the rangepicker here so that processInputDates() can\n        // determine if this is the range-end picker of the rangepicker while\n        // setting inital values when pickLevel > 0\n        datepickers[index] = this;\n        this.rangepicker = rangepicker;\n        this.rangeSideIndex = index;\n      }\n\n      // set up config\n      this._options = options;\n      Object.assign(config, processOptions(options, this));\n      config.shortcutKeys = createShortcutKeyConfig(options.shortcutKeys || {});\n\n      // process initial value\n      const initialDates = stringToArray(element.value || element.dataset.date, config.dateDelimiter);\n      delete element.dataset.date;\n      const inputDateValues = processInputDates(this, initialDates);\n      if (inputDateValues && inputDateValues.length > 0) {\n        this.dates = inputDateValues;\n      }\n      if (inputField) {\n        inputField.value = stringifyDates(this.dates, config);\n      }\n\n      // set up picekr element\n      const picker = this.picker = new Picker(this);\n      const keydownListener = [element, 'keydown', onKeydown.bind(null, this)];\n      if (inputField) {\n        registerListeners(this, [keydownListener, [inputField, 'focus', onFocus.bind(null, this)], [inputField, 'mousedown', onMousedown.bind(null, this)], [inputField, 'click', onClickInput.bind(null, this)], [inputField, 'paste', onPaste.bind(null, this)],\n        // To detect a click on outside, just listening to mousedown is enough,\n        // no need to listen to touchstart.\n        // Actually, listening to touchstart can be a problem because, while\n        // mousedown is fired only on tapping but not on swiping/pinching,\n        // touchstart is fired on swiping/pinching as well.\n        // (issue #95)\n        [document, 'mousedown', onClickOutside.bind(null, this)], [window, 'resize', picker.place.bind(picker)]]);\n      } else {\n        registerListeners(this, [keydownListener]);\n        this.show();\n      }\n    }\n\n    /**\r\n     * Format Date object or time value in given format and language\r\n     * @param  {Date|Number} date - date or time value to format\r\n     * @param  {String|Object} format - format string or object that contains\r\n     * toDisplay() custom formatter, whose signature is\r\n     * - args:\r\n     *   - date: {Date} - Date instance of the date passed to the method\r\n     *   - format: {Object} - the format object passed to the method\r\n     *   - locale: {Object} - locale for the language specified by `lang`\r\n     * - return:\r\n     *     {String} formatted date\r\n     * @param  {String} [lang=en] - language code for the locale to use\r\n     * @return {String} formatted date\r\n     */\n    static formatDate(date, format, lang) {\n      return formatDate(date, format, lang && locales[lang] || locales.en);\n    }\n\n    /**\r\n     * Parse date string\r\n     * @param  {String|Date|Number} dateStr - date string, Date object or time\r\n     * value to parse\r\n     * @param  {String|Object} format - format string or object that contains\r\n     * toValue() custom parser, whose signature is\r\n     * - args:\r\n     *   - dateStr: {String|Date|Number} - the dateStr passed to the method\r\n     *   - format: {Object} - the format object passed to the method\r\n     *   - locale: {Object} - locale for the language specified by `lang`\r\n     * - return:\r\n     *     {Date|Number} parsed date or its time value\r\n     * @param  {String} [lang=en] - language code for the locale to use\r\n     * @return {Number} time value of parsed date\r\n     */\n    static parseDate(dateStr, format, lang) {\n      return parseDate(dateStr, format, lang && locales[lang] || locales.en);\n    }\n\n    /**\r\n     * @type {Object} - Installed locales in `[languageCode]: localeObject` format\r\n     * en`:_English (US)_ is pre-installed.\r\n     */\n    static get locales() {\n      return locales;\n    }\n\n    /**\r\n     * @type {Boolean} - Whether the picker element is shown. `true` whne shown\r\n     */\n    get active() {\n      return !!(this.picker && this.picker.active);\n    }\n\n    /**\r\n     * @type {HTMLDivElement} - DOM object of picker element\r\n     */\n    get pickerElement() {\n      return this.picker ? this.picker.element : undefined;\n    }\n\n    /**\r\n     * Set new values to the config options\r\n     * @param {Object} options - config options to update\r\n     */\n    setOptions(options) {\n      const newOptions = processOptions(options, this);\n      Object.assign(this._options, options);\n      Object.assign(this.config, newOptions);\n      this.picker.setOptions(newOptions);\n      refreshUI(this, 3);\n    }\n\n    /**\r\n     * Show the picker element\r\n     */\n    show() {\n      if (this.inputField) {\n        const {\n          config,\n          inputField\n        } = this;\n        if (inputField.disabled || inputField.readOnly && !config.enableOnReadonly) {\n          return;\n        }\n        if (!isActiveElement(inputField) && !config.disableTouchKeyboard) {\n          this._showing = true;\n          inputField.focus();\n          delete this._showing;\n        }\n      }\n      this.picker.show();\n    }\n\n    /**\r\n     * Hide the picker element\r\n     * Not available on inline picker\r\n     */\n    hide() {\n      if (!this.inputField) {\n        return;\n      }\n      this.picker.hide();\n      this.picker.update().changeView(this.config.startView).render();\n    }\n\n    /**\r\n     * Toggle the display of the picker element\r\n     * Not available on inline picker\r\n     *\r\n     * Unlike hide(), the picker does not return to the start view when hiding.\r\n     */\n    toggle() {\n      if (!this.picker.active) {\n        this.show();\n      } else if (this.inputField) {\n        this.picker.hide();\n      }\n    }\n\n    /**\r\n     * Destroy the Datepicker instance\r\n     * @return {Detepicker} - the instance destroyed\r\n     */\n    destroy() {\n      this.hide();\n      unregisterListeners(this);\n      this.picker.detach();\n      const element = this.element;\n      element.classList.remove('datepicker-input');\n      delete element.datepicker;\n      return this;\n    }\n\n    /**\r\n     * Get the selected date(s)\r\n     *\r\n     * The method returns a Date object of selected date by default, and returns\r\n     * an array of selected dates in multidate mode. If format string is passed,\r\n     * it returns date string(s) formatted in given format.\r\n     *\r\n     * @param  {String} [format] - format string to stringify the date(s)\r\n     * @return {Date|String|Date[]|String[]} - selected date(s), or if none is\r\n     * selected, empty array in multidate mode and undefined in sigledate mode\r\n     */\n    getDate() {\n      let format = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : undefined;\n      const callback = getOutputConverter(this, format);\n      if (this.config.multidate) {\n        return this.dates.map(callback);\n      }\n      if (this.dates.length > 0) {\n        return callback(this.dates[0]);\n      }\n    }\n\n    /**\r\n     * Set selected date(s)\r\n     *\r\n     * In multidate mode, you can pass multiple dates as a series of arguments\r\n     * or an array. (Since each date is parsed individually, the type of the\r\n     * dates doesn't have to be the same.)\r\n     * The given dates are used to toggle the select status of each date. The\r\n     * number of selected dates is kept from exceeding the length set to\r\n     * maxNumberOfDates.\r\n     *\r\n     * With clear: true option, the method can be used to clear the selection\r\n     * and to replace the selection instead of toggling in multidate mode.\r\n     * If the option is passed with no date arguments or an empty dates array,\r\n     * it works as \"clear\" (clear the selection then set nothing), and if the\r\n     * option is passed with new dates to select, it works as \"replace\" (clear\r\n     * the selection then set the given dates)\r\n     *\r\n     * When render: false option is used, the method omits re-rendering the\r\n     * picker element. In this case, you need to call refresh() method later in\r\n     * order for the picker element to reflect the changes. The input field is\r\n     * refreshed always regardless of this option.\r\n     *\r\n     * When invalid (unparsable, repeated, disabled or out-of-range) dates are\r\n     * passed, the method ignores them and applies only valid ones. In the case\r\n     * that all the given dates are invalid, which is distinguished from passing\r\n     * no dates, the method considers it as an error and leaves the selection\r\n     * untouched. (The input field also remains untouched unless revert: true\r\n     * option is used.)\r\n     * Replacing the selection with the same date(s) also causes a similar\r\n     * situation. In both cases, the method does not refresh the picker element\r\n     * unless forceRefresh: true option is used.\r\n     *\r\n     * If viewDate option is used, the method changes the focused date to the\r\n     * specified date instead of the last item of the selection.\r\n     *\r\n     * @param {...(Date|Number|String)|Array} [dates] - Date strings, Date\r\n     * objects, time values or mix of those for new selection\r\n     * @param {Object} [options] - function options\r\n     * - clear: {boolean} - Whether to clear the existing selection\r\n     *     defualt: false\r\n     * - render: {boolean} - Whether to re-render the picker element\r\n     *     default: true\r\n     * - autohide: {boolean} - Whether to hide the picker element after re-render\r\n     *     Ignored when used with render: false\r\n     *     default: config.autohide\r\n     * - revert: {boolean} - Whether to refresh the input field when all the\r\n     *     passed dates are invalid\r\n     *     default: false\r\n     * - forceRefresh: {boolean} - Whether to refresh the picker element when\r\n     *     passed dates don't change the existing selection\r\n     *     default: false\r\n     * - viewDate: {Date|Number|String} - Date to be focused after setiing date(s)\r\n     *     default: The last item of the resulting selection, or defaultViewDate\r\n     *     config option if none is selected\r\n     */\n    setDate() {\n      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        args[_key2] = arguments[_key2];\n      }\n      const dates = [...args];\n      const opts = {};\n      const lastArg = lastItemOf(args);\n      if (lastArg && typeof lastArg === 'object' && !Array.isArray(lastArg) && !(lastArg instanceof Date)) {\n        Object.assign(opts, dates.pop());\n      }\n      const inputDates = Array.isArray(dates[0]) ? dates[0] : dates;\n      setDate(this, inputDates, opts);\n    }\n\n    /**\r\n     * Update the selected date(s) with input field's value\r\n     * Not available on inline picker\r\n     *\r\n     * The input field will be refreshed with properly formatted date string.\r\n     *\r\n     * In the case that all the entered dates are invalid (unparsable, repeated,\r\n     * disabled or out-of-range), which is distinguished from empty input field,\r\n     * the method leaves the input field untouched as well as the selection by\r\n     * default. If revert: true option is used in this case, the input field is\r\n     * refreshed with the existing selection.\r\n     * The method also doesn't refresh the picker element in this case and when\r\n     * the entered dates are the same as the existing selection. If\r\n     * forceRefresh: true option is used, the picker element is refreshed in\r\n     * these cases too.\r\n     *\r\n     * @param  {Object} [options] - function options\r\n     * - autohide: {boolean} - whether to hide the picker element after refresh\r\n     *     default: false\r\n     * - revert: {boolean} - Whether to refresh the input field when all the\r\n     *     passed dates are invalid\r\n     *     default: false\r\n     * - forceRefresh: {boolean} - Whether to refresh the picer element when\r\n     *     input field's value doesn't change the existing selection\r\n     *     default: false\r\n     */\n    update() {\n      let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : undefined;\n      if (!this.inputField) {\n        return;\n      }\n      const opts = Object.assign(options || {}, {\n        clear: true,\n        render: true,\n        viewDate: undefined\n      });\n      const inputDates = stringToArray(this.inputField.value, this.config.dateDelimiter);\n      setDate(this, inputDates, opts);\n    }\n\n    /**\r\n     * Get the focused date\r\n     *\r\n     * The method returns a Date object of focused date by default. If format\r\n     * string is passed, it returns date string formatted in given format.\r\n     *\r\n     * @param  {String} [format] - format string to stringify the date\r\n     * @return {Date|String} - focused date (viewDate)\r\n     */\n    getFocusedDate() {\n      let format = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : undefined;\n      return getOutputConverter(this, format)(this.picker.viewDate);\n    }\n\n    /**\r\n     * Set focused date\r\n     *\r\n     * By default, the method updates the focus on the view shown at the time,\r\n     * or the one set to the startView config option if the picker is hidden.\r\n     * When resetView: true is passed, the view displayed is changed to the\r\n     * pickLevel config option's if the picker is shown.\r\n     *\r\n     * @param {Date|Number|String} viewDate - date string, Date object, time\r\n     * values of the date to focus\r\n     * @param {Boolean} [resetView] - whether to change the view to pickLevel\r\n     * config option's when the picker is shown. Ignored when the picker is\r\n     * hidden\r\n     */\n    setFocusedDate(viewDate) {\n      let resetView = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      const {\n        config,\n        picker,\n        active,\n        rangeSideIndex\n      } = this;\n      const pickLevel = config.pickLevel;\n      const newViewDate = parseDate(viewDate, config.format, config.locale);\n      if (newViewDate === undefined) {\n        return;\n      }\n      picker.changeFocus(regularizeDate(newViewDate, pickLevel, rangeSideIndex));\n      if (active && resetView) {\n        picker.changeView(pickLevel);\n      }\n      picker.render();\n    }\n\n    /**\r\n     * Refresh the picker element and the associated input field\r\n     * @param {String} [target] - target item when refreshing one item only\r\n     * 'picker' or 'input'\r\n     * @param {Boolean} [forceRender] - whether to re-render the picker element\r\n     * regardless of its state instead of optimized refresh\r\n     */\n    refresh() {\n      let target = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : undefined;\n      let forceRender = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      if (target && typeof target !== 'string') {\n        forceRender = target;\n        target = undefined;\n      }\n      let mode;\n      if (target === 'picker') {\n        mode = 2;\n      } else if (target === 'input') {\n        mode = 1;\n      } else {\n        mode = 3;\n      }\n      refreshUI(this, mode, !forceRender);\n    }\n\n    /**\r\n     * Enter edit mode\r\n     * Not available on inline picker or when the picker element is hidden\r\n     */\n    enterEditMode() {\n      const inputField = this.inputField;\n      if (!inputField || inputField.readOnly || !this.picker.active || this.editMode) {\n        return;\n      }\n      this.editMode = true;\n      inputField.classList.add('in-edit');\n    }\n\n    /**\r\n     * Exit from edit mode\r\n     * Not available on inline picker\r\n     * @param  {Object} [options] - function options\r\n     * - update: {boolean} - whether to call update() after exiting\r\n     *     If false, input field is revert to the existing selection\r\n     *     default: false\r\n     */\n    exitEditMode() {\n      let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : undefined;\n      if (!this.inputField || !this.editMode) {\n        return;\n      }\n      const opts = Object.assign({\n        update: false\n      }, options);\n      delete this.editMode;\n      this.inputField.classList.remove('in-edit');\n      if (opts.update) {\n        this.update(opts);\n      }\n    }\n  }\n\n  // filter out the config options inapproprite to pass to Datepicker\n  function filterOptions(options) {\n    const newOpts = Object.assign({}, options);\n    delete newOpts.inputs;\n    delete newOpts.allowOneSidedRange;\n    delete newOpts.maxNumberOfDates; // to ensure each datepicker handles a single date\n\n    return newOpts;\n  }\n  function setupDatepicker(rangepicker, changeDateListener, el, options) {\n    registerListeners(rangepicker, [[el, 'changeDate', changeDateListener]]);\n    new Datepicker(el, options, rangepicker);\n  }\n  function onChangeDate(rangepicker, ev) {\n    // to prevent both datepickers trigger the other side's update each other\n    if (rangepicker._updating) {\n      return;\n    }\n    rangepicker._updating = true;\n    const target = ev.target;\n    if (target.datepicker === undefined) {\n      return;\n    }\n    const datepickers = rangepicker.datepickers;\n    const [datepicker0, datepicker1] = datepickers;\n    const setDateOptions = {\n      render: false\n    };\n    const changedSide = rangepicker.inputs.indexOf(target);\n    const otherSide = changedSide === 0 ? 1 : 0;\n    const changedDate = datepickers[changedSide].dates[0];\n    const otherDate = datepickers[otherSide].dates[0];\n    if (changedDate !== undefined && otherDate !== undefined) {\n      // if the start of the range > the end, swap them\n      if (changedSide === 0 && changedDate > otherDate) {\n        datepicker0.setDate(otherDate, setDateOptions);\n        datepicker1.setDate(changedDate, setDateOptions);\n      } else if (changedSide === 1 && changedDate < otherDate) {\n        datepicker0.setDate(changedDate, setDateOptions);\n        datepicker1.setDate(otherDate, setDateOptions);\n      }\n    } else if (!rangepicker.allowOneSidedRange) {\n      // to prevent the range from becoming one-sided, copy changed side's\n      // selection (no matter if it's empty) to the other side\n      if (changedDate !== undefined || otherDate !== undefined) {\n        setDateOptions.clear = true;\n        datepickers[otherSide].setDate(datepickers[changedSide].dates, setDateOptions);\n      }\n    }\n    datepickers.forEach(datepicker => {\n      datepicker.picker.update().render();\n    });\n    delete rangepicker._updating;\n  }\n\n  /**\r\n   * Class representing a date range picker\r\n   */\n  class DateRangePicker {\n    /**\r\n     * Create a date range picker\r\n     * @param  {Element} element - element to bind a date range picker\r\n     * @param  {Object} [options] - config options\r\n     */\n    constructor(element) {\n      let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      let inputs = Array.isArray(options.inputs) ? options.inputs : Array.from(element.querySelectorAll('input'));\n      if (inputs.length < 2) {\n        return;\n      }\n      element.rangepicker = this;\n      this.element = element;\n      this.inputs = inputs = inputs.slice(0, 2);\n      Object.freeze(inputs);\n      this.allowOneSidedRange = !!options.allowOneSidedRange;\n      const changeDateListener = onChangeDate.bind(null, this);\n      const cleanOptions = filterOptions(options);\n      // in order for initial date setup to work right when pcicLvel > 0,\n      // let Datepicker constructor add the instance to the rangepicker\n      const datepickers = this.datepickers = [];\n      inputs.forEach(input => {\n        setupDatepicker(this, changeDateListener, input, cleanOptions);\n      });\n      Object.freeze(datepickers);\n      Object.defineProperty(this, 'dates', {\n        get() {\n          return datepickers.map(datepicker => datepicker.dates[0]);\n        }\n      });\n      // normalize the range if inital dates are given\n      if (datepickers[0].dates.length > 0) {\n        onChangeDate(this, {\n          target: inputs[0]\n        });\n      } else if (datepickers[1].dates.length > 0) {\n        onChangeDate(this, {\n          target: inputs[1]\n        });\n      }\n    }\n\n    /**\r\n     * Set new values to the config options\r\n     * @param {Object} options - config options to update\r\n     */\n    setOptions(options) {\n      this.allowOneSidedRange = !!options.allowOneSidedRange;\n      const cleanOptions = filterOptions(options);\n      this.datepickers.forEach(datepicker => {\n        datepicker.setOptions(cleanOptions);\n      });\n    }\n\n    /**\r\n     * Destroy the DateRangePicker instance\r\n     * @return {DateRangePicker} - the instance destroyed\r\n     */\n    destroy() {\n      this.datepickers.forEach(datepicker => {\n        datepicker.destroy();\n      });\n      unregisterListeners(this);\n      delete this.element.rangepicker;\n    }\n\n    /**\r\n     * Get the start and end dates of the date range\r\n     *\r\n     * The method returns Date objects by default. If format string is passed,\r\n     * it returns date strings formatted in given format.\r\n     * The result array always contains 2 items (start date/end date) and\r\n     * undefined is used for unselected side. (e.g. If none is selected,\r\n     * the result will be [undefined, undefined]. If only the end date is set\r\n     * when allowOneSidedRange config option is true, [undefined, endDate] will\r\n     * be returned.)\r\n     *\r\n     * @param  {String} [format] - Format string to stringify the dates\r\n     * @return {Array} - Start and end dates\r\n     */\n    getDates() {\n      let format = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : undefined;\n      const callback = format ? date => formatDate(date, format, this.datepickers[0].config.locale) : date => new Date(date);\n      return this.dates.map(date => date === undefined ? date : callback(date));\n    }\n\n    /**\r\n     * Set the start and end dates of the date range\r\n     *\r\n     * The method calls datepicker.setDate() internally using each of the\r\n     * arguments in start→end order.\r\n     *\r\n     * When a clear: true option object is passed instead of a date, the method\r\n     * clears the date.\r\n     *\r\n     * If an invalid date, the same date as the current one or an option object\r\n     * without clear: true is passed, the method considers that argument as an\r\n     * \"ineffective\" argument because calling datepicker.setDate() with those\r\n     * values makes no changes to the date selection.\r\n     *\r\n     * When the allowOneSidedRange config option is false, passing {clear: true}\r\n     * to clear the range works only when it is done to the last effective\r\n     * argument (in other words, passed to rangeEnd or to rangeStart along with\r\n     * ineffective rangeEnd). This is because when the date range is changed,\r\n     * it gets normalized based on the last change at the end of the changing\r\n     * process.\r\n     *\r\n     * @param {Date|Number|String|Object} rangeStart - Start date of the range\r\n     * or {clear: true} to clear the date\r\n     * @param {Date|Number|String|Object} rangeEnd - End date of the range\r\n     * or {clear: true} to clear the date\r\n     */\n    setDates(rangeStart, rangeEnd) {\n      const {\n        datepickers: [datepicker0, datepicker1],\n        inputs: [input0, input1],\n        dates: [origDate0, origDate1]\n      } = this;\n\n      // If range normalization runs on every change, we can't set a new range\n      // that starts after the end of the current range correctly because the\n      // normalization process swaps start↔︎end right after setting the new start\n      // date. To prevent this, the normalization process needs to run once after\n      // both of the new dates are set.\n      this._updating = true;\n      datepicker0.setDate(rangeStart);\n      datepicker1.setDate(rangeEnd);\n      delete this._updating;\n      if (datepicker1.dates[0] !== origDate1) {\n        onChangeDate(this, {\n          target: input1\n        });\n      } else if (datepicker0.dates[0] !== origDate0) {\n        onChangeDate(this, {\n          target: input0\n        });\n      }\n    }\n  }\n  window.Datepicker = Datepicker;\n  window.DateRangePicker = DateRangePicker;\n})();\n\n//# sourceURL=webpack://brainwave/../../../themes/leocar/assets/src/scripts/utils/datepicker-full.js?");

/***/ }),

/***/ "../../../themes/leocar/assets/src/scripts/utils/faq.js":
/*!**************************************************************!*\
  !*** ../../../themes/leocar/assets/src/scripts/utils/faq.js ***!
  \**************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ faq; }\n/* harmony export */ });\nfunction faq() {\n  let faq = document.querySelector('.faq-list');\n  if (faq) {\n    let faqItems = faq.querySelectorAll('.faq-list > div');\n    faqItems.forEach(item => {\n      item.querySelector('h5').addEventListener('click', () => {\n        // Close siblings with class 'open' before toggling this item\n        item.parentElement.querySelectorAll('.open').forEach(openedItem => {\n          if (openedItem !== item) {\n            // Exclude the clicked item itself\n            openedItem.classList.remove('open');\n          }\n        });\n\n        // Toggle the clicked item\n        item.classList.toggle('open');\n      });\n    });\n  }\n  let return_spoiler = document.querySelector('.leo-car-return__spoiler');\n  if (return_spoiler) {\n    document.querySelectorAll('.leo-car-return__spoiler').forEach(item => {\n      item.querySelector('h5').addEventListener('click', () => {\n        // Close siblings with class 'open' before toggling this item\n        item.parentElement.querySelectorAll('.open').forEach(openedItem => {\n          if (openedItem !== item) {\n            // Exclude the clicked item itself\n            openedItem.classList.remove('open');\n          }\n        });\n\n        // Toggle the clicked item\n        item.classList.toggle('open');\n      });\n    });\n  }\n}\n\n//# sourceURL=webpack://brainwave/../../../themes/leocar/assets/src/scripts/utils/faq.js?");

/***/ }),

/***/ "../../../themes/leocar/assets/src/scripts/utils/header.js":
/*!*****************************************************************!*\
  !*** ../../../themes/leocar/assets/src/scripts/utils/header.js ***!
  \*****************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ header; }\n/* harmony export */ });\nfunction header() {\n  let body = document.body;\n  let header = document.querySelector('header');\n  let announcementBlock = document.querySelector('.leo-announcement');\n  if (announcementBlock) {\n    announcementBlock.querySelector('.close').addEventListener('click', () => {\n      announcementBlock.classList.add('hidden');\n    });\n  }\n  let burgerElement = document.querySelector('.leo-burger');\n  if (burgerElement) {\n    let toggleMobileOpen = () => {\n      document.querySelector('header .mobile-menu').style.height = window.innerHeight + 'px';\n      body.classList.toggle('menu-open');\n    };\n    burgerElement.addEventListener('click', toggleMobileOpen);\n  }\n  document.addEventListener('mouseup', function (e) {\n    // Назва контейнеру\n    let container = document.querySelector('.mobile-menu');\n    // Умова, щоб працювало тільки коли попап відкритий\n    if (document.querySelector('body').classList.contains('menu-open')) {\n      if (!e.target.closest('a') && !container.contains(e.target) && !e.target.closest('.leo-burger')) {\n        document.querySelector('.leo-burger').click();\n      }\n    }\n  });\n}\n\n//# sourceURL=webpack://brainwave/../../../themes/leocar/assets/src/scripts/utils/header.js?");

/***/ }),

/***/ "../../../themes/leocar/assets/src/scripts/utils/home.js":
/*!***************************************************************!*\
  !*** ../../../themes/leocar/assets/src/scripts/utils/home.js ***!
  \***************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ home; }\n/* harmony export */ });\nfunction home() {\n  let $ = jQuery;\n  let dateInput = document.querySelector('input#td-date');\n  if (dateInput) {\n    let datepicker = new Datepicker(dateInput, {\n      daysOfWeekDisabled: [0, 6],\n      disableTouchKeyboard: true,\n      format: 'dd/mm/yyyy',\n      autohide: true\n    });\n  }\n\n  /* TIME */\n\n  const timeInput = document.getElementById(\"td-time\");\n\n  // Create the select element\n  const timeSelect = document.createElement(\"ul\");\n\n  // Generate options only for hours from 9 to 19 with half-hour increments\n  for (let hour = 9; hour <= 19; hour++) {\n    for (let minute = 0; minute <= 30; minute += 30) {\n      const formattedTime = hour.toString().padStart(2, \"0\") + \":\" + minute.toString().padStart(2, \"0\");\n      const option = document.createElement(\"li\");\n      option.dataset.value = formattedTime;\n      option.textContent = formattedTime;\n      timeSelect.appendChild(option);\n    }\n  }\n  if (timeInput) {\n    // Insert the select element after the input\n    timeInput.parentNode.insertBefore(timeSelect, timeInput.nextSibling);\n  }\n\n  /* TIME */\n\n  let chooseCarButton = document.querySelector('button.choose-car');\n  let leoCatalogSection = document.querySelector('section.leo-catalog');\n  if (chooseCarButton && leoCatalogSection) {\n    chooseCarButton.addEventListener('click', () => {\n      let offset = 120; // Adjust this value to change the top margin\n\n      if (window.screen.width > 1099) {\n        offset = 140;\n      }\n      let elementTop = leoCatalogSection.getBoundingClientRect().top + window.scrollY;\n      let adjustedScrollPosition = elementTop - offset;\n      window.scrollTo({\n        top: adjustedScrollPosition,\n        behavior: 'smooth'\n      });\n    });\n  }\n  let navLinks = document.querySelectorAll('header ul li, .quick-links ul li');\n  let sections = document.querySelectorAll('section');\n  let offset = getHeaderHeight();\n  if (navLinks) {\n    navLinks.forEach(link => link.addEventListener('click', scrollToSection));\n  }\n  if (window.screen.width > 1099) {\n    $('.flip-card').each(function () {\n      let $this = $(this);\n      $this.find('.flip-card-inner').on('click', function () {\n        $this.parent().siblings().find('.flip-card').removeClass('flipped');\n        if (!$(this).parent().hasClass('flipped')) {\n          $(this).parent().addClass('flipped');\n        } else {\n          $(this).parent().removeClass('flipped');\n        }\n      });\n    });\n    $(document).mouseup(function (e) {\n      let container = $('.flip-card-inner');\n      if (!container.is(e.target) && container.has(e.target).length === 0) {\n        $('.flip-card').removeClass('flipped');\n      }\n    });\n  }\n  function scrollToSection(event) {\n    event.preventDefault();\n    const targetSectionId = event.target.getAttribute('href').slice(1); // Remove the leading #\n    const targetSection = document.getElementById(targetSectionId);\n    const targetSectionTop = targetSection.offsetTop - offset; // Account for offset\n\n    document.querySelector('.leo-burger').click();\n    if (window.screen.width < 1024) {\n      document.body.classList.remove('menu-open');\n      window.scrollTo({\n        top: targetSectionTop\n      });\n    } else {\n      window.scrollTo({\n        top: targetSectionTop,\n        behavior: 'smooth' // Smooth scrolling\n      });\n    }\n\n    // Remove active class from all links on click\n    navLinks.forEach(link => link.classList.remove('active'));\n    this.classList.add('active');\n  }\n  function getHeaderHeight() {\n    const header = document.querySelector('header'); // Replace with your header element selector\n    if (!header) {\n      return 0;\n    }\n    const rect = header.getBoundingClientRect();\n    return rect.height;\n  }\n  document.querySelectorAll('.scroll-top').forEach(function (scrollTopBtn) {\n    scrollTopBtn.addEventListener('click', function (e) {\n      window.scrollTo({\n        top: 0,\n        behavior: 'smooth'\n      });\n    });\n    window.addEventListener('scroll', function () {\n      if (window.pageYOffset > 1 && !scrollTopBtn.classList.contains('active')) {\n        scrollTopBtn.classList.add('active');\n      } else if (window.pageYOffset < 1 && scrollTopBtn.classList.contains('active')) {\n        scrollTopBtn.classList.remove('active');\n      }\n    });\n  });\n}\n\n//# sourceURL=webpack://brainwave/../../../themes/leocar/assets/src/scripts/utils/home.js?");

/***/ }),

/***/ "../../../themes/leocar/assets/src/scripts/utils/imask.js":
/*!****************************************************************!*\
  !*** ../../../themes/leocar/assets/src/scripts/utils/imask.js ***!
  \****************************************************************/
/***/ (function(__unused_webpack_module, exports) {

eval("(function (global, factory) {\n   true ? factory(exports) : 0;\n})(this, function (exports) {\n  'use strict';\n\n  /** Checks if value is string */\n  function isString(str) {\n    return typeof str === 'string' || str instanceof String;\n  }\n\n  /** Checks if value is object */\n  function isObject(obj) {\n    var _obj$constructor;\n    return typeof obj === 'object' && obj != null && (obj == null || (_obj$constructor = obj.constructor) == null ? void 0 : _obj$constructor.name) === 'Object';\n  }\n  function pick(obj, keys) {\n    if (Array.isArray(keys)) return pick(obj, (_, k) => keys.includes(k));\n    return Object.entries(obj).reduce((acc, _ref) => {\n      let [k, v] = _ref;\n      if (keys(v, k)) acc[k] = v;\n      return acc;\n    }, {});\n  }\n\n  /** Direction */\n  const DIRECTION = {\n    NONE: 'NONE',\n    LEFT: 'LEFT',\n    FORCE_LEFT: 'FORCE_LEFT',\n    RIGHT: 'RIGHT',\n    FORCE_RIGHT: 'FORCE_RIGHT'\n  };\n\n  /** Direction */\n\n  function forceDirection(direction) {\n    switch (direction) {\n      case DIRECTION.LEFT:\n        return DIRECTION.FORCE_LEFT;\n      case DIRECTION.RIGHT:\n        return DIRECTION.FORCE_RIGHT;\n      default:\n        return direction;\n    }\n  }\n\n  /** Escapes regular expression control chars */\n  function escapeRegExp(str) {\n    return str.replace(/([.*+?^=!:${}()|[\\]/\\\\])/g, '\\\\$1');\n  }\n\n  // cloned from https://github.com/epoberezkin/fast-deep-equal with small changes\n  function objectIncludes(b, a) {\n    if (a === b) return true;\n    const arrA = Array.isArray(a),\n      arrB = Array.isArray(b);\n    let i;\n    if (arrA && arrB) {\n      if (a.length != b.length) return false;\n      for (i = 0; i < a.length; i++) if (!objectIncludes(a[i], b[i])) return false;\n      return true;\n    }\n    if (arrA != arrB) return false;\n    if (a && b && typeof a === 'object' && typeof b === 'object') {\n      const dateA = a instanceof Date,\n        dateB = b instanceof Date;\n      if (dateA && dateB) return a.getTime() == b.getTime();\n      if (dateA != dateB) return false;\n      const regexpA = a instanceof RegExp,\n        regexpB = b instanceof RegExp;\n      if (regexpA && regexpB) return a.toString() == b.toString();\n      if (regexpA != regexpB) return false;\n      const keys = Object.keys(a);\n      // if (keys.length !== Object.keys(b).length) return false;\n\n      for (i = 0; i < keys.length; i++) if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false;\n      for (i = 0; i < keys.length; i++) if (!objectIncludes(b[keys[i]], a[keys[i]])) return false;\n      return true;\n    } else if (a && b && typeof a === 'function' && typeof b === 'function') {\n      return a.toString() === b.toString();\n    }\n    return false;\n  }\n\n  /** Selection range */\n\n  /** Provides details of changing input */\n  class ActionDetails {\n    /** Current input value */\n\n    /** Current cursor position */\n\n    /** Old input value */\n\n    /** Old selection */\n\n    constructor(opts) {\n      Object.assign(this, opts);\n\n      // double check if left part was changed (autofilling, other non-standard input triggers)\n      while (this.value.slice(0, this.startChangePos) !== this.oldValue.slice(0, this.startChangePos)) {\n        --this.oldSelection.start;\n      }\n      if (this.insertedCount) {\n        // double check right part\n        while (this.value.slice(this.cursorPos) !== this.oldValue.slice(this.oldSelection.end)) {\n          if (this.value.length - this.cursorPos < this.oldValue.length - this.oldSelection.end) ++this.oldSelection.end;else ++this.cursorPos;\n        }\n      }\n    }\n\n    /** Start changing position */\n    get startChangePos() {\n      return Math.min(this.cursorPos, this.oldSelection.start);\n    }\n\n    /** Inserted symbols count */\n    get insertedCount() {\n      return this.cursorPos - this.startChangePos;\n    }\n\n    /** Inserted symbols */\n    get inserted() {\n      return this.value.substr(this.startChangePos, this.insertedCount);\n    }\n\n    /** Removed symbols count */\n    get removedCount() {\n      // Math.max for opposite operation\n      return Math.max(this.oldSelection.end - this.startChangePos ||\n      // for Delete\n      this.oldValue.length - this.value.length, 0);\n    }\n\n    /** Removed symbols */\n    get removed() {\n      return this.oldValue.substr(this.startChangePos, this.removedCount);\n    }\n\n    /** Unchanged head symbols */\n    get head() {\n      return this.value.substring(0, this.startChangePos);\n    }\n\n    /** Unchanged tail symbols */\n    get tail() {\n      return this.value.substring(this.startChangePos + this.insertedCount);\n    }\n\n    /** Remove direction */\n    get removeDirection() {\n      if (!this.removedCount || this.insertedCount) return DIRECTION.NONE;\n\n      // align right if delete at right\n      return (this.oldSelection.end === this.cursorPos || this.oldSelection.start === this.cursorPos) &&\n      // if not range removed (event with backspace)\n      this.oldSelection.end === this.oldSelection.start ? DIRECTION.RIGHT : DIRECTION.LEFT;\n    }\n  }\n\n  /** Applies mask on element */\n  function IMask(el, opts) {\n    // currently available only for input-like elements\n    return new IMask.InputMask(el, opts);\n  }\n\n  // TODO can't use overloads here because of https://github.com/microsoft/TypeScript/issues/50754\n  // export function maskedClass(mask: string): typeof MaskedPattern;\n  // export function maskedClass(mask: DateConstructor): typeof MaskedDate;\n  // export function maskedClass(mask: NumberConstructor): typeof MaskedNumber;\n  // export function maskedClass(mask: Array<any> | ArrayConstructor): typeof MaskedDynamic;\n  // export function maskedClass(mask: MaskedDate): typeof MaskedDate;\n  // export function maskedClass(mask: MaskedNumber): typeof MaskedNumber;\n  // export function maskedClass(mask: MaskedEnum): typeof MaskedEnum;\n  // export function maskedClass(mask: MaskedRange): typeof MaskedRange;\n  // export function maskedClass(mask: MaskedRegExp): typeof MaskedRegExp;\n  // export function maskedClass(mask: MaskedFunction): typeof MaskedFunction;\n  // export function maskedClass(mask: MaskedPattern): typeof MaskedPattern;\n  // export function maskedClass(mask: MaskedDynamic): typeof MaskedDynamic;\n  // export function maskedClass(mask: Masked): typeof Masked;\n  // export function maskedClass(mask: typeof Masked): typeof Masked;\n  // export function maskedClass(mask: typeof MaskedDate): typeof MaskedDate;\n  // export function maskedClass(mask: typeof MaskedNumber): typeof MaskedNumber;\n  // export function maskedClass(mask: typeof MaskedEnum): typeof MaskedEnum;\n  // export function maskedClass(mask: typeof MaskedRange): typeof MaskedRange;\n  // export function maskedClass(mask: typeof MaskedRegExp): typeof MaskedRegExp;\n  // export function maskedClass(mask: typeof MaskedFunction): typeof MaskedFunction;\n  // export function maskedClass(mask: typeof MaskedPattern): typeof MaskedPattern;\n  // export function maskedClass(mask: typeof MaskedDynamic): typeof MaskedDynamic;\n  // export function maskedClass<Mask extends typeof Masked> (mask: Mask): Mask;\n  // export function maskedClass(mask: RegExp): typeof MaskedRegExp;\n  // export function maskedClass(mask: (value: string, ...args: any[]) => boolean): typeof MaskedFunction;\n\n  /** Get Masked class by mask type */\n  function maskedClass(mask) /* TODO */{\n    if (mask == null) throw new Error('mask property should be defined');\n    if (mask instanceof RegExp) return IMask.MaskedRegExp;\n    if (isString(mask)) return IMask.MaskedPattern;\n    if (mask === Date) return IMask.MaskedDate;\n    if (mask === Number) return IMask.MaskedNumber;\n    if (Array.isArray(mask) || mask === Array) return IMask.MaskedDynamic;\n    if (IMask.Masked && mask.prototype instanceof IMask.Masked) return mask;\n    if (IMask.Masked && mask instanceof IMask.Masked) return mask.constructor;\n    if (mask instanceof Function) return IMask.MaskedFunction;\n    console.warn('Mask not found for mask', mask); // eslint-disable-line no-console\n    return IMask.Masked;\n  }\n  function normalizeOpts(opts) {\n    if (!opts) throw new Error('Options in not defined');\n    if (IMask.Masked) {\n      if (opts.prototype instanceof IMask.Masked) return {\n        mask: opts\n      };\n\n      /*\r\n      handle cases like:\r\n      1) opts = Masked\r\n      2) opts = { mask: Masked, ...instanceOpts }\r\n      */\n      const {\n        mask = undefined,\n        ...instanceOpts\n      } = opts instanceof IMask.Masked ? {\n        mask: opts\n      } : isObject(opts) && opts.mask instanceof IMask.Masked ? opts : {};\n      if (mask) {\n        const _mask = mask.mask;\n        return {\n          ...pick(mask, (_, k) => !k.startsWith('_')),\n          mask: mask.constructor,\n          _mask,\n          ...instanceOpts\n        };\n      }\n    }\n    if (!isObject(opts)) return {\n      mask: opts\n    };\n    return {\n      ...opts\n    };\n  }\n\n  // TODO can't use overloads here because of https://github.com/microsoft/TypeScript/issues/50754\n\n  // From masked\n  // export default function createMask<Opts extends Masked, ReturnMasked=Opts> (opts: Opts): ReturnMasked;\n  // // From masked class\n  // export default function createMask<Opts extends MaskedOptions<typeof Masked>, ReturnMasked extends Masked=InstanceType<Opts['mask']>> (opts: Opts): ReturnMasked;\n  // export default function createMask<Opts extends MaskedOptions<typeof MaskedDate>, ReturnMasked extends MaskedDate=MaskedDate<Opts['parent']>> (opts: Opts): ReturnMasked;\n  // export default function createMask<Opts extends MaskedOptions<typeof MaskedNumber>, ReturnMasked extends MaskedNumber=MaskedNumber<Opts['parent']>> (opts: Opts): ReturnMasked;\n  // export default function createMask<Opts extends MaskedOptions<typeof MaskedEnum>, ReturnMasked extends MaskedEnum=MaskedEnum<Opts['parent']>> (opts: Opts): ReturnMasked;\n  // export default function createMask<Opts extends MaskedOptions<typeof MaskedRange>, ReturnMasked extends MaskedRange=MaskedRange<Opts['parent']>> (opts: Opts): ReturnMasked;\n  // export default function createMask<Opts extends MaskedOptions<typeof MaskedRegExp>, ReturnMasked extends MaskedRegExp=MaskedRegExp<Opts['parent']>> (opts: Opts): ReturnMasked;\n  // export default function createMask<Opts extends MaskedOptions<typeof MaskedFunction>, ReturnMasked extends MaskedFunction=MaskedFunction<Opts['parent']>> (opts: Opts): ReturnMasked;\n  // export default function createMask<Opts extends MaskedOptions<typeof MaskedPattern>, ReturnMasked extends MaskedPattern=MaskedPattern<Opts['parent']>> (opts: Opts): ReturnMasked;\n  // export default function createMask<Opts extends MaskedOptions<typeof MaskedDynamic>, ReturnMasked extends MaskedDynamic=MaskedDynamic<Opts['parent']>> (opts: Opts): ReturnMasked;\n  // // From mask opts\n  // export default function createMask<Opts extends MaskedOptions<Masked>, ReturnMasked=Opts extends MaskedOptions<infer M> ? M : never> (opts: Opts): ReturnMasked;\n  // export default function createMask<Opts extends MaskedNumberOptions, ReturnMasked extends MaskedNumber=MaskedNumber<Opts['parent']>> (opts: Opts): ReturnMasked;\n  // export default function createMask<Opts extends MaskedDateFactoryOptions, ReturnMasked extends MaskedDate=MaskedDate<Opts['parent']>> (opts: Opts): ReturnMasked;\n  // export default function createMask<Opts extends MaskedEnumOptions, ReturnMasked extends MaskedEnum=MaskedEnum<Opts['parent']>> (opts: Opts): ReturnMasked;\n  // export default function createMask<Opts extends MaskedRangeOptions, ReturnMasked extends MaskedRange=MaskedRange<Opts['parent']>> (opts: Opts): ReturnMasked;\n  // export default function createMask<Opts extends MaskedPatternOptions, ReturnMasked extends MaskedPattern=MaskedPattern<Opts['parent']>> (opts: Opts): ReturnMasked;\n  // export default function createMask<Opts extends MaskedDynamicOptions, ReturnMasked extends MaskedDynamic=MaskedDynamic<Opts['parent']>> (opts: Opts): ReturnMasked;\n  // export default function createMask<Opts extends MaskedOptions<RegExp>, ReturnMasked extends MaskedRegExp=MaskedRegExp<Opts['parent']>> (opts: Opts): ReturnMasked;\n  // export default function createMask<Opts extends MaskedOptions<Function>, ReturnMasked extends MaskedFunction=MaskedFunction<Opts['parent']>> (opts: Opts): ReturnMasked;\n\n  /** Creates new {@link Masked} depending on mask type */\n  function createMask(opts) {\n    if (IMask.Masked && opts instanceof IMask.Masked) return opts;\n    const nOpts = normalizeOpts(opts);\n    const MaskedClass = maskedClass(nOpts.mask);\n    if (!MaskedClass) throw new Error(\"Masked class is not found for provided mask \" + nOpts.mask + \", appropriate module needs to be imported manually before creating mask.\");\n    if (nOpts.mask === MaskedClass) delete nOpts.mask;\n    if (nOpts._mask) {\n      nOpts.mask = nOpts._mask;\n      delete nOpts._mask;\n    }\n    return new MaskedClass(nOpts);\n  }\n  IMask.createMask = createMask;\n\n  /**  Generic element API to use with mask */\n  class MaskElement {\n    /** */\n\n    /** */\n\n    /** */\n\n    /** Safely returns selection start */\n    get selectionStart() {\n      let start;\n      try {\n        start = this._unsafeSelectionStart;\n      } catch {}\n      return start != null ? start : this.value.length;\n    }\n\n    /** Safely returns selection end */\n    get selectionEnd() {\n      let end;\n      try {\n        end = this._unsafeSelectionEnd;\n      } catch {}\n      return end != null ? end : this.value.length;\n    }\n\n    /** Safely sets element selection */\n    select(start, end) {\n      if (start == null || end == null || start === this.selectionStart && end === this.selectionEnd) return;\n      try {\n        this._unsafeSelect(start, end);\n      } catch {}\n    }\n\n    /** */\n    get isActive() {\n      return false;\n    }\n    /** */\n\n    /** */\n\n    /** */\n  }\n  IMask.MaskElement = MaskElement;\n  const KEY_Z = 90;\n  const KEY_Y = 89;\n\n  /** Bridge between HTMLElement and {@link Masked} */\n  class HTMLMaskElement extends MaskElement {\n    /** HTMLElement to use mask on */\n\n    constructor(input) {\n      super();\n      this.input = input;\n      this._onKeydown = this._onKeydown.bind(this);\n      this._onInput = this._onInput.bind(this);\n      this._onBeforeinput = this._onBeforeinput.bind(this);\n      this._onCompositionEnd = this._onCompositionEnd.bind(this);\n    }\n    get rootElement() {\n      var _this$input$getRootNo, _this$input$getRootNo2, _this$input;\n      return (_this$input$getRootNo = (_this$input$getRootNo2 = (_this$input = this.input).getRootNode) == null ? void 0 : _this$input$getRootNo2.call(_this$input)) != null ? _this$input$getRootNo : document;\n    }\n\n    /** Is element in focus */\n    get isActive() {\n      return this.input === this.rootElement.activeElement;\n    }\n\n    /** Binds HTMLElement events to mask internal events */\n    bindEvents(handlers) {\n      this.input.addEventListener('keydown', this._onKeydown);\n      this.input.addEventListener('input', this._onInput);\n      this.input.addEventListener('beforeinput', this._onBeforeinput);\n      this.input.addEventListener('compositionend', this._onCompositionEnd);\n      this.input.addEventListener('drop', handlers.drop);\n      this.input.addEventListener('click', handlers.click);\n      this.input.addEventListener('focus', handlers.focus);\n      this.input.addEventListener('blur', handlers.commit);\n      this._handlers = handlers;\n    }\n    _onKeydown(e) {\n      if (this._handlers.redo && (e.keyCode === KEY_Z && e.shiftKey && (e.metaKey || e.ctrlKey) || e.keyCode === KEY_Y && e.ctrlKey)) {\n        e.preventDefault();\n        return this._handlers.redo(e);\n      }\n      if (this._handlers.undo && e.keyCode === KEY_Z && (e.metaKey || e.ctrlKey)) {\n        e.preventDefault();\n        return this._handlers.undo(e);\n      }\n      if (!e.isComposing) this._handlers.selectionChange(e);\n    }\n    _onBeforeinput(e) {\n      if (e.inputType === 'historyUndo' && this._handlers.undo) {\n        e.preventDefault();\n        return this._handlers.undo(e);\n      }\n      if (e.inputType === 'historyRedo' && this._handlers.redo) {\n        e.preventDefault();\n        return this._handlers.redo(e);\n      }\n    }\n    _onCompositionEnd(e) {\n      this._handlers.input(e);\n    }\n    _onInput(e) {\n      if (!e.isComposing) this._handlers.input(e);\n    }\n\n    /** Unbinds HTMLElement events to mask internal events */\n    unbindEvents() {\n      this.input.removeEventListener('keydown', this._onKeydown);\n      this.input.removeEventListener('input', this._onInput);\n      this.input.removeEventListener('beforeinput', this._onBeforeinput);\n      this.input.removeEventListener('compositionend', this._onCompositionEnd);\n      this.input.removeEventListener('drop', this._handlers.drop);\n      this.input.removeEventListener('click', this._handlers.click);\n      this.input.removeEventListener('focus', this._handlers.focus);\n      this.input.removeEventListener('blur', this._handlers.commit);\n      this._handlers = {};\n    }\n  }\n  IMask.HTMLMaskElement = HTMLMaskElement;\n\n  /** Bridge between InputElement and {@link Masked} */\n  class HTMLInputMaskElement extends HTMLMaskElement {\n    /** InputElement to use mask on */\n\n    constructor(input) {\n      super(input);\n      this.input = input;\n    }\n\n    /** Returns InputElement selection start */\n    get _unsafeSelectionStart() {\n      return this.input.selectionStart != null ? this.input.selectionStart : this.value.length;\n    }\n\n    /** Returns InputElement selection end */\n    get _unsafeSelectionEnd() {\n      return this.input.selectionEnd;\n    }\n\n    /** Sets InputElement selection */\n    _unsafeSelect(start, end) {\n      this.input.setSelectionRange(start, end);\n    }\n    get value() {\n      return this.input.value;\n    }\n    set value(value) {\n      this.input.value = value;\n    }\n  }\n  IMask.HTMLMaskElement = HTMLMaskElement;\n  class HTMLContenteditableMaskElement extends HTMLMaskElement {\n    /** Returns HTMLElement selection start */\n    get _unsafeSelectionStart() {\n      const root = this.rootElement;\n      const selection = root.getSelection && root.getSelection();\n      const anchorOffset = selection && selection.anchorOffset;\n      const focusOffset = selection && selection.focusOffset;\n      if (focusOffset == null || anchorOffset == null || anchorOffset < focusOffset) {\n        return anchorOffset;\n      }\n      return focusOffset;\n    }\n\n    /** Returns HTMLElement selection end */\n    get _unsafeSelectionEnd() {\n      const root = this.rootElement;\n      const selection = root.getSelection && root.getSelection();\n      const anchorOffset = selection && selection.anchorOffset;\n      const focusOffset = selection && selection.focusOffset;\n      if (focusOffset == null || anchorOffset == null || anchorOffset > focusOffset) {\n        return anchorOffset;\n      }\n      return focusOffset;\n    }\n\n    /** Sets HTMLElement selection */\n    _unsafeSelect(start, end) {\n      if (!this.rootElement.createRange) return;\n      const range = this.rootElement.createRange();\n      range.setStart(this.input.firstChild || this.input, start);\n      range.setEnd(this.input.lastChild || this.input, end);\n      const root = this.rootElement;\n      const selection = root.getSelection && root.getSelection();\n      if (selection) {\n        selection.removeAllRanges();\n        selection.addRange(range);\n      }\n    }\n\n    /** HTMLElement value */\n    get value() {\n      return this.input.textContent || '';\n    }\n    set value(value) {\n      this.input.textContent = value;\n    }\n  }\n  IMask.HTMLContenteditableMaskElement = HTMLContenteditableMaskElement;\n  class InputHistory {\n    constructor() {\n      this.states = [];\n      this.currentIndex = 0;\n    }\n    get currentState() {\n      return this.states[this.currentIndex];\n    }\n    get isEmpty() {\n      return this.states.length === 0;\n    }\n    push(state) {\n      // if current index points before the last element then remove the future\n      if (this.currentIndex < this.states.length - 1) this.states.length = this.currentIndex + 1;\n      this.states.push(state);\n      if (this.states.length > InputHistory.MAX_LENGTH) this.states.shift();\n      this.currentIndex = this.states.length - 1;\n    }\n    go(steps) {\n      this.currentIndex = Math.min(Math.max(this.currentIndex + steps, 0), this.states.length - 1);\n      return this.currentState;\n    }\n    undo() {\n      return this.go(-1);\n    }\n    redo() {\n      return this.go(+1);\n    }\n    clear() {\n      this.states.length = 0;\n      this.currentIndex = 0;\n    }\n  }\n  InputHistory.MAX_LENGTH = 100;\n\n  /** Listens to element events and controls changes between element and {@link Masked} */\n  class InputMask {\n    /**\r\n     View element\r\n     */\n\n    /** Internal {@link Masked} model */\n\n    constructor(el, opts) {\n      this.el = el instanceof MaskElement ? el : el.isContentEditable && el.tagName !== 'INPUT' && el.tagName !== 'TEXTAREA' ? new HTMLContenteditableMaskElement(el) : new HTMLInputMaskElement(el);\n      this.masked = createMask(opts);\n      this._listeners = {};\n      this._value = '';\n      this._unmaskedValue = '';\n      this._rawInputValue = '';\n      this.history = new InputHistory();\n      this._saveSelection = this._saveSelection.bind(this);\n      this._onInput = this._onInput.bind(this);\n      this._onChange = this._onChange.bind(this);\n      this._onDrop = this._onDrop.bind(this);\n      this._onFocus = this._onFocus.bind(this);\n      this._onClick = this._onClick.bind(this);\n      this._onUndo = this._onUndo.bind(this);\n      this._onRedo = this._onRedo.bind(this);\n      this.alignCursor = this.alignCursor.bind(this);\n      this.alignCursorFriendly = this.alignCursorFriendly.bind(this);\n      this._bindEvents();\n\n      // refresh\n      this.updateValue();\n      this._onChange();\n    }\n    maskEquals(mask) {\n      var _this$masked;\n      return mask == null || ((_this$masked = this.masked) == null ? void 0 : _this$masked.maskEquals(mask));\n    }\n\n    /** Masked */\n    get mask() {\n      return this.masked.mask;\n    }\n    set mask(mask) {\n      if (this.maskEquals(mask)) return;\n      if (!(mask instanceof IMask.Masked) && this.masked.constructor === maskedClass(mask)) {\n        // TODO \"any\" no idea\n        this.masked.updateOptions({\n          mask\n        });\n        return;\n      }\n      const masked = mask instanceof IMask.Masked ? mask : createMask({\n        mask\n      });\n      masked.unmaskedValue = this.masked.unmaskedValue;\n      this.masked = masked;\n    }\n\n    /** Raw value */\n    get value() {\n      return this._value;\n    }\n    set value(str) {\n      if (this.value === str) return;\n      this.masked.value = str;\n      this.updateControl('auto');\n    }\n\n    /** Unmasked value */\n    get unmaskedValue() {\n      return this._unmaskedValue;\n    }\n    set unmaskedValue(str) {\n      if (this.unmaskedValue === str) return;\n      this.masked.unmaskedValue = str;\n      this.updateControl('auto');\n    }\n\n    /** Raw input value */\n    get rawInputValue() {\n      return this._rawInputValue;\n    }\n    set rawInputValue(str) {\n      if (this.rawInputValue === str) return;\n      this.masked.rawInputValue = str;\n      this.updateControl();\n      this.alignCursor();\n    }\n\n    /** Typed unmasked value */\n    get typedValue() {\n      return this.masked.typedValue;\n    }\n    set typedValue(val) {\n      if (this.masked.typedValueEquals(val)) return;\n      this.masked.typedValue = val;\n      this.updateControl('auto');\n    }\n\n    /** Display value */\n    get displayValue() {\n      return this.masked.displayValue;\n    }\n\n    /** Starts listening to element events */\n    _bindEvents() {\n      this.el.bindEvents({\n        selectionChange: this._saveSelection,\n        input: this._onInput,\n        drop: this._onDrop,\n        click: this._onClick,\n        focus: this._onFocus,\n        commit: this._onChange,\n        undo: this._onUndo,\n        redo: this._onRedo\n      });\n    }\n\n    /** Stops listening to element events */\n    _unbindEvents() {\n      if (this.el) this.el.unbindEvents();\n    }\n\n    /** Fires custom event */\n    _fireEvent(ev, e) {\n      const listeners = this._listeners[ev];\n      if (!listeners) return;\n      listeners.forEach(l => l(e));\n    }\n\n    /** Current selection start */\n    get selectionStart() {\n      return this._cursorChanging ? this._changingCursorPos : this.el.selectionStart;\n    }\n\n    /** Current cursor position */\n    get cursorPos() {\n      return this._cursorChanging ? this._changingCursorPos : this.el.selectionEnd;\n    }\n    set cursorPos(pos) {\n      if (!this.el || !this.el.isActive) return;\n      this.el.select(pos, pos);\n      this._saveSelection();\n    }\n\n    /** Stores current selection */\n    _saveSelection( /* ev */\n    ) {\n      if (this.displayValue !== this.el.value) {\n        console.warn('Element value was changed outside of mask. Syncronize mask using `mask.updateValue()` to work properly.'); // eslint-disable-line no-console\n      }\n      this._selection = {\n        start: this.selectionStart,\n        end: this.cursorPos\n      };\n    }\n\n    /** Syncronizes model value from view */\n    updateValue() {\n      this.masked.value = this.el.value;\n      this._value = this.masked.value;\n    }\n\n    /** Syncronizes view from model value, fires change events */\n    updateControl(cursorPos) {\n      const newUnmaskedValue = this.masked.unmaskedValue;\n      const newValue = this.masked.value;\n      const newRawInputValue = this.masked.rawInputValue;\n      const newDisplayValue = this.displayValue;\n      const isChanged = this.unmaskedValue !== newUnmaskedValue || this.value !== newValue || this._rawInputValue !== newRawInputValue;\n      this._unmaskedValue = newUnmaskedValue;\n      this._value = newValue;\n      this._rawInputValue = newRawInputValue;\n      if (this.el.value !== newDisplayValue) this.el.value = newDisplayValue;\n      if (cursorPos === 'auto') this.alignCursor();else if (cursorPos != null) this.cursorPos = cursorPos;\n      if (isChanged) this._fireChangeEvents();\n      if (!this._historyChanging && (isChanged || this.history.isEmpty)) this.history.push({\n        unmaskedValue: newUnmaskedValue,\n        selection: {\n          start: this.selectionStart,\n          end: this.cursorPos\n        }\n      });\n    }\n\n    /** Updates options with deep equal check, recreates {@link Masked} model if mask type changes */\n    updateOptions(opts) {\n      const {\n        mask,\n        ...restOpts\n      } = opts; // TODO types, yes, mask is optional\n\n      const updateMask = !this.maskEquals(mask);\n      const updateOpts = this.masked.optionsIsChanged(restOpts);\n      if (updateMask) this.mask = mask;\n      if (updateOpts) this.masked.updateOptions(restOpts); // TODO\n\n      if (updateMask || updateOpts) this.updateControl();\n    }\n\n    /** Updates cursor */\n    updateCursor(cursorPos) {\n      if (cursorPos == null) return;\n      this.cursorPos = cursorPos;\n\n      // also queue change cursor for mobile browsers\n      this._delayUpdateCursor(cursorPos);\n    }\n\n    /** Delays cursor update to support mobile browsers */\n    _delayUpdateCursor(cursorPos) {\n      this._abortUpdateCursor();\n      this._changingCursorPos = cursorPos;\n      this._cursorChanging = setTimeout(() => {\n        if (!this.el) return; // if was destroyed\n        this.cursorPos = this._changingCursorPos;\n        this._abortUpdateCursor();\n      }, 10);\n    }\n\n    /** Fires custom events */\n    _fireChangeEvents() {\n      this._fireEvent('accept', this._inputEvent);\n      if (this.masked.isComplete) this._fireEvent('complete', this._inputEvent);\n    }\n\n    /** Aborts delayed cursor update */\n    _abortUpdateCursor() {\n      if (this._cursorChanging) {\n        clearTimeout(this._cursorChanging);\n        delete this._cursorChanging;\n      }\n    }\n\n    /** Aligns cursor to nearest available position */\n    alignCursor() {\n      this.cursorPos = this.masked.nearestInputPos(this.masked.nearestInputPos(this.cursorPos, DIRECTION.LEFT));\n    }\n\n    /** Aligns cursor only if selection is empty */\n    alignCursorFriendly() {\n      if (this.selectionStart !== this.cursorPos) return; // skip if range is selected\n      this.alignCursor();\n    }\n\n    /** Adds listener on custom event */\n    on(ev, handler) {\n      if (!this._listeners[ev]) this._listeners[ev] = [];\n      this._listeners[ev].push(handler);\n      return this;\n    }\n\n    /** Removes custom event listener */\n    off(ev, handler) {\n      if (!this._listeners[ev]) return this;\n      if (!handler) {\n        delete this._listeners[ev];\n        return this;\n      }\n      const hIndex = this._listeners[ev].indexOf(handler);\n      if (hIndex >= 0) this._listeners[ev].splice(hIndex, 1);\n      return this;\n    }\n\n    /** Handles view input event */\n    _onInput(e) {\n      this._inputEvent = e;\n      this._abortUpdateCursor();\n      const details = new ActionDetails({\n        // new state\n        value: this.el.value,\n        cursorPos: this.cursorPos,\n        // old state\n        oldValue: this.displayValue,\n        oldSelection: this._selection\n      });\n      const oldRawValue = this.masked.rawInputValue;\n      const offset = this.masked.splice(details.startChangePos, details.removed.length, details.inserted, details.removeDirection, {\n        input: true,\n        raw: true\n      }).offset;\n\n      // force align in remove direction only if no input chars were removed\n      // otherwise we still need to align with NONE (to get out from fixed symbols for instance)\n      const removeDirection = oldRawValue === this.masked.rawInputValue ? details.removeDirection : DIRECTION.NONE;\n      let cursorPos = this.masked.nearestInputPos(details.startChangePos + offset, removeDirection);\n      if (removeDirection !== DIRECTION.NONE) cursorPos = this.masked.nearestInputPos(cursorPos, DIRECTION.NONE);\n      this.updateControl(cursorPos);\n      delete this._inputEvent;\n    }\n\n    /** Handles view change event and commits model value */\n    _onChange() {\n      if (this.displayValue !== this.el.value) {\n        this.updateValue();\n      }\n      this.masked.doCommit();\n      this.updateControl();\n      this._saveSelection();\n    }\n\n    /** Handles view drop event, prevents by default */\n    _onDrop(ev) {\n      ev.preventDefault();\n      ev.stopPropagation();\n    }\n\n    /** Restore last selection on focus */\n    _onFocus(ev) {\n      this.alignCursorFriendly();\n    }\n\n    /** Restore last selection on focus */\n    _onClick(ev) {\n      this.alignCursorFriendly();\n    }\n    _onUndo() {\n      this._applyHistoryState(this.history.undo());\n    }\n    _onRedo() {\n      this._applyHistoryState(this.history.redo());\n    }\n    _applyHistoryState(state) {\n      if (!state) return;\n      this._historyChanging = true;\n      this.unmaskedValue = state.unmaskedValue;\n      this.el.select(state.selection.start, state.selection.end);\n      this._saveSelection();\n      this._historyChanging = false;\n    }\n\n    /** Unbind view events and removes element reference */\n    destroy() {\n      this._unbindEvents();\n      this._listeners.length = 0;\n      delete this.el;\n    }\n  }\n  IMask.InputMask = InputMask;\n\n  /** Provides details of changing model value */\n  class ChangeDetails {\n    /** Inserted symbols */\n\n    /** Additional offset if any changes occurred before tail */\n\n    /** Raw inserted is used by dynamic mask */\n\n    /** Can skip chars */\n\n    static normalize(prep) {\n      return Array.isArray(prep) ? prep : [prep, new ChangeDetails()];\n    }\n    constructor(details) {\n      Object.assign(this, {\n        inserted: '',\n        rawInserted: '',\n        tailShift: 0,\n        skip: false\n      }, details);\n    }\n\n    /** Aggregate changes */\n    aggregate(details) {\n      this.inserted += details.inserted;\n      this.rawInserted += details.rawInserted;\n      this.tailShift += details.tailShift;\n      this.skip = this.skip || details.skip;\n      return this;\n    }\n\n    /** Total offset considering all changes */\n    get offset() {\n      return this.tailShift + this.inserted.length;\n    }\n    get consumed() {\n      return Boolean(this.rawInserted) || this.skip;\n    }\n    equals(details) {\n      return this.inserted === details.inserted && this.tailShift === details.tailShift && this.rawInserted === details.rawInserted && this.skip === details.skip;\n    }\n  }\n  IMask.ChangeDetails = ChangeDetails;\n\n  /** Provides details of continuous extracted tail */\n  class ContinuousTailDetails {\n    /** Tail value as string */\n\n    /** Tail start position */\n\n    /** Start position */\n\n    constructor(value, from, stop) {\n      if (value === void 0) {\n        value = '';\n      }\n      if (from === void 0) {\n        from = 0;\n      }\n      this.value = value;\n      this.from = from;\n      this.stop = stop;\n    }\n    toString() {\n      return this.value;\n    }\n    extend(tail) {\n      this.value += String(tail);\n    }\n    appendTo(masked) {\n      return masked.append(this.toString(), {\n        tail: true\n      }).aggregate(masked._appendPlaceholder());\n    }\n    get state() {\n      return {\n        value: this.value,\n        from: this.from,\n        stop: this.stop\n      };\n    }\n    set state(state) {\n      Object.assign(this, state);\n    }\n    unshift(beforePos) {\n      if (!this.value.length || beforePos != null && this.from >= beforePos) return '';\n      const shiftChar = this.value[0];\n      this.value = this.value.slice(1);\n      return shiftChar;\n    }\n    shift() {\n      if (!this.value.length) return '';\n      const shiftChar = this.value[this.value.length - 1];\n      this.value = this.value.slice(0, -1);\n      return shiftChar;\n    }\n  }\n\n  /** Append flags */\n\n  /** Extract flags */\n\n  // see https://github.com/microsoft/TypeScript/issues/6223\n\n  /** Provides common masking stuff */\n  class Masked {\n    /** */\n\n    /** */\n\n    /** Transforms value before mask processing */\n\n    /** Transforms each char before mask processing */\n\n    /** Validates if value is acceptable */\n\n    /** Does additional processing at the end of editing */\n\n    /** Format typed value to string */\n\n    /** Parse string to get typed value */\n\n    /** Enable characters overwriting */\n\n    /** */\n\n    /** */\n\n    /** */\n\n    /** */\n\n    constructor(opts) {\n      this._value = '';\n      this._update({\n        ...Masked.DEFAULTS,\n        ...opts\n      });\n      this._initialized = true;\n    }\n\n    /** Sets and applies new options */\n    updateOptions(opts) {\n      if (!this.optionsIsChanged(opts)) return;\n      this.withValueRefresh(this._update.bind(this, opts));\n    }\n\n    /** Sets new options */\n    _update(opts) {\n      Object.assign(this, opts);\n    }\n\n    /** Mask state */\n    get state() {\n      return {\n        _value: this.value,\n        _rawInputValue: this.rawInputValue\n      };\n    }\n    set state(state) {\n      this._value = state._value;\n    }\n\n    /** Resets value */\n    reset() {\n      this._value = '';\n    }\n    get value() {\n      return this._value;\n    }\n    set value(value) {\n      this.resolve(value, {\n        input: true\n      });\n    }\n\n    /** Resolve new value */\n    resolve(value, flags) {\n      if (flags === void 0) {\n        flags = {\n          input: true\n        };\n      }\n      this.reset();\n      this.append(value, flags, '');\n      this.doCommit();\n    }\n    get unmaskedValue() {\n      return this.value;\n    }\n    set unmaskedValue(value) {\n      this.resolve(value, {});\n    }\n    get typedValue() {\n      return this.parse ? this.parse(this.value, this) : this.unmaskedValue;\n    }\n    set typedValue(value) {\n      if (this.format) {\n        this.value = this.format(value, this);\n      } else {\n        this.unmaskedValue = String(value);\n      }\n    }\n\n    /** Value that includes raw user input */\n    get rawInputValue() {\n      return this.extractInput(0, this.displayValue.length, {\n        raw: true\n      });\n    }\n    set rawInputValue(value) {\n      this.resolve(value, {\n        raw: true\n      });\n    }\n    get displayValue() {\n      return this.value;\n    }\n    get isComplete() {\n      return true;\n    }\n    get isFilled() {\n      return this.isComplete;\n    }\n\n    /** Finds nearest input position in direction */\n    nearestInputPos(cursorPos, direction) {\n      return cursorPos;\n    }\n    totalInputPositions(fromPos, toPos) {\n      if (fromPos === void 0) {\n        fromPos = 0;\n      }\n      if (toPos === void 0) {\n        toPos = this.displayValue.length;\n      }\n      return Math.min(this.displayValue.length, toPos - fromPos);\n    }\n\n    /** Extracts value in range considering flags */\n    extractInput(fromPos, toPos, flags) {\n      if (fromPos === void 0) {\n        fromPos = 0;\n      }\n      if (toPos === void 0) {\n        toPos = this.displayValue.length;\n      }\n      return this.displayValue.slice(fromPos, toPos);\n    }\n\n    /** Extracts tail in range */\n    extractTail(fromPos, toPos) {\n      if (fromPos === void 0) {\n        fromPos = 0;\n      }\n      if (toPos === void 0) {\n        toPos = this.displayValue.length;\n      }\n      return new ContinuousTailDetails(this.extractInput(fromPos, toPos), fromPos);\n    }\n\n    /** Appends tail */\n    appendTail(tail) {\n      if (isString(tail)) tail = new ContinuousTailDetails(String(tail));\n      return tail.appendTo(this);\n    }\n\n    /** Appends char */\n    _appendCharRaw(ch, flags) {\n      if (!ch) return new ChangeDetails();\n      this._value += ch;\n      return new ChangeDetails({\n        inserted: ch,\n        rawInserted: ch\n      });\n    }\n\n    /** Appends char */\n    _appendChar(ch, flags, checkTail) {\n      if (flags === void 0) {\n        flags = {};\n      }\n      const consistentState = this.state;\n      let details;\n      [ch, details] = this.doPrepareChar(ch, flags);\n      if (ch) {\n        details = details.aggregate(this._appendCharRaw(ch, flags));\n\n        // TODO handle `skip`?\n\n        // try `autofix` lookahead\n        if (!details.rawInserted && this.autofix === 'pad') {\n          const noFixState = this.state;\n          this.state = consistentState;\n          let fixDetails = this.pad(flags);\n          const chDetails = this._appendCharRaw(ch, flags);\n          fixDetails = fixDetails.aggregate(chDetails);\n\n          // if fix was applied or\n          // if details are equal use skip restoring state optimization\n          if (chDetails.rawInserted || fixDetails.equals(details)) {\n            details = fixDetails;\n          } else {\n            this.state = noFixState;\n          }\n        }\n      }\n      if (details.inserted) {\n        let consistentTail;\n        let appended = this.doValidate(flags) !== false;\n        if (appended && checkTail != null) {\n          // validation ok, check tail\n          const beforeTailState = this.state;\n          if (this.overwrite === true) {\n            consistentTail = checkTail.state;\n            for (let i = 0; i < details.rawInserted.length; ++i) {\n              checkTail.unshift(this.displayValue.length - details.tailShift);\n            }\n          }\n          let tailDetails = this.appendTail(checkTail);\n          appended = tailDetails.rawInserted.length === checkTail.toString().length;\n\n          // not ok, try shift\n          if (!(appended && tailDetails.inserted) && this.overwrite === 'shift') {\n            this.state = beforeTailState;\n            consistentTail = checkTail.state;\n            for (let i = 0; i < details.rawInserted.length; ++i) {\n              checkTail.shift();\n            }\n            tailDetails = this.appendTail(checkTail);\n            appended = tailDetails.rawInserted.length === checkTail.toString().length;\n          }\n\n          // if ok, rollback state after tail\n          if (appended && tailDetails.inserted) this.state = beforeTailState;\n        }\n\n        // revert all if something went wrong\n        if (!appended) {\n          details = new ChangeDetails();\n          this.state = consistentState;\n          if (checkTail && consistentTail) checkTail.state = consistentTail;\n        }\n      }\n      return details;\n    }\n\n    /** Appends optional placeholder at the end */\n    _appendPlaceholder() {\n      return new ChangeDetails();\n    }\n\n    /** Appends optional eager placeholder at the end */\n    _appendEager() {\n      return new ChangeDetails();\n    }\n\n    /** Appends symbols considering flags */\n    append(str, flags, tail) {\n      if (!isString(str)) throw new Error('value should be string');\n      const checkTail = isString(tail) ? new ContinuousTailDetails(String(tail)) : tail;\n      if (flags != null && flags.tail) flags._beforeTailState = this.state;\n      let details;\n      [str, details] = this.doPrepare(str, flags);\n      for (let ci = 0; ci < str.length; ++ci) {\n        const d = this._appendChar(str[ci], flags, checkTail);\n        if (!d.rawInserted && !this.doSkipInvalid(str[ci], flags, checkTail)) break;\n        details.aggregate(d);\n      }\n      if ((this.eager === true || this.eager === 'append') && flags != null && flags.input && str) {\n        details.aggregate(this._appendEager());\n      }\n\n      // append tail but aggregate only tailShift\n      if (checkTail != null) {\n        details.tailShift += this.appendTail(checkTail).tailShift;\n        // TODO it's a good idea to clear state after appending ends\n        // but it causes bugs when one append calls another (when dynamic dispatch set rawInputValue)\n        // this._resetBeforeTailState();\n      }\n      return details;\n    }\n    remove(fromPos, toPos) {\n      if (fromPos === void 0) {\n        fromPos = 0;\n      }\n      if (toPos === void 0) {\n        toPos = this.displayValue.length;\n      }\n      this._value = this.displayValue.slice(0, fromPos) + this.displayValue.slice(toPos);\n      return new ChangeDetails();\n    }\n\n    /** Calls function and reapplies current value */\n    withValueRefresh(fn) {\n      if (this._refreshing || !this._initialized) return fn();\n      this._refreshing = true;\n      const rawInput = this.rawInputValue;\n      const value = this.value;\n      const ret = fn();\n      this.rawInputValue = rawInput;\n      // append lost trailing chars at the end\n      if (this.value && this.value !== value && value.indexOf(this.value) === 0) {\n        this.append(value.slice(this.displayValue.length), {}, '');\n        this.doCommit();\n      }\n      delete this._refreshing;\n      return ret;\n    }\n    runIsolated(fn) {\n      if (this._isolated || !this._initialized) return fn(this);\n      this._isolated = true;\n      const state = this.state;\n      const ret = fn(this);\n      this.state = state;\n      delete this._isolated;\n      return ret;\n    }\n    doSkipInvalid(ch, flags, checkTail) {\n      return Boolean(this.skipInvalid);\n    }\n\n    /** Prepares string before mask processing */\n    doPrepare(str, flags) {\n      if (flags === void 0) {\n        flags = {};\n      }\n      return ChangeDetails.normalize(this.prepare ? this.prepare(str, this, flags) : str);\n    }\n\n    /** Prepares each char before mask processing */\n    doPrepareChar(str, flags) {\n      if (flags === void 0) {\n        flags = {};\n      }\n      return ChangeDetails.normalize(this.prepareChar ? this.prepareChar(str, this, flags) : str);\n    }\n\n    /** Validates if value is acceptable */\n    doValidate(flags) {\n      return (!this.validate || this.validate(this.value, this, flags)) && (!this.parent || this.parent.doValidate(flags));\n    }\n\n    /** Does additional processing at the end of editing */\n    doCommit() {\n      if (this.commit) this.commit(this.value, this);\n    }\n    splice(start, deleteCount, inserted, removeDirection, flags) {\n      if (inserted === void 0) {\n        inserted = '';\n      }\n      if (removeDirection === void 0) {\n        removeDirection = DIRECTION.NONE;\n      }\n      if (flags === void 0) {\n        flags = {\n          input: true\n        };\n      }\n      const tailPos = start + deleteCount;\n      const tail = this.extractTail(tailPos);\n      const eagerRemove = this.eager === true || this.eager === 'remove';\n      let oldRawValue;\n      if (eagerRemove) {\n        removeDirection = forceDirection(removeDirection);\n        oldRawValue = this.extractInput(0, tailPos, {\n          raw: true\n        });\n      }\n      let startChangePos = start;\n      const details = new ChangeDetails();\n\n      // if it is just deletion without insertion\n      if (removeDirection !== DIRECTION.NONE) {\n        startChangePos = this.nearestInputPos(start, deleteCount > 1 && start !== 0 && !eagerRemove ? DIRECTION.NONE : removeDirection);\n\n        // adjust tailShift if start was aligned\n        details.tailShift = startChangePos - start;\n      }\n      details.aggregate(this.remove(startChangePos));\n      if (eagerRemove && removeDirection !== DIRECTION.NONE && oldRawValue === this.rawInputValue) {\n        if (removeDirection === DIRECTION.FORCE_LEFT) {\n          let valLength;\n          while (oldRawValue === this.rawInputValue && (valLength = this.displayValue.length)) {\n            details.aggregate(new ChangeDetails({\n              tailShift: -1\n            })).aggregate(this.remove(valLength - 1));\n          }\n        } else if (removeDirection === DIRECTION.FORCE_RIGHT) {\n          tail.unshift();\n        }\n      }\n      return details.aggregate(this.append(inserted, flags, tail));\n    }\n    maskEquals(mask) {\n      return this.mask === mask;\n    }\n    optionsIsChanged(opts) {\n      return !objectIncludes(this, opts);\n    }\n    typedValueEquals(value) {\n      const tval = this.typedValue;\n      return value === tval || Masked.EMPTY_VALUES.includes(value) && Masked.EMPTY_VALUES.includes(tval) || (this.format ? this.format(value, this) === this.format(this.typedValue, this) : false);\n    }\n    pad(flags) {\n      return new ChangeDetails();\n    }\n  }\n  Masked.DEFAULTS = {\n    skipInvalid: true\n  };\n  Masked.EMPTY_VALUES = [undefined, null, ''];\n  IMask.Masked = Masked;\n  class ChunksTailDetails {\n    /** */\n\n    constructor(chunks, from) {\n      if (chunks === void 0) {\n        chunks = [];\n      }\n      if (from === void 0) {\n        from = 0;\n      }\n      this.chunks = chunks;\n      this.from = from;\n    }\n    toString() {\n      return this.chunks.map(String).join('');\n    }\n    extend(tailChunk) {\n      if (!String(tailChunk)) return;\n      tailChunk = isString(tailChunk) ? new ContinuousTailDetails(String(tailChunk)) : tailChunk;\n      const lastChunk = this.chunks[this.chunks.length - 1];\n      const extendLast = lastChunk && (\n      // if stops are same or tail has no stop\n      lastChunk.stop === tailChunk.stop || tailChunk.stop == null) &&\n      // if tail chunk goes just after last chunk\n      tailChunk.from === lastChunk.from + lastChunk.toString().length;\n      if (tailChunk instanceof ContinuousTailDetails) {\n        // check the ability to extend previous chunk\n        if (extendLast) {\n          // extend previous chunk\n          lastChunk.extend(tailChunk.toString());\n        } else {\n          // append new chunk\n          this.chunks.push(tailChunk);\n        }\n      } else if (tailChunk instanceof ChunksTailDetails) {\n        if (tailChunk.stop == null) {\n          // unwrap floating chunks to parent, keeping `from` pos\n          let firstTailChunk;\n          while (tailChunk.chunks.length && tailChunk.chunks[0].stop == null) {\n            firstTailChunk = tailChunk.chunks.shift(); // not possible to be `undefined` because length was checked above\n            firstTailChunk.from += tailChunk.from;\n            this.extend(firstTailChunk);\n          }\n        }\n\n        // if tail chunk still has value\n        if (tailChunk.toString()) {\n          // if chunks contains stops, then popup stop to container\n          tailChunk.stop = tailChunk.blockIndex;\n          this.chunks.push(tailChunk);\n        }\n      }\n    }\n    appendTo(masked) {\n      if (!(masked instanceof IMask.MaskedPattern)) {\n        const tail = new ContinuousTailDetails(this.toString());\n        return tail.appendTo(masked);\n      }\n      const details = new ChangeDetails();\n      for (let ci = 0; ci < this.chunks.length; ++ci) {\n        const chunk = this.chunks[ci];\n        const lastBlockIter = masked._mapPosToBlock(masked.displayValue.length);\n        const stop = chunk.stop;\n        let chunkBlock;\n        if (stop != null && (\n        // if block not found or stop is behind lastBlock\n        !lastBlockIter || lastBlockIter.index <= stop)) {\n          if (chunk instanceof ChunksTailDetails ||\n          // for continuous block also check if stop is exist\n          masked._stops.indexOf(stop) >= 0) {\n            details.aggregate(masked._appendPlaceholder(stop));\n          }\n          chunkBlock = chunk instanceof ChunksTailDetails && masked._blocks[stop];\n        }\n        if (chunkBlock) {\n          const tailDetails = chunkBlock.appendTail(chunk);\n          details.aggregate(tailDetails);\n\n          // get not inserted chars\n          const remainChars = chunk.toString().slice(tailDetails.rawInserted.length);\n          if (remainChars) details.aggregate(masked.append(remainChars, {\n            tail: true\n          }));\n        } else {\n          details.aggregate(masked.append(chunk.toString(), {\n            tail: true\n          }));\n        }\n      }\n      return details;\n    }\n    get state() {\n      return {\n        chunks: this.chunks.map(c => c.state),\n        from: this.from,\n        stop: this.stop,\n        blockIndex: this.blockIndex\n      };\n    }\n    set state(state) {\n      const {\n        chunks,\n        ...props\n      } = state;\n      Object.assign(this, props);\n      this.chunks = chunks.map(cstate => {\n        const chunk = \"chunks\" in cstate ? new ChunksTailDetails() : new ContinuousTailDetails();\n        chunk.state = cstate;\n        return chunk;\n      });\n    }\n    unshift(beforePos) {\n      if (!this.chunks.length || beforePos != null && this.from >= beforePos) return '';\n      const chunkShiftPos = beforePos != null ? beforePos - this.from : beforePos;\n      let ci = 0;\n      while (ci < this.chunks.length) {\n        const chunk = this.chunks[ci];\n        const shiftChar = chunk.unshift(chunkShiftPos);\n        if (chunk.toString()) {\n          // chunk still contains value\n          // but not shifted - means no more available chars to shift\n          if (!shiftChar) break;\n          ++ci;\n        } else {\n          // clean if chunk has no value\n          this.chunks.splice(ci, 1);\n        }\n        if (shiftChar) return shiftChar;\n      }\n      return '';\n    }\n    shift() {\n      if (!this.chunks.length) return '';\n      let ci = this.chunks.length - 1;\n      while (0 <= ci) {\n        const chunk = this.chunks[ci];\n        const shiftChar = chunk.shift();\n        if (chunk.toString()) {\n          // chunk still contains value\n          // but not shifted - means no more available chars to shift\n          if (!shiftChar) break;\n          --ci;\n        } else {\n          // clean if chunk has no value\n          this.chunks.splice(ci, 1);\n        }\n        if (shiftChar) return shiftChar;\n      }\n      return '';\n    }\n  }\n  class PatternCursor {\n    constructor(masked, pos) {\n      this.masked = masked;\n      this._log = [];\n      const {\n        offset,\n        index\n      } = masked._mapPosToBlock(pos) || (pos < 0 ?\n      // first\n      {\n        index: 0,\n        offset: 0\n      } :\n      // last\n      {\n        index: this.masked._blocks.length,\n        offset: 0\n      });\n      this.offset = offset;\n      this.index = index;\n      this.ok = false;\n    }\n    get block() {\n      return this.masked._blocks[this.index];\n    }\n    get pos() {\n      return this.masked._blockStartPos(this.index) + this.offset;\n    }\n    get state() {\n      return {\n        index: this.index,\n        offset: this.offset,\n        ok: this.ok\n      };\n    }\n    set state(s) {\n      Object.assign(this, s);\n    }\n    pushState() {\n      this._log.push(this.state);\n    }\n    popState() {\n      const s = this._log.pop();\n      if (s) this.state = s;\n      return s;\n    }\n    bindBlock() {\n      if (this.block) return;\n      if (this.index < 0) {\n        this.index = 0;\n        this.offset = 0;\n      }\n      if (this.index >= this.masked._blocks.length) {\n        this.index = this.masked._blocks.length - 1;\n        this.offset = this.block.displayValue.length; // TODO this is stupid type error, `block` depends on index that was changed above\n      }\n    }\n    _pushLeft(fn) {\n      this.pushState();\n      for (this.bindBlock(); 0 <= this.index; --this.index, this.offset = ((_this$block = this.block) == null ? void 0 : _this$block.displayValue.length) || 0) {\n        var _this$block;\n        if (fn()) return this.ok = true;\n      }\n      return this.ok = false;\n    }\n    _pushRight(fn) {\n      this.pushState();\n      for (this.bindBlock(); this.index < this.masked._blocks.length; ++this.index, this.offset = 0) {\n        if (fn()) return this.ok = true;\n      }\n      return this.ok = false;\n    }\n    pushLeftBeforeFilled() {\n      return this._pushLeft(() => {\n        if (this.block.isFixed || !this.block.value) return;\n        this.offset = this.block.nearestInputPos(this.offset, DIRECTION.FORCE_LEFT);\n        if (this.offset !== 0) return true;\n      });\n    }\n    pushLeftBeforeInput() {\n      // cases:\n      // filled input: 00|\n      // optional empty input: 00[]|\n      // nested block: XX<[]>|\n      return this._pushLeft(() => {\n        if (this.block.isFixed) return;\n        this.offset = this.block.nearestInputPos(this.offset, DIRECTION.LEFT);\n        return true;\n      });\n    }\n    pushLeftBeforeRequired() {\n      return this._pushLeft(() => {\n        if (this.block.isFixed || this.block.isOptional && !this.block.value) return;\n        this.offset = this.block.nearestInputPos(this.offset, DIRECTION.LEFT);\n        return true;\n      });\n    }\n    pushRightBeforeFilled() {\n      return this._pushRight(() => {\n        if (this.block.isFixed || !this.block.value) return;\n        this.offset = this.block.nearestInputPos(this.offset, DIRECTION.FORCE_RIGHT);\n        if (this.offset !== this.block.value.length) return true;\n      });\n    }\n    pushRightBeforeInput() {\n      return this._pushRight(() => {\n        if (this.block.isFixed) return;\n\n        // const o = this.offset;\n        this.offset = this.block.nearestInputPos(this.offset, DIRECTION.NONE);\n        // HACK cases like (STILL DOES NOT WORK FOR NESTED)\n        // aa|X\n        // aa<X|[]>X_    - this will not work\n        // if (o && o === this.offset && this.block instanceof PatternInputDefinition) continue;\n        return true;\n      });\n    }\n    pushRightBeforeRequired() {\n      return this._pushRight(() => {\n        if (this.block.isFixed || this.block.isOptional && !this.block.value) return;\n\n        // TODO check |[*]XX_\n        this.offset = this.block.nearestInputPos(this.offset, DIRECTION.NONE);\n        return true;\n      });\n    }\n  }\n  class PatternFixedDefinition {\n    /** */\n\n    /** */\n\n    /** */\n\n    /** */\n\n    /** */\n\n    /** */\n\n    constructor(opts) {\n      Object.assign(this, opts);\n      this._value = '';\n      this.isFixed = true;\n    }\n    get value() {\n      return this._value;\n    }\n    get unmaskedValue() {\n      return this.isUnmasking ? this.value : '';\n    }\n    get rawInputValue() {\n      return this._isRawInput ? this.value : '';\n    }\n    get displayValue() {\n      return this.value;\n    }\n    reset() {\n      this._isRawInput = false;\n      this._value = '';\n    }\n    remove(fromPos, toPos) {\n      if (fromPos === void 0) {\n        fromPos = 0;\n      }\n      if (toPos === void 0) {\n        toPos = this._value.length;\n      }\n      this._value = this._value.slice(0, fromPos) + this._value.slice(toPos);\n      if (!this._value) this._isRawInput = false;\n      return new ChangeDetails();\n    }\n    nearestInputPos(cursorPos, direction) {\n      if (direction === void 0) {\n        direction = DIRECTION.NONE;\n      }\n      const minPos = 0;\n      const maxPos = this._value.length;\n      switch (direction) {\n        case DIRECTION.LEFT:\n        case DIRECTION.FORCE_LEFT:\n          return minPos;\n        case DIRECTION.NONE:\n        case DIRECTION.RIGHT:\n        case DIRECTION.FORCE_RIGHT:\n        default:\n          return maxPos;\n      }\n    }\n    totalInputPositions(fromPos, toPos) {\n      if (fromPos === void 0) {\n        fromPos = 0;\n      }\n      if (toPos === void 0) {\n        toPos = this._value.length;\n      }\n      return this._isRawInput ? toPos - fromPos : 0;\n    }\n    extractInput(fromPos, toPos, flags) {\n      if (fromPos === void 0) {\n        fromPos = 0;\n      }\n      if (toPos === void 0) {\n        toPos = this._value.length;\n      }\n      if (flags === void 0) {\n        flags = {};\n      }\n      return flags.raw && this._isRawInput && this._value.slice(fromPos, toPos) || '';\n    }\n    get isComplete() {\n      return true;\n    }\n    get isFilled() {\n      return Boolean(this._value);\n    }\n    _appendChar(ch, flags) {\n      if (flags === void 0) {\n        flags = {};\n      }\n      if (this.isFilled) return new ChangeDetails();\n      const appendEager = this.eager === true || this.eager === 'append';\n      const appended = this.char === ch;\n      const isResolved = appended && (this.isUnmasking || flags.input || flags.raw) && (!flags.raw || !appendEager) && !flags.tail;\n      const details = new ChangeDetails({\n        inserted: this.char,\n        rawInserted: isResolved ? this.char : ''\n      });\n      this._value = this.char;\n      this._isRawInput = isResolved && (flags.raw || flags.input);\n      return details;\n    }\n    _appendEager() {\n      return this._appendChar(this.char, {\n        tail: true\n      });\n    }\n    _appendPlaceholder() {\n      const details = new ChangeDetails();\n      if (this.isFilled) return details;\n      this._value = details.inserted = this.char;\n      return details;\n    }\n    extractTail() {\n      return new ContinuousTailDetails('');\n    }\n    appendTail(tail) {\n      if (isString(tail)) tail = new ContinuousTailDetails(String(tail));\n      return tail.appendTo(this);\n    }\n    append(str, flags, tail) {\n      const details = this._appendChar(str[0], flags);\n      if (tail != null) {\n        details.tailShift += this.appendTail(tail).tailShift;\n      }\n      return details;\n    }\n    doCommit() {}\n    get state() {\n      return {\n        _value: this._value,\n        _rawInputValue: this.rawInputValue\n      };\n    }\n    set state(state) {\n      this._value = state._value;\n      this._isRawInput = Boolean(state._rawInputValue);\n    }\n    pad(flags) {\n      return this._appendPlaceholder();\n    }\n  }\n  class PatternInputDefinition {\n    /** */\n\n    /** */\n\n    /** */\n\n    /** */\n\n    /** */\n\n    /** */\n\n    /** */\n\n    /** */\n\n    constructor(opts) {\n      const {\n        parent,\n        isOptional,\n        placeholderChar,\n        displayChar,\n        lazy,\n        eager,\n        ...maskOpts\n      } = opts;\n      this.masked = createMask(maskOpts);\n      Object.assign(this, {\n        parent,\n        isOptional,\n        placeholderChar,\n        displayChar,\n        lazy,\n        eager\n      });\n    }\n    reset() {\n      this.isFilled = false;\n      this.masked.reset();\n    }\n    remove(fromPos, toPos) {\n      if (fromPos === void 0) {\n        fromPos = 0;\n      }\n      if (toPos === void 0) {\n        toPos = this.value.length;\n      }\n      if (fromPos === 0 && toPos >= 1) {\n        this.isFilled = false;\n        return this.masked.remove(fromPos, toPos);\n      }\n      return new ChangeDetails();\n    }\n    get value() {\n      return this.masked.value || (this.isFilled && !this.isOptional ? this.placeholderChar : '');\n    }\n    get unmaskedValue() {\n      return this.masked.unmaskedValue;\n    }\n    get rawInputValue() {\n      return this.masked.rawInputValue;\n    }\n    get displayValue() {\n      return this.masked.value && this.displayChar || this.value;\n    }\n    get isComplete() {\n      return Boolean(this.masked.value) || this.isOptional;\n    }\n    _appendChar(ch, flags) {\n      if (flags === void 0) {\n        flags = {};\n      }\n      if (this.isFilled) return new ChangeDetails();\n      const state = this.masked.state;\n      // simulate input\n      let details = this.masked._appendChar(ch, this.currentMaskFlags(flags));\n      if (details.inserted && this.doValidate(flags) === false) {\n        details = new ChangeDetails();\n        this.masked.state = state;\n      }\n      if (!details.inserted && !this.isOptional && !this.lazy && !flags.input) {\n        details.inserted = this.placeholderChar;\n      }\n      details.skip = !details.inserted && !this.isOptional;\n      this.isFilled = Boolean(details.inserted);\n      return details;\n    }\n    append(str, flags, tail) {\n      // TODO probably should be done via _appendChar\n      return this.masked.append(str, this.currentMaskFlags(flags), tail);\n    }\n    _appendPlaceholder() {\n      if (this.isFilled || this.isOptional) return new ChangeDetails();\n      this.isFilled = true;\n      return new ChangeDetails({\n        inserted: this.placeholderChar\n      });\n    }\n    _appendEager() {\n      return new ChangeDetails();\n    }\n    extractTail(fromPos, toPos) {\n      return this.masked.extractTail(fromPos, toPos);\n    }\n    appendTail(tail) {\n      return this.masked.appendTail(tail);\n    }\n    extractInput(fromPos, toPos, flags) {\n      if (fromPos === void 0) {\n        fromPos = 0;\n      }\n      if (toPos === void 0) {\n        toPos = this.value.length;\n      }\n      return this.masked.extractInput(fromPos, toPos, flags);\n    }\n    nearestInputPos(cursorPos, direction) {\n      if (direction === void 0) {\n        direction = DIRECTION.NONE;\n      }\n      const minPos = 0;\n      const maxPos = this.value.length;\n      const boundPos = Math.min(Math.max(cursorPos, minPos), maxPos);\n      switch (direction) {\n        case DIRECTION.LEFT:\n        case DIRECTION.FORCE_LEFT:\n          return this.isComplete ? boundPos : minPos;\n        case DIRECTION.RIGHT:\n        case DIRECTION.FORCE_RIGHT:\n          return this.isComplete ? boundPos : maxPos;\n        case DIRECTION.NONE:\n        default:\n          return boundPos;\n      }\n    }\n    totalInputPositions(fromPos, toPos) {\n      if (fromPos === void 0) {\n        fromPos = 0;\n      }\n      if (toPos === void 0) {\n        toPos = this.value.length;\n      }\n      return this.value.slice(fromPos, toPos).length;\n    }\n    doValidate(flags) {\n      return this.masked.doValidate(this.currentMaskFlags(flags)) && (!this.parent || this.parent.doValidate(this.currentMaskFlags(flags)));\n    }\n    doCommit() {\n      this.masked.doCommit();\n    }\n    get state() {\n      return {\n        _value: this.value,\n        _rawInputValue: this.rawInputValue,\n        masked: this.masked.state,\n        isFilled: this.isFilled\n      };\n    }\n    set state(state) {\n      this.masked.state = state.masked;\n      this.isFilled = state.isFilled;\n    }\n    currentMaskFlags(flags) {\n      var _flags$_beforeTailSta;\n      return {\n        ...flags,\n        _beforeTailState: (flags == null || (_flags$_beforeTailSta = flags._beforeTailState) == null ? void 0 : _flags$_beforeTailSta.masked) || (flags == null ? void 0 : flags._beforeTailState)\n      };\n    }\n    pad(flags) {\n      return new ChangeDetails();\n    }\n  }\n  PatternInputDefinition.DEFAULT_DEFINITIONS = {\n    '0': /\\d/,\n    'a': /[\\u0041-\\u005A\\u0061-\\u007A\\u00AA\\u00B5\\u00BA\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0370-\\u0374\\u0376\\u0377\\u037A-\\u037D\\u0386\\u0388-\\u038A\\u038C\\u038E-\\u03A1\\u03A3-\\u03F5\\u03F7-\\u0481\\u048A-\\u0527\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u05D0-\\u05EA\\u05F0-\\u05F2\\u0620-\\u064A\\u066E\\u066F\\u0671-\\u06D3\\u06D5\\u06E5\\u06E6\\u06EE\\u06EF\\u06FA-\\u06FC\\u06FF\\u0710\\u0712-\\u072F\\u074D-\\u07A5\\u07B1\\u07CA-\\u07EA\\u07F4\\u07F5\\u07FA\\u0800-\\u0815\\u081A\\u0824\\u0828\\u0840-\\u0858\\u08A0\\u08A2-\\u08AC\\u0904-\\u0939\\u093D\\u0950\\u0958-\\u0961\\u0971-\\u0977\\u0979-\\u097F\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BD\\u09CE\\u09DC\\u09DD\\u09DF-\\u09E1\\u09F0\\u09F1\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A59-\\u0A5C\\u0A5E\\u0A72-\\u0A74\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABD\\u0AD0\\u0AE0\\u0AE1\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B35-\\u0B39\\u0B3D\\u0B5C\\u0B5D\\u0B5F-\\u0B61\\u0B71\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BD0\\u0C05-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C33\\u0C35-\\u0C39\\u0C3D\\u0C58\\u0C59\\u0C60\\u0C61\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBD\\u0CDE\\u0CE0\\u0CE1\\u0CF1\\u0CF2\\u0D05-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D3A\\u0D3D\\u0D4E\\u0D60\\u0D61\\u0D7A-\\u0D7F\\u0D85-\\u0D96\\u0D9A-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0E01-\\u0E30\\u0E32\\u0E33\\u0E40-\\u0E46\\u0E81\\u0E82\\u0E84\\u0E87\\u0E88\\u0E8A\\u0E8D\\u0E94-\\u0E97\\u0E99-\\u0E9F\\u0EA1-\\u0EA3\\u0EA5\\u0EA7\\u0EAA\\u0EAB\\u0EAD-\\u0EB0\\u0EB2\\u0EB3\\u0EBD\\u0EC0-\\u0EC4\\u0EC6\\u0EDC-\\u0EDF\\u0F00\\u0F40-\\u0F47\\u0F49-\\u0F6C\\u0F88-\\u0F8C\\u1000-\\u102A\\u103F\\u1050-\\u1055\\u105A-\\u105D\\u1061\\u1065\\u1066\\u106E-\\u1070\\u1075-\\u1081\\u108E\\u10A0-\\u10C5\\u10C7\\u10CD\\u10D0-\\u10FA\\u10FC-\\u1248\\u124A-\\u124D\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310\\u1312-\\u1315\\u1318-\\u135A\\u1380-\\u138F\\u13A0-\\u13F4\\u1401-\\u166C\\u166F-\\u167F\\u1681-\\u169A\\u16A0-\\u16EA\\u1700-\\u170C\\u170E-\\u1711\\u1720-\\u1731\\u1740-\\u1751\\u1760-\\u176C\\u176E-\\u1770\\u1780-\\u17B3\\u17D7\\u17DC\\u1820-\\u1877\\u1880-\\u18A8\\u18AA\\u18B0-\\u18F5\\u1900-\\u191C\\u1950-\\u196D\\u1970-\\u1974\\u1980-\\u19AB\\u19C1-\\u19C7\\u1A00-\\u1A16\\u1A20-\\u1A54\\u1AA7\\u1B05-\\u1B33\\u1B45-\\u1B4B\\u1B83-\\u1BA0\\u1BAE\\u1BAF\\u1BBA-\\u1BE5\\u1C00-\\u1C23\\u1C4D-\\u1C4F\\u1C5A-\\u1C7D\\u1CE9-\\u1CEC\\u1CEE-\\u1CF1\\u1CF5\\u1CF6\\u1D00-\\u1DBF\\u1E00-\\u1F15\\u1F18-\\u1F1D\\u1F20-\\u1F45\\u1F48-\\u1F4D\\u1F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F7D\\u1F80-\\u1FB4\\u1FB6-\\u1FBC\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD0-\\u1FD3\\u1FD6-\\u1FDB\\u1FE0-\\u1FEC\\u1FF2-\\u1FF4\\u1FF6-\\u1FFC\\u2071\\u207F\\u2090-\\u209C\\u2102\\u2107\\u210A-\\u2113\\u2115\\u2119-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u212D\\u212F-\\u2139\\u213C-\\u213F\\u2145-\\u2149\\u214E\\u2183\\u2184\\u2C00-\\u2C2E\\u2C30-\\u2C5E\\u2C60-\\u2CE4\\u2CEB-\\u2CEE\\u2CF2\\u2CF3\\u2D00-\\u2D25\\u2D27\\u2D2D\\u2D30-\\u2D67\\u2D6F\\u2D80-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u2E2F\\u3005\\u3006\\u3031-\\u3035\\u303B\\u303C\\u3041-\\u3096\\u309D-\\u309F\\u30A1-\\u30FA\\u30FC-\\u30FF\\u3105-\\u312D\\u3131-\\u318E\\u31A0-\\u31BA\\u31F0-\\u31FF\\u3400-\\u4DB5\\u4E00-\\u9FCC\\uA000-\\uA48C\\uA4D0-\\uA4FD\\uA500-\\uA60C\\uA610-\\uA61F\\uA62A\\uA62B\\uA640-\\uA66E\\uA67F-\\uA697\\uA6A0-\\uA6E5\\uA717-\\uA71F\\uA722-\\uA788\\uA78B-\\uA78E\\uA790-\\uA793\\uA7A0-\\uA7AA\\uA7F8-\\uA801\\uA803-\\uA805\\uA807-\\uA80A\\uA80C-\\uA822\\uA840-\\uA873\\uA882-\\uA8B3\\uA8F2-\\uA8F7\\uA8FB\\uA90A-\\uA925\\uA930-\\uA946\\uA960-\\uA97C\\uA984-\\uA9B2\\uA9CF\\uAA00-\\uAA28\\uAA40-\\uAA42\\uAA44-\\uAA4B\\uAA60-\\uAA76\\uAA7A\\uAA80-\\uAAAF\\uAAB1\\uAAB5\\uAAB6\\uAAB9-\\uAABD\\uAAC0\\uAAC2\\uAADB-\\uAADD\\uAAE0-\\uAAEA\\uAAF2-\\uAAF4\\uAB01-\\uAB06\\uAB09-\\uAB0E\\uAB11-\\uAB16\\uAB20-\\uAB26\\uAB28-\\uAB2E\\uABC0-\\uABE2\\uAC00-\\uD7A3\\uD7B0-\\uD7C6\\uD7CB-\\uD7FB\\uF900-\\uFA6D\\uFA70-\\uFAD9\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFB1D\\uFB1F-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40\\uFB41\\uFB43\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF21-\\uFF3A\\uFF41-\\uFF5A\\uFF66-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC]/,\n    // http://stackoverflow.com/a/22075070\n    '*': /./\n  };\n\n  /** Masking by RegExp */\n  class MaskedRegExp extends Masked {\n    /** */\n\n    /** Enable characters overwriting */\n\n    /** */\n\n    /** */\n\n    /** */\n\n    updateOptions(opts) {\n      super.updateOptions(opts);\n    }\n    _update(opts) {\n      const mask = opts.mask;\n      if (mask) opts.validate = value => value.search(mask) >= 0;\n      super._update(opts);\n    }\n  }\n  IMask.MaskedRegExp = MaskedRegExp;\n\n  /** Pattern mask */\n  class MaskedPattern extends Masked {\n    /** */\n\n    /** */\n\n    /** Single char for empty input */\n\n    /** Single char for filled input */\n\n    /** Show placeholder only when needed */\n\n    /** Enable characters overwriting */\n\n    /** */\n\n    /** */\n\n    /** */\n\n    constructor(opts) {\n      super({\n        ...MaskedPattern.DEFAULTS,\n        ...opts,\n        definitions: Object.assign({}, PatternInputDefinition.DEFAULT_DEFINITIONS, opts == null ? void 0 : opts.definitions)\n      });\n    }\n    updateOptions(opts) {\n      super.updateOptions(opts);\n    }\n    _update(opts) {\n      opts.definitions = Object.assign({}, this.definitions, opts.definitions);\n      super._update(opts);\n      this._rebuildMask();\n    }\n    _rebuildMask() {\n      const defs = this.definitions;\n      this._blocks = [];\n      this.exposeBlock = undefined;\n      this._stops = [];\n      this._maskedBlocks = {};\n      const pattern = this.mask;\n      if (!pattern || !defs) return;\n      let unmaskingBlock = false;\n      let optionalBlock = false;\n      for (let i = 0; i < pattern.length; ++i) {\n        if (this.blocks) {\n          const p = pattern.slice(i);\n          const bNames = Object.keys(this.blocks).filter(bName => p.indexOf(bName) === 0);\n          // order by key length\n          bNames.sort((a, b) => b.length - a.length);\n          // use block name with max length\n          const bName = bNames[0];\n          if (bName) {\n            const {\n              expose,\n              repeat,\n              ...bOpts\n            } = normalizeOpts(this.blocks[bName]); // TODO type Opts<Arg & Extra>\n            const blockOpts = {\n              lazy: this.lazy,\n              eager: this.eager,\n              placeholderChar: this.placeholderChar,\n              displayChar: this.displayChar,\n              overwrite: this.overwrite,\n              autofix: this.autofix,\n              ...bOpts,\n              repeat,\n              parent: this\n            };\n            const maskedBlock = repeat != null ? new IMask.RepeatBlock(blockOpts /* TODO */) : createMask(blockOpts);\n            if (maskedBlock) {\n              this._blocks.push(maskedBlock);\n              if (expose) this.exposeBlock = maskedBlock;\n\n              // store block index\n              if (!this._maskedBlocks[bName]) this._maskedBlocks[bName] = [];\n              this._maskedBlocks[bName].push(this._blocks.length - 1);\n            }\n            i += bName.length - 1;\n            continue;\n          }\n        }\n        let char = pattern[i];\n        let isInput = (char in defs);\n        if (char === MaskedPattern.STOP_CHAR) {\n          this._stops.push(this._blocks.length);\n          continue;\n        }\n        if (char === '{' || char === '}') {\n          unmaskingBlock = !unmaskingBlock;\n          continue;\n        }\n        if (char === '[' || char === ']') {\n          optionalBlock = !optionalBlock;\n          continue;\n        }\n        if (char === MaskedPattern.ESCAPE_CHAR) {\n          ++i;\n          char = pattern[i];\n          if (!char) break;\n          isInput = false;\n        }\n        const def = isInput ? new PatternInputDefinition({\n          isOptional: optionalBlock,\n          lazy: this.lazy,\n          eager: this.eager,\n          placeholderChar: this.placeholderChar,\n          displayChar: this.displayChar,\n          ...normalizeOpts(defs[char]),\n          parent: this\n        }) : new PatternFixedDefinition({\n          char,\n          eager: this.eager,\n          isUnmasking: unmaskingBlock\n        });\n        this._blocks.push(def);\n      }\n    }\n    get state() {\n      return {\n        ...super.state,\n        _blocks: this._blocks.map(b => b.state)\n      };\n    }\n    set state(state) {\n      if (!state) {\n        this.reset();\n        return;\n      }\n      const {\n        _blocks,\n        ...maskedState\n      } = state;\n      this._blocks.forEach((b, bi) => b.state = _blocks[bi]);\n      super.state = maskedState;\n    }\n    reset() {\n      super.reset();\n      this._blocks.forEach(b => b.reset());\n    }\n    get isComplete() {\n      return this.exposeBlock ? this.exposeBlock.isComplete : this._blocks.every(b => b.isComplete);\n    }\n    get isFilled() {\n      return this._blocks.every(b => b.isFilled);\n    }\n    get isFixed() {\n      return this._blocks.every(b => b.isFixed);\n    }\n    get isOptional() {\n      return this._blocks.every(b => b.isOptional);\n    }\n    doCommit() {\n      this._blocks.forEach(b => b.doCommit());\n      super.doCommit();\n    }\n    get unmaskedValue() {\n      return this.exposeBlock ? this.exposeBlock.unmaskedValue : this._blocks.reduce((str, b) => str += b.unmaskedValue, '');\n    }\n    set unmaskedValue(unmaskedValue) {\n      if (this.exposeBlock) {\n        const tail = this.extractTail(this._blockStartPos(this._blocks.indexOf(this.exposeBlock)) + this.exposeBlock.displayValue.length);\n        this.exposeBlock.unmaskedValue = unmaskedValue;\n        this.appendTail(tail);\n        this.doCommit();\n      } else super.unmaskedValue = unmaskedValue;\n    }\n    get value() {\n      return this.exposeBlock ? this.exposeBlock.value :\n      // TODO return _value when not in change?\n      this._blocks.reduce((str, b) => str += b.value, '');\n    }\n    set value(value) {\n      if (this.exposeBlock) {\n        const tail = this.extractTail(this._blockStartPos(this._blocks.indexOf(this.exposeBlock)) + this.exposeBlock.displayValue.length);\n        this.exposeBlock.value = value;\n        this.appendTail(tail);\n        this.doCommit();\n      } else super.value = value;\n    }\n    get typedValue() {\n      return this.exposeBlock ? this.exposeBlock.typedValue : super.typedValue;\n    }\n    set typedValue(value) {\n      if (this.exposeBlock) {\n        const tail = this.extractTail(this._blockStartPos(this._blocks.indexOf(this.exposeBlock)) + this.exposeBlock.displayValue.length);\n        this.exposeBlock.typedValue = value;\n        this.appendTail(tail);\n        this.doCommit();\n      } else super.typedValue = value;\n    }\n    get displayValue() {\n      return this._blocks.reduce((str, b) => str += b.displayValue, '');\n    }\n    appendTail(tail) {\n      return super.appendTail(tail).aggregate(this._appendPlaceholder());\n    }\n    _appendEager() {\n      var _this$_mapPosToBlock;\n      const details = new ChangeDetails();\n      let startBlockIndex = (_this$_mapPosToBlock = this._mapPosToBlock(this.displayValue.length)) == null ? void 0 : _this$_mapPosToBlock.index;\n      if (startBlockIndex == null) return details;\n\n      // TODO test if it works for nested pattern masks\n      if (this._blocks[startBlockIndex].isFilled) ++startBlockIndex;\n      for (let bi = startBlockIndex; bi < this._blocks.length; ++bi) {\n        const d = this._blocks[bi]._appendEager();\n        if (!d.inserted) break;\n        details.aggregate(d);\n      }\n      return details;\n    }\n    _appendCharRaw(ch, flags) {\n      if (flags === void 0) {\n        flags = {};\n      }\n      const blockIter = this._mapPosToBlock(this.displayValue.length);\n      const details = new ChangeDetails();\n      if (!blockIter) return details;\n      for (let bi = blockIter.index, block; block = this._blocks[bi]; ++bi) {\n        var _flags$_beforeTailSta;\n        const blockDetails = block._appendChar(ch, {\n          ...flags,\n          _beforeTailState: (_flags$_beforeTailSta = flags._beforeTailState) == null || (_flags$_beforeTailSta = _flags$_beforeTailSta._blocks) == null ? void 0 : _flags$_beforeTailSta[bi]\n        });\n        details.aggregate(blockDetails);\n        if (blockDetails.consumed) break; // go next char\n      }\n      return details;\n    }\n    extractTail(fromPos, toPos) {\n      if (fromPos === void 0) {\n        fromPos = 0;\n      }\n      if (toPos === void 0) {\n        toPos = this.displayValue.length;\n      }\n      const chunkTail = new ChunksTailDetails();\n      if (fromPos === toPos) return chunkTail;\n      this._forEachBlocksInRange(fromPos, toPos, (b, bi, bFromPos, bToPos) => {\n        const blockChunk = b.extractTail(bFromPos, bToPos);\n        blockChunk.stop = this._findStopBefore(bi);\n        blockChunk.from = this._blockStartPos(bi);\n        if (blockChunk instanceof ChunksTailDetails) blockChunk.blockIndex = bi;\n        chunkTail.extend(blockChunk);\n      });\n      return chunkTail;\n    }\n    extractInput(fromPos, toPos, flags) {\n      if (fromPos === void 0) {\n        fromPos = 0;\n      }\n      if (toPos === void 0) {\n        toPos = this.displayValue.length;\n      }\n      if (flags === void 0) {\n        flags = {};\n      }\n      if (fromPos === toPos) return '';\n      let input = '';\n      this._forEachBlocksInRange(fromPos, toPos, (b, _, fromPos, toPos) => {\n        input += b.extractInput(fromPos, toPos, flags);\n      });\n      return input;\n    }\n    _findStopBefore(blockIndex) {\n      let stopBefore;\n      for (let si = 0; si < this._stops.length; ++si) {\n        const stop = this._stops[si];\n        if (stop <= blockIndex) stopBefore = stop;else break;\n      }\n      return stopBefore;\n    }\n\n    /** Appends placeholder depending on laziness */\n    _appendPlaceholder(toBlockIndex) {\n      const details = new ChangeDetails();\n      if (this.lazy && toBlockIndex == null) return details;\n      const startBlockIter = this._mapPosToBlock(this.displayValue.length);\n      if (!startBlockIter) return details;\n      const startBlockIndex = startBlockIter.index;\n      const endBlockIndex = toBlockIndex != null ? toBlockIndex : this._blocks.length;\n      this._blocks.slice(startBlockIndex, endBlockIndex).forEach(b => {\n        if (!b.lazy || toBlockIndex != null) {\n          var _blocks2;\n          details.aggregate(b._appendPlaceholder((_blocks2 = b._blocks) == null ? void 0 : _blocks2.length));\n        }\n      });\n      return details;\n    }\n\n    /** Finds block in pos */\n    _mapPosToBlock(pos) {\n      let accVal = '';\n      for (let bi = 0; bi < this._blocks.length; ++bi) {\n        const block = this._blocks[bi];\n        const blockStartPos = accVal.length;\n        accVal += block.displayValue;\n        if (pos <= accVal.length) {\n          return {\n            index: bi,\n            offset: pos - blockStartPos\n          };\n        }\n      }\n    }\n    _blockStartPos(blockIndex) {\n      return this._blocks.slice(0, blockIndex).reduce((pos, b) => pos += b.displayValue.length, 0);\n    }\n    _forEachBlocksInRange(fromPos, toPos, fn) {\n      if (toPos === void 0) {\n        toPos = this.displayValue.length;\n      }\n      const fromBlockIter = this._mapPosToBlock(fromPos);\n      if (fromBlockIter) {\n        const toBlockIter = this._mapPosToBlock(toPos);\n        // process first block\n        const isSameBlock = toBlockIter && fromBlockIter.index === toBlockIter.index;\n        const fromBlockStartPos = fromBlockIter.offset;\n        const fromBlockEndPos = toBlockIter && isSameBlock ? toBlockIter.offset : this._blocks[fromBlockIter.index].displayValue.length;\n        fn(this._blocks[fromBlockIter.index], fromBlockIter.index, fromBlockStartPos, fromBlockEndPos);\n        if (toBlockIter && !isSameBlock) {\n          // process intermediate blocks\n          for (let bi = fromBlockIter.index + 1; bi < toBlockIter.index; ++bi) {\n            fn(this._blocks[bi], bi, 0, this._blocks[bi].displayValue.length);\n          }\n\n          // process last block\n          fn(this._blocks[toBlockIter.index], toBlockIter.index, 0, toBlockIter.offset);\n        }\n      }\n    }\n    remove(fromPos, toPos) {\n      if (fromPos === void 0) {\n        fromPos = 0;\n      }\n      if (toPos === void 0) {\n        toPos = this.displayValue.length;\n      }\n      const removeDetails = super.remove(fromPos, toPos);\n      this._forEachBlocksInRange(fromPos, toPos, (b, _, bFromPos, bToPos) => {\n        removeDetails.aggregate(b.remove(bFromPos, bToPos));\n      });\n      return removeDetails;\n    }\n    nearestInputPos(cursorPos, direction) {\n      if (direction === void 0) {\n        direction = DIRECTION.NONE;\n      }\n      if (!this._blocks.length) return 0;\n      const cursor = new PatternCursor(this, cursorPos);\n      if (direction === DIRECTION.NONE) {\n        // -------------------------------------------------\n        // NONE should only go out from fixed to the right!\n        // -------------------------------------------------\n        if (cursor.pushRightBeforeInput()) return cursor.pos;\n        cursor.popState();\n        if (cursor.pushLeftBeforeInput()) return cursor.pos;\n        return this.displayValue.length;\n      }\n\n      // FORCE is only about a|* otherwise is 0\n      if (direction === DIRECTION.LEFT || direction === DIRECTION.FORCE_LEFT) {\n        // try to break fast when *|a\n        if (direction === DIRECTION.LEFT) {\n          cursor.pushRightBeforeFilled();\n          if (cursor.ok && cursor.pos === cursorPos) return cursorPos;\n          cursor.popState();\n        }\n\n        // forward flow\n        cursor.pushLeftBeforeInput();\n        cursor.pushLeftBeforeRequired();\n        cursor.pushLeftBeforeFilled();\n\n        // backward flow\n        if (direction === DIRECTION.LEFT) {\n          cursor.pushRightBeforeInput();\n          cursor.pushRightBeforeRequired();\n          if (cursor.ok && cursor.pos <= cursorPos) return cursor.pos;\n          cursor.popState();\n          if (cursor.ok && cursor.pos <= cursorPos) return cursor.pos;\n          cursor.popState();\n        }\n        if (cursor.ok) return cursor.pos;\n        if (direction === DIRECTION.FORCE_LEFT) return 0;\n        cursor.popState();\n        if (cursor.ok) return cursor.pos;\n        cursor.popState();\n        if (cursor.ok) return cursor.pos;\n        return 0;\n      }\n      if (direction === DIRECTION.RIGHT || direction === DIRECTION.FORCE_RIGHT) {\n        // forward flow\n        cursor.pushRightBeforeInput();\n        cursor.pushRightBeforeRequired();\n        if (cursor.pushRightBeforeFilled()) return cursor.pos;\n        if (direction === DIRECTION.FORCE_RIGHT) return this.displayValue.length;\n\n        // backward flow\n        cursor.popState();\n        if (cursor.ok) return cursor.pos;\n        cursor.popState();\n        if (cursor.ok) return cursor.pos;\n        return this.nearestInputPos(cursorPos, DIRECTION.LEFT);\n      }\n      return cursorPos;\n    }\n    totalInputPositions(fromPos, toPos) {\n      if (fromPos === void 0) {\n        fromPos = 0;\n      }\n      if (toPos === void 0) {\n        toPos = this.displayValue.length;\n      }\n      let total = 0;\n      this._forEachBlocksInRange(fromPos, toPos, (b, _, bFromPos, bToPos) => {\n        total += b.totalInputPositions(bFromPos, bToPos);\n      });\n      return total;\n    }\n\n    /** Get block by name */\n    maskedBlock(name) {\n      return this.maskedBlocks(name)[0];\n    }\n\n    /** Get all blocks by name */\n    maskedBlocks(name) {\n      const indices = this._maskedBlocks[name];\n      if (!indices) return [];\n      return indices.map(gi => this._blocks[gi]);\n    }\n    pad(flags) {\n      const details = new ChangeDetails();\n      this._forEachBlocksInRange(0, this.displayValue.length, b => details.aggregate(b.pad(flags)));\n      return details;\n    }\n  }\n  MaskedPattern.DEFAULTS = {\n    ...Masked.DEFAULTS,\n    lazy: true,\n    placeholderChar: '_'\n  };\n  MaskedPattern.STOP_CHAR = '`';\n  MaskedPattern.ESCAPE_CHAR = '\\\\';\n  MaskedPattern.InputDefinition = PatternInputDefinition;\n  MaskedPattern.FixedDefinition = PatternFixedDefinition;\n  IMask.MaskedPattern = MaskedPattern;\n\n  /** Pattern which accepts ranges */\n  class MaskedRange extends MaskedPattern {\n    /**\r\n     Optionally sets max length of pattern.\r\n     Used when pattern length is longer then `to` param length. Pads zeros at start in this case.\r\n     */\n\n    /** Min bound */\n\n    /** Max bound */\n\n    get _matchFrom() {\n      return this.maxLength - String(this.from).length;\n    }\n    constructor(opts) {\n      super(opts); // mask will be created in _update\n    }\n    updateOptions(opts) {\n      super.updateOptions(opts);\n    }\n    _update(opts) {\n      const {\n        to = this.to || 0,\n        from = this.from || 0,\n        maxLength = this.maxLength || 0,\n        autofix = this.autofix,\n        ...patternOpts\n      } = opts;\n      this.to = to;\n      this.from = from;\n      this.maxLength = Math.max(String(to).length, maxLength);\n      this.autofix = autofix;\n      const fromStr = String(this.from).padStart(this.maxLength, '0');\n      const toStr = String(this.to).padStart(this.maxLength, '0');\n      let sameCharsCount = 0;\n      while (sameCharsCount < toStr.length && toStr[sameCharsCount] === fromStr[sameCharsCount]) ++sameCharsCount;\n      patternOpts.mask = toStr.slice(0, sameCharsCount).replace(/0/g, '\\\\0') + '0'.repeat(this.maxLength - sameCharsCount);\n      super._update(patternOpts);\n    }\n    get isComplete() {\n      return super.isComplete && Boolean(this.value);\n    }\n    boundaries(str) {\n      let minstr = '';\n      let maxstr = '';\n      const [, placeholder, num] = str.match(/^(\\D*)(\\d*)(\\D*)/) || [];\n      if (num) {\n        minstr = '0'.repeat(placeholder.length) + num;\n        maxstr = '9'.repeat(placeholder.length) + num;\n      }\n      minstr = minstr.padEnd(this.maxLength, '0');\n      maxstr = maxstr.padEnd(this.maxLength, '9');\n      return [minstr, maxstr];\n    }\n    doPrepareChar(ch, flags) {\n      if (flags === void 0) {\n        flags = {};\n      }\n      let details;\n      [ch, details] = super.doPrepareChar(ch.replace(/\\D/g, ''), flags);\n      if (!ch) details.skip = !this.isComplete;\n      return [ch, details];\n    }\n    _appendCharRaw(ch, flags) {\n      if (flags === void 0) {\n        flags = {};\n      }\n      if (!this.autofix || this.value.length + 1 > this.maxLength) return super._appendCharRaw(ch, flags);\n      const fromStr = String(this.from).padStart(this.maxLength, '0');\n      const toStr = String(this.to).padStart(this.maxLength, '0');\n      const [minstr, maxstr] = this.boundaries(this.value + ch);\n      if (Number(maxstr) < this.from) return super._appendCharRaw(fromStr[this.value.length], flags);\n      if (Number(minstr) > this.to) {\n        if (!flags.tail && this.autofix === 'pad' && this.value.length + 1 < this.maxLength) {\n          return super._appendCharRaw(fromStr[this.value.length], flags).aggregate(this._appendCharRaw(ch, flags));\n        }\n        return super._appendCharRaw(toStr[this.value.length], flags);\n      }\n      return super._appendCharRaw(ch, flags);\n    }\n    doValidate(flags) {\n      const str = this.value;\n      const firstNonZero = str.search(/[^0]/);\n      if (firstNonZero === -1 && str.length <= this._matchFrom) return true;\n      const [minstr, maxstr] = this.boundaries(str);\n      return this.from <= Number(maxstr) && Number(minstr) <= this.to && super.doValidate(flags);\n    }\n    pad(flags) {\n      const details = new ChangeDetails();\n      if (this.value.length === this.maxLength) return details;\n      const value = this.value;\n      const padLength = this.maxLength - this.value.length;\n      if (padLength) {\n        this.reset();\n        for (let i = 0; i < padLength; ++i) {\n          details.aggregate(super._appendCharRaw('0', flags));\n        }\n\n        // append tail\n        value.split('').forEach(ch => this._appendCharRaw(ch));\n      }\n      return details;\n    }\n  }\n  IMask.MaskedRange = MaskedRange;\n\n  /** Date mask */\n  class MaskedDate extends MaskedPattern {\n    static extractPatternOptions(opts) {\n      const {\n        mask,\n        pattern,\n        ...patternOpts\n      } = opts;\n      return {\n        ...patternOpts,\n        mask: isString(mask) ? mask : pattern\n      };\n    }\n\n    /** Pattern mask for date according to {@link MaskedDate#format} */\n\n    /** Start date */\n\n    /** End date */\n\n    /** Format typed value to string */\n\n    /** Parse string to get typed value */\n\n    constructor(opts) {\n      super(MaskedDate.extractPatternOptions({\n        ...MaskedDate.DEFAULTS,\n        ...opts\n      }));\n    }\n    updateOptions(opts) {\n      super.updateOptions(opts);\n    }\n    _update(opts) {\n      const {\n        mask,\n        pattern,\n        blocks,\n        ...patternOpts\n      } = {\n        ...MaskedDate.DEFAULTS,\n        ...opts\n      };\n      const patternBlocks = Object.assign({}, MaskedDate.GET_DEFAULT_BLOCKS());\n      // adjust year block\n      if (opts.min) patternBlocks.Y.from = opts.min.getFullYear();\n      if (opts.max) patternBlocks.Y.to = opts.max.getFullYear();\n      if (opts.min && opts.max && patternBlocks.Y.from === patternBlocks.Y.to) {\n        patternBlocks.m.from = opts.min.getMonth() + 1;\n        patternBlocks.m.to = opts.max.getMonth() + 1;\n        if (patternBlocks.m.from === patternBlocks.m.to) {\n          patternBlocks.d.from = opts.min.getDate();\n          patternBlocks.d.to = opts.max.getDate();\n        }\n      }\n      Object.assign(patternBlocks, this.blocks, blocks);\n      super._update({\n        ...patternOpts,\n        mask: isString(mask) ? mask : pattern,\n        blocks: patternBlocks\n      });\n    }\n    doValidate(flags) {\n      const date = this.date;\n      return super.doValidate(flags) && (!this.isComplete || this.isDateExist(this.value) && date != null && (this.min == null || this.min <= date) && (this.max == null || date <= this.max));\n    }\n\n    /** Checks if date is exists */\n    isDateExist(str) {\n      return this.format(this.parse(str, this), this).indexOf(str) >= 0;\n    }\n\n    /** Parsed Date */\n    get date() {\n      return this.typedValue;\n    }\n    set date(date) {\n      this.typedValue = date;\n    }\n    get typedValue() {\n      return this.isComplete ? super.typedValue : null;\n    }\n    set typedValue(value) {\n      super.typedValue = value;\n    }\n    maskEquals(mask) {\n      return mask === Date || super.maskEquals(mask);\n    }\n    optionsIsChanged(opts) {\n      return super.optionsIsChanged(MaskedDate.extractPatternOptions(opts));\n    }\n  }\n  MaskedDate.GET_DEFAULT_BLOCKS = () => ({\n    d: {\n      mask: MaskedRange,\n      from: 1,\n      to: 31,\n      maxLength: 2\n    },\n    m: {\n      mask: MaskedRange,\n      from: 1,\n      to: 12,\n      maxLength: 2\n    },\n    Y: {\n      mask: MaskedRange,\n      from: 1900,\n      to: 9999\n    }\n  });\n  MaskedDate.DEFAULTS = {\n    ...MaskedPattern.DEFAULTS,\n    mask: Date,\n    pattern: 'd{.}`m{.}`Y',\n    format: (date, masked) => {\n      if (!date) return '';\n      const day = String(date.getDate()).padStart(2, '0');\n      const month = String(date.getMonth() + 1).padStart(2, '0');\n      const year = date.getFullYear();\n      return [day, month, year].join('.');\n    },\n    parse: (str, masked) => {\n      const [day, month, year] = str.split('.').map(Number);\n      return new Date(year, month - 1, day);\n    }\n  };\n  IMask.MaskedDate = MaskedDate;\n\n  /** Dynamic mask for choosing appropriate mask in run-time */\n  class MaskedDynamic extends Masked {\n    constructor(opts) {\n      super({\n        ...MaskedDynamic.DEFAULTS,\n        ...opts\n      });\n      this.currentMask = undefined;\n    }\n    updateOptions(opts) {\n      super.updateOptions(opts);\n    }\n    _update(opts) {\n      super._update(opts);\n      if ('mask' in opts) {\n        this.exposeMask = undefined;\n        // mask could be totally dynamic with only `dispatch` option\n        this.compiledMasks = Array.isArray(opts.mask) ? opts.mask.map(m => {\n          const {\n            expose,\n            ...maskOpts\n          } = normalizeOpts(m);\n          const masked = createMask({\n            overwrite: this._overwrite,\n            eager: this._eager,\n            skipInvalid: this._skipInvalid,\n            ...maskOpts\n          });\n          if (expose) this.exposeMask = masked;\n          return masked;\n        }) : [];\n\n        // this.currentMask = this.doDispatch(''); // probably not needed but lets see\n      }\n    }\n    _appendCharRaw(ch, flags) {\n      if (flags === void 0) {\n        flags = {};\n      }\n      const details = this._applyDispatch(ch, flags);\n      if (this.currentMask) {\n        details.aggregate(this.currentMask._appendChar(ch, this.currentMaskFlags(flags)));\n      }\n      return details;\n    }\n    _applyDispatch(appended, flags, tail) {\n      if (appended === void 0) {\n        appended = '';\n      }\n      if (flags === void 0) {\n        flags = {};\n      }\n      if (tail === void 0) {\n        tail = '';\n      }\n      const prevValueBeforeTail = flags.tail && flags._beforeTailState != null ? flags._beforeTailState._value : this.value;\n      const inputValue = this.rawInputValue;\n      const insertValue = flags.tail && flags._beforeTailState != null ? flags._beforeTailState._rawInputValue : inputValue;\n      const tailValue = inputValue.slice(insertValue.length);\n      const prevMask = this.currentMask;\n      const details = new ChangeDetails();\n      const prevMaskState = prevMask == null ? void 0 : prevMask.state;\n\n      // clone flags to prevent overwriting `_beforeTailState`\n      this.currentMask = this.doDispatch(appended, {\n        ...flags\n      }, tail);\n\n      // restore state after dispatch\n      if (this.currentMask) {\n        if (this.currentMask !== prevMask) {\n          // if mask changed reapply input\n          this.currentMask.reset();\n          if (insertValue) {\n            this.currentMask.append(insertValue, {\n              raw: true\n            });\n            details.tailShift = this.currentMask.value.length - prevValueBeforeTail.length;\n          }\n          if (tailValue) {\n            details.tailShift += this.currentMask.append(tailValue, {\n              raw: true,\n              tail: true\n            }).tailShift;\n          }\n        } else if (prevMaskState) {\n          // Dispatch can do something bad with state, so\n          // restore prev mask state\n          this.currentMask.state = prevMaskState;\n        }\n      }\n      return details;\n    }\n    _appendPlaceholder() {\n      const details = this._applyDispatch();\n      if (this.currentMask) {\n        details.aggregate(this.currentMask._appendPlaceholder());\n      }\n      return details;\n    }\n    _appendEager() {\n      const details = this._applyDispatch();\n      if (this.currentMask) {\n        details.aggregate(this.currentMask._appendEager());\n      }\n      return details;\n    }\n    appendTail(tail) {\n      const details = new ChangeDetails();\n      if (tail) details.aggregate(this._applyDispatch('', {}, tail));\n      return details.aggregate(this.currentMask ? this.currentMask.appendTail(tail) : super.appendTail(tail));\n    }\n    currentMaskFlags(flags) {\n      var _flags$_beforeTailSta, _flags$_beforeTailSta2;\n      return {\n        ...flags,\n        _beforeTailState: ((_flags$_beforeTailSta = flags._beforeTailState) == null ? void 0 : _flags$_beforeTailSta.currentMaskRef) === this.currentMask && ((_flags$_beforeTailSta2 = flags._beforeTailState) == null ? void 0 : _flags$_beforeTailSta2.currentMask) || flags._beforeTailState\n      };\n    }\n    doDispatch(appended, flags, tail) {\n      if (flags === void 0) {\n        flags = {};\n      }\n      if (tail === void 0) {\n        tail = '';\n      }\n      return this.dispatch(appended, this, flags, tail);\n    }\n    doValidate(flags) {\n      return super.doValidate(flags) && (!this.currentMask || this.currentMask.doValidate(this.currentMaskFlags(flags)));\n    }\n    doPrepare(str, flags) {\n      if (flags === void 0) {\n        flags = {};\n      }\n      let [s, details] = super.doPrepare(str, flags);\n      if (this.currentMask) {\n        let currentDetails;\n        [s, currentDetails] = super.doPrepare(s, this.currentMaskFlags(flags));\n        details = details.aggregate(currentDetails);\n      }\n      return [s, details];\n    }\n    doPrepareChar(str, flags) {\n      if (flags === void 0) {\n        flags = {};\n      }\n      let [s, details] = super.doPrepareChar(str, flags);\n      if (this.currentMask) {\n        let currentDetails;\n        [s, currentDetails] = super.doPrepareChar(s, this.currentMaskFlags(flags));\n        details = details.aggregate(currentDetails);\n      }\n      return [s, details];\n    }\n    reset() {\n      var _this$currentMask;\n      (_this$currentMask = this.currentMask) == null || _this$currentMask.reset();\n      this.compiledMasks.forEach(m => m.reset());\n    }\n    get value() {\n      return this.exposeMask ? this.exposeMask.value : this.currentMask ? this.currentMask.value : '';\n    }\n    set value(value) {\n      if (this.exposeMask) {\n        this.exposeMask.value = value;\n        this.currentMask = this.exposeMask;\n        this._applyDispatch();\n      } else super.value = value;\n    }\n    get unmaskedValue() {\n      return this.exposeMask ? this.exposeMask.unmaskedValue : this.currentMask ? this.currentMask.unmaskedValue : '';\n    }\n    set unmaskedValue(unmaskedValue) {\n      if (this.exposeMask) {\n        this.exposeMask.unmaskedValue = unmaskedValue;\n        this.currentMask = this.exposeMask;\n        this._applyDispatch();\n      } else super.unmaskedValue = unmaskedValue;\n    }\n    get typedValue() {\n      return this.exposeMask ? this.exposeMask.typedValue : this.currentMask ? this.currentMask.typedValue : '';\n    }\n    set typedValue(typedValue) {\n      if (this.exposeMask) {\n        this.exposeMask.typedValue = typedValue;\n        this.currentMask = this.exposeMask;\n        this._applyDispatch();\n        return;\n      }\n      let unmaskedValue = String(typedValue);\n\n      // double check it\n      if (this.currentMask) {\n        this.currentMask.typedValue = typedValue;\n        unmaskedValue = this.currentMask.unmaskedValue;\n      }\n      this.unmaskedValue = unmaskedValue;\n    }\n    get displayValue() {\n      return this.currentMask ? this.currentMask.displayValue : '';\n    }\n    get isComplete() {\n      var _this$currentMask2;\n      return Boolean((_this$currentMask2 = this.currentMask) == null ? void 0 : _this$currentMask2.isComplete);\n    }\n    get isFilled() {\n      var _this$currentMask3;\n      return Boolean((_this$currentMask3 = this.currentMask) == null ? void 0 : _this$currentMask3.isFilled);\n    }\n    remove(fromPos, toPos) {\n      const details = new ChangeDetails();\n      if (this.currentMask) {\n        details.aggregate(this.currentMask.remove(fromPos, toPos))\n        // update with dispatch\n        .aggregate(this._applyDispatch());\n      }\n      return details;\n    }\n    get state() {\n      var _this$currentMask4;\n      return {\n        ...super.state,\n        _rawInputValue: this.rawInputValue,\n        compiledMasks: this.compiledMasks.map(m => m.state),\n        currentMaskRef: this.currentMask,\n        currentMask: (_this$currentMask4 = this.currentMask) == null ? void 0 : _this$currentMask4.state\n      };\n    }\n    set state(state) {\n      const {\n        compiledMasks,\n        currentMaskRef,\n        currentMask,\n        ...maskedState\n      } = state;\n      if (compiledMasks) this.compiledMasks.forEach((m, mi) => m.state = compiledMasks[mi]);\n      if (currentMaskRef != null) {\n        this.currentMask = currentMaskRef;\n        this.currentMask.state = currentMask;\n      }\n      super.state = maskedState;\n    }\n    extractInput(fromPos, toPos, flags) {\n      return this.currentMask ? this.currentMask.extractInput(fromPos, toPos, flags) : '';\n    }\n    extractTail(fromPos, toPos) {\n      return this.currentMask ? this.currentMask.extractTail(fromPos, toPos) : super.extractTail(fromPos, toPos);\n    }\n    doCommit() {\n      if (this.currentMask) this.currentMask.doCommit();\n      super.doCommit();\n    }\n    nearestInputPos(cursorPos, direction) {\n      return this.currentMask ? this.currentMask.nearestInputPos(cursorPos, direction) : super.nearestInputPos(cursorPos, direction);\n    }\n    get overwrite() {\n      return this.currentMask ? this.currentMask.overwrite : this._overwrite;\n    }\n    set overwrite(overwrite) {\n      this._overwrite = overwrite;\n    }\n    get eager() {\n      return this.currentMask ? this.currentMask.eager : this._eager;\n    }\n    set eager(eager) {\n      this._eager = eager;\n    }\n    get skipInvalid() {\n      return this.currentMask ? this.currentMask.skipInvalid : this._skipInvalid;\n    }\n    set skipInvalid(skipInvalid) {\n      this._skipInvalid = skipInvalid;\n    }\n    get autofix() {\n      return this.currentMask ? this.currentMask.autofix : this._autofix;\n    }\n    set autofix(autofix) {\n      this._autofix = autofix;\n    }\n    maskEquals(mask) {\n      return Array.isArray(mask) ? this.compiledMasks.every((m, mi) => {\n        if (!mask[mi]) return;\n        const {\n          mask: oldMask,\n          ...restOpts\n        } = mask[mi];\n        return objectIncludes(m, restOpts) && m.maskEquals(oldMask);\n      }) : super.maskEquals(mask);\n    }\n    typedValueEquals(value) {\n      var _this$currentMask5;\n      return Boolean((_this$currentMask5 = this.currentMask) == null ? void 0 : _this$currentMask5.typedValueEquals(value));\n    }\n  }\n  /** Currently chosen mask */\n  /** Currently chosen mask */\n  /** Compliled {@link Masked} options */\n  /** Chooses {@link Masked} depending on input value */\n  MaskedDynamic.DEFAULTS = {\n    ...Masked.DEFAULTS,\n    dispatch: (appended, masked, flags, tail) => {\n      if (!masked.compiledMasks.length) return;\n      const inputValue = masked.rawInputValue;\n\n      // simulate input\n      const inputs = masked.compiledMasks.map((m, index) => {\n        const isCurrent = masked.currentMask === m;\n        const startInputPos = isCurrent ? m.displayValue.length : m.nearestInputPos(m.displayValue.length, DIRECTION.FORCE_LEFT);\n        if (m.rawInputValue !== inputValue) {\n          m.reset();\n          m.append(inputValue, {\n            raw: true\n          });\n        } else if (!isCurrent) {\n          m.remove(startInputPos);\n        }\n        m.append(appended, masked.currentMaskFlags(flags));\n        m.appendTail(tail);\n        return {\n          index,\n          weight: m.rawInputValue.length,\n          totalInputPositions: m.totalInputPositions(0, Math.max(startInputPos, m.nearestInputPos(m.displayValue.length, DIRECTION.FORCE_LEFT)))\n        };\n      });\n\n      // pop masks with longer values first\n      inputs.sort((i1, i2) => i2.weight - i1.weight || i2.totalInputPositions - i1.totalInputPositions);\n      return masked.compiledMasks[inputs[0].index];\n    }\n  };\n  IMask.MaskedDynamic = MaskedDynamic;\n\n  /** Pattern which validates enum values */\n  class MaskedEnum extends MaskedPattern {\n    constructor(opts) {\n      super({\n        ...MaskedEnum.DEFAULTS,\n        ...opts\n      }); // mask will be created in _update\n    }\n    updateOptions(opts) {\n      super.updateOptions(opts);\n    }\n    _update(opts) {\n      const {\n        enum: enum_,\n        ...eopts\n      } = opts;\n      if (enum_) {\n        const lengths = enum_.map(e => e.length);\n        const requiredLength = Math.min(...lengths);\n        const optionalLength = Math.max(...lengths) - requiredLength;\n        eopts.mask = '*'.repeat(requiredLength);\n        if (optionalLength) eopts.mask += '[' + '*'.repeat(optionalLength) + ']';\n        this.enum = enum_;\n      }\n      super._update(eopts);\n    }\n    _appendCharRaw(ch, flags) {\n      if (flags === void 0) {\n        flags = {};\n      }\n      const matchFrom = Math.min(this.nearestInputPos(0, DIRECTION.FORCE_RIGHT), this.value.length);\n      const matches = this.enum.filter(e => this.matchValue(e, this.unmaskedValue + ch, matchFrom));\n      if (matches.length) {\n        if (matches.length === 1) {\n          this._forEachBlocksInRange(0, this.value.length, (b, bi) => {\n            const mch = matches[0][bi];\n            if (bi >= this.value.length || mch === b.value) return;\n            b.reset();\n            b._appendChar(mch, flags);\n          });\n        }\n        const d = super._appendCharRaw(matches[0][this.value.length], flags);\n        if (matches.length === 1) {\n          matches[0].slice(this.unmaskedValue.length).split('').forEach(mch => d.aggregate(super._appendCharRaw(mch)));\n        }\n        return d;\n      }\n      return new ChangeDetails();\n    }\n    extractTail(fromPos, toPos) {\n      if (fromPos === void 0) {\n        fromPos = 0;\n      }\n      if (toPos === void 0) {\n        toPos = this.displayValue.length;\n      }\n      // just drop tail\n      return new ContinuousTailDetails('', fromPos);\n    }\n    remove(fromPos, toPos) {\n      if (fromPos === void 0) {\n        fromPos = 0;\n      }\n      if (toPos === void 0) {\n        toPos = this.displayValue.length;\n      }\n      if (fromPos === toPos) return new ChangeDetails();\n      const matchFrom = Math.min(super.nearestInputPos(0, DIRECTION.FORCE_RIGHT), this.value.length);\n      let pos;\n      for (pos = fromPos; pos >= 0; --pos) {\n        const matches = this.enum.filter(e => this.matchValue(e, this.value.slice(matchFrom, pos), matchFrom));\n        if (matches.length > 1) break;\n      }\n      const details = super.remove(pos, toPos);\n      details.tailShift += pos - fromPos;\n      return details;\n    }\n  }\n  /** Match enum value */\n  MaskedEnum.DEFAULTS = {\n    ...MaskedPattern.DEFAULTS,\n    matchValue: (estr, istr, matchFrom) => estr.indexOf(istr, matchFrom) === matchFrom\n  };\n  IMask.MaskedEnum = MaskedEnum;\n\n  /** Masking by custom Function */\n  class MaskedFunction extends Masked {\n    /** */\n\n    /** Enable characters overwriting */\n\n    /** */\n\n    /** */\n\n    /** */\n\n    updateOptions(opts) {\n      super.updateOptions(opts);\n    }\n    _update(opts) {\n      super._update({\n        ...opts,\n        validate: opts.mask\n      });\n    }\n  }\n  IMask.MaskedFunction = MaskedFunction;\n  var _MaskedNumber;\n  /** Number mask */\n  class MaskedNumber extends Masked {\n    /** Single char */\n\n    /** Single char */\n\n    /** Array of single chars */\n\n    /** */\n\n    /** */\n\n    /** Digits after point */\n\n    /** Flag to remove leading and trailing zeros in the end of editing */\n\n    /** Flag to pad trailing zeros after point in the end of editing */\n\n    /** Enable characters overwriting */\n\n    /** */\n\n    /** */\n\n    /** */\n\n    /** Format typed value to string */\n\n    /** Parse string to get typed value */\n\n    constructor(opts) {\n      super({\n        ...MaskedNumber.DEFAULTS,\n        ...opts\n      });\n    }\n    updateOptions(opts) {\n      super.updateOptions(opts);\n    }\n    _update(opts) {\n      super._update(opts);\n      this._updateRegExps();\n    }\n    _updateRegExps() {\n      const start = '^' + (this.allowNegative ? '[+|\\\\-]?' : '');\n      const mid = '\\\\d*';\n      const end = (this.scale ? \"(\" + escapeRegExp(this.radix) + \"\\\\d{0,\" + this.scale + \"})?\" : '') + '$';\n      this._numberRegExp = new RegExp(start + mid + end);\n      this._mapToRadixRegExp = new RegExp(\"[\" + this.mapToRadix.map(escapeRegExp).join('') + \"]\", 'g');\n      this._thousandsSeparatorRegExp = new RegExp(escapeRegExp(this.thousandsSeparator), 'g');\n    }\n    _removeThousandsSeparators(value) {\n      return value.replace(this._thousandsSeparatorRegExp, '');\n    }\n    _insertThousandsSeparators(value) {\n      // https://stackoverflow.com/questions/2901102/how-to-print-a-number-with-commas-as-thousands-separators-in-javascript\n      const parts = value.split(this.radix);\n      parts[0] = parts[0].replace(/\\B(?=(\\d{3})+(?!\\d))/g, this.thousandsSeparator);\n      return parts.join(this.radix);\n    }\n    doPrepareChar(ch, flags) {\n      if (flags === void 0) {\n        flags = {};\n      }\n      const [prepCh, details] = super.doPrepareChar(this._removeThousandsSeparators(this.scale && this.mapToRadix.length && (\n      /*\r\n      radix should be mapped when\r\n      1) input is done from keyboard = flags.input && flags.raw\r\n      2) unmasked value is set = !flags.input && !flags.raw\r\n      and should not be mapped when\r\n      1) value is set = flags.input && !flags.raw\r\n      2) raw value is set = !flags.input && flags.raw\r\n      */\n      flags.input && flags.raw || !flags.input && !flags.raw) ? ch.replace(this._mapToRadixRegExp, this.radix) : ch), flags);\n      if (ch && !prepCh) details.skip = true;\n      if (prepCh && !this.allowPositive && !this.value && prepCh !== '-') details.aggregate(this._appendChar('-'));\n      return [prepCh, details];\n    }\n    _separatorsCount(to, extendOnSeparators) {\n      if (extendOnSeparators === void 0) {\n        extendOnSeparators = false;\n      }\n      let count = 0;\n      for (let pos = 0; pos < to; ++pos) {\n        if (this._value.indexOf(this.thousandsSeparator, pos) === pos) {\n          ++count;\n          if (extendOnSeparators) to += this.thousandsSeparator.length;\n        }\n      }\n      return count;\n    }\n    _separatorsCountFromSlice(slice) {\n      if (slice === void 0) {\n        slice = this._value;\n      }\n      return this._separatorsCount(this._removeThousandsSeparators(slice).length, true);\n    }\n    extractInput(fromPos, toPos, flags) {\n      if (fromPos === void 0) {\n        fromPos = 0;\n      }\n      if (toPos === void 0) {\n        toPos = this.displayValue.length;\n      }\n      [fromPos, toPos] = this._adjustRangeWithSeparators(fromPos, toPos);\n      return this._removeThousandsSeparators(super.extractInput(fromPos, toPos, flags));\n    }\n    _appendCharRaw(ch, flags) {\n      if (flags === void 0) {\n        flags = {};\n      }\n      const prevBeforeTailValue = flags.tail && flags._beforeTailState ? flags._beforeTailState._value : this._value;\n      const prevBeforeTailSeparatorsCount = this._separatorsCountFromSlice(prevBeforeTailValue);\n      this._value = this._removeThousandsSeparators(this.value);\n      const oldValue = this._value;\n      this._value += ch;\n      const num = this.number;\n      let accepted = !isNaN(num);\n      let skip = false;\n      if (accepted) {\n        let fixedNum;\n        if (this.min != null && this.min < 0 && this.number < this.min) fixedNum = this.min;\n        if (this.max != null && this.max > 0 && this.number > this.max) fixedNum = this.max;\n        if (fixedNum != null) {\n          if (this.autofix) {\n            this._value = this.format(fixedNum, this).replace(MaskedNumber.UNMASKED_RADIX, this.radix);\n            skip || (skip = oldValue === this._value && !flags.tail); // if not changed on tail it's still ok to proceed\n          } else {\n            accepted = false;\n          }\n        }\n        accepted && (accepted = Boolean(this._value.match(this._numberRegExp)));\n      }\n      let appendDetails;\n      if (!accepted) {\n        this._value = oldValue;\n        appendDetails = new ChangeDetails();\n      } else {\n        appendDetails = new ChangeDetails({\n          inserted: this._value.slice(oldValue.length),\n          rawInserted: skip ? '' : ch,\n          skip\n        });\n      }\n      this._value = this._insertThousandsSeparators(this._value);\n      const beforeTailValue = flags.tail && flags._beforeTailState ? flags._beforeTailState._value : this._value;\n      const beforeTailSeparatorsCount = this._separatorsCountFromSlice(beforeTailValue);\n      appendDetails.tailShift += (beforeTailSeparatorsCount - prevBeforeTailSeparatorsCount) * this.thousandsSeparator.length;\n      return appendDetails;\n    }\n    _findSeparatorAround(pos) {\n      if (this.thousandsSeparator) {\n        const searchFrom = pos - this.thousandsSeparator.length + 1;\n        const separatorPos = this.value.indexOf(this.thousandsSeparator, searchFrom);\n        if (separatorPos <= pos) return separatorPos;\n      }\n      return -1;\n    }\n    _adjustRangeWithSeparators(from, to) {\n      const separatorAroundFromPos = this._findSeparatorAround(from);\n      if (separatorAroundFromPos >= 0) from = separatorAroundFromPos;\n      const separatorAroundToPos = this._findSeparatorAround(to);\n      if (separatorAroundToPos >= 0) to = separatorAroundToPos + this.thousandsSeparator.length;\n      return [from, to];\n    }\n    remove(fromPos, toPos) {\n      if (fromPos === void 0) {\n        fromPos = 0;\n      }\n      if (toPos === void 0) {\n        toPos = this.displayValue.length;\n      }\n      [fromPos, toPos] = this._adjustRangeWithSeparators(fromPos, toPos);\n      const valueBeforePos = this.value.slice(0, fromPos);\n      const valueAfterPos = this.value.slice(toPos);\n      const prevBeforeTailSeparatorsCount = this._separatorsCount(valueBeforePos.length);\n      this._value = this._insertThousandsSeparators(this._removeThousandsSeparators(valueBeforePos + valueAfterPos));\n      const beforeTailSeparatorsCount = this._separatorsCountFromSlice(valueBeforePos);\n      return new ChangeDetails({\n        tailShift: (beforeTailSeparatorsCount - prevBeforeTailSeparatorsCount) * this.thousandsSeparator.length\n      });\n    }\n    nearestInputPos(cursorPos, direction) {\n      if (!this.thousandsSeparator) return cursorPos;\n      switch (direction) {\n        case DIRECTION.NONE:\n        case DIRECTION.LEFT:\n        case DIRECTION.FORCE_LEFT:\n          {\n            const separatorAtLeftPos = this._findSeparatorAround(cursorPos - 1);\n            if (separatorAtLeftPos >= 0) {\n              const separatorAtLeftEndPos = separatorAtLeftPos + this.thousandsSeparator.length;\n              if (cursorPos < separatorAtLeftEndPos || this.value.length <= separatorAtLeftEndPos || direction === DIRECTION.FORCE_LEFT) {\n                return separatorAtLeftPos;\n              }\n            }\n            break;\n          }\n        case DIRECTION.RIGHT:\n        case DIRECTION.FORCE_RIGHT:\n          {\n            const separatorAtRightPos = this._findSeparatorAround(cursorPos);\n            if (separatorAtRightPos >= 0) {\n              return separatorAtRightPos + this.thousandsSeparator.length;\n            }\n          }\n      }\n      return cursorPos;\n    }\n    doCommit() {\n      if (this.value) {\n        const number = this.number;\n        let validnum = number;\n\n        // check bounds\n        if (this.min != null) validnum = Math.max(validnum, this.min);\n        if (this.max != null) validnum = Math.min(validnum, this.max);\n        if (validnum !== number) this.unmaskedValue = this.format(validnum, this);\n        let formatted = this.value;\n        if (this.normalizeZeros) formatted = this._normalizeZeros(formatted);\n        if (this.padFractionalZeros && this.scale > 0) formatted = this._padFractionalZeros(formatted);\n        this._value = formatted;\n      }\n      super.doCommit();\n    }\n    _normalizeZeros(value) {\n      const parts = this._removeThousandsSeparators(value).split(this.radix);\n\n      // remove leading zeros\n      parts[0] = parts[0].replace(/^(\\D*)(0*)(\\d*)/, (match, sign, zeros, num) => sign + num);\n      // add leading zero\n      if (value.length && !/\\d$/.test(parts[0])) parts[0] = parts[0] + '0';\n      if (parts.length > 1) {\n        parts[1] = parts[1].replace(/0*$/, ''); // remove trailing zeros\n        if (!parts[1].length) parts.length = 1; // remove fractional\n      }\n      return this._insertThousandsSeparators(parts.join(this.radix));\n    }\n    _padFractionalZeros(value) {\n      if (!value) return value;\n      const parts = value.split(this.radix);\n      if (parts.length < 2) parts.push('');\n      parts[1] = parts[1].padEnd(this.scale, '0');\n      return parts.join(this.radix);\n    }\n    doSkipInvalid(ch, flags, checkTail) {\n      if (flags === void 0) {\n        flags = {};\n      }\n      const dropFractional = this.scale === 0 && ch !== this.thousandsSeparator && (ch === this.radix || ch === MaskedNumber.UNMASKED_RADIX || this.mapToRadix.includes(ch));\n      return super.doSkipInvalid(ch, flags, checkTail) && !dropFractional;\n    }\n    get unmaskedValue() {\n      return this._removeThousandsSeparators(this._normalizeZeros(this.value)).replace(this.radix, MaskedNumber.UNMASKED_RADIX);\n    }\n    set unmaskedValue(unmaskedValue) {\n      super.unmaskedValue = unmaskedValue;\n    }\n    get typedValue() {\n      return this.parse(this.unmaskedValue, this);\n    }\n    set typedValue(n) {\n      this.rawInputValue = this.format(n, this).replace(MaskedNumber.UNMASKED_RADIX, this.radix);\n    }\n\n    /** Parsed Number */\n    get number() {\n      return this.typedValue;\n    }\n    set number(number) {\n      this.typedValue = number;\n    }\n    get allowNegative() {\n      return this.min != null && this.min < 0 || this.max != null && this.max < 0;\n    }\n    get allowPositive() {\n      return this.min != null && this.min > 0 || this.max != null && this.max > 0;\n    }\n    typedValueEquals(value) {\n      // handle  0 -> '' case (typed = 0 even if value = '')\n      // for details see https://github.com/uNmAnNeR/imaskjs/issues/134\n      return (super.typedValueEquals(value) || MaskedNumber.EMPTY_VALUES.includes(value) && MaskedNumber.EMPTY_VALUES.includes(this.typedValue)) && !(value === 0 && this.value === '');\n    }\n  }\n  _MaskedNumber = MaskedNumber;\n  MaskedNumber.UNMASKED_RADIX = '.';\n  MaskedNumber.EMPTY_VALUES = [...Masked.EMPTY_VALUES, 0];\n  MaskedNumber.DEFAULTS = {\n    ...Masked.DEFAULTS,\n    mask: Number,\n    radix: ',',\n    thousandsSeparator: '',\n    mapToRadix: [_MaskedNumber.UNMASKED_RADIX],\n    min: Number.MIN_SAFE_INTEGER,\n    max: Number.MAX_SAFE_INTEGER,\n    scale: 2,\n    normalizeZeros: true,\n    padFractionalZeros: false,\n    parse: Number,\n    format: n => n.toLocaleString('en-US', {\n      useGrouping: false,\n      maximumFractionDigits: 20\n    })\n  };\n  IMask.MaskedNumber = MaskedNumber;\n\n  /** Mask pipe source and destination types */\n  const PIPE_TYPE = {\n    MASKED: 'value',\n    UNMASKED: 'unmaskedValue',\n    TYPED: 'typedValue'\n  };\n  /** Creates new pipe function depending on mask type, source and destination options */\n  function createPipe(arg, from, to) {\n    if (from === void 0) {\n      from = PIPE_TYPE.MASKED;\n    }\n    if (to === void 0) {\n      to = PIPE_TYPE.MASKED;\n    }\n    const masked = createMask(arg);\n    return value => masked.runIsolated(m => {\n      m[from] = value;\n      return m[to];\n    });\n  }\n\n  /** Pipes value through mask depending on mask type, source and destination options */\n  function pipe(value, mask, from, to) {\n    return createPipe(mask, from, to)(value);\n  }\n  IMask.PIPE_TYPE = PIPE_TYPE;\n  IMask.createPipe = createPipe;\n  IMask.pipe = pipe;\n\n  /** Pattern mask */\n  class RepeatBlock extends MaskedPattern {\n    get repeatFrom() {\n      var _ref;\n      return (_ref = Array.isArray(this.repeat) ? this.repeat[0] : this.repeat === Infinity ? 0 : this.repeat) != null ? _ref : 0;\n    }\n    get repeatTo() {\n      var _ref2;\n      return (_ref2 = Array.isArray(this.repeat) ? this.repeat[1] : this.repeat) != null ? _ref2 : Infinity;\n    }\n    constructor(opts) {\n      super(opts);\n    }\n    updateOptions(opts) {\n      super.updateOptions(opts);\n    }\n    _update(opts) {\n      var _ref3, _ref4, _this$_blocks;\n      const {\n        repeat,\n        ...blockOpts\n      } = normalizeOpts(opts); // TODO type\n      this._blockOpts = Object.assign({}, this._blockOpts, blockOpts);\n      const block = createMask(this._blockOpts);\n      this.repeat = (_ref3 = (_ref4 = repeat != null ? repeat : block.repeat) != null ? _ref4 : this.repeat) != null ? _ref3 : Infinity; // TODO type\n\n      super._update({\n        mask: 'm'.repeat(Math.max(this.repeatTo === Infinity && ((_this$_blocks = this._blocks) == null ? void 0 : _this$_blocks.length) || 0, this.repeatFrom)),\n        blocks: {\n          m: block\n        },\n        eager: block.eager,\n        overwrite: block.overwrite,\n        skipInvalid: block.skipInvalid,\n        lazy: block.lazy,\n        placeholderChar: block.placeholderChar,\n        displayChar: block.displayChar\n      });\n    }\n    _allocateBlock(bi) {\n      if (bi < this._blocks.length) return this._blocks[bi];\n      if (this.repeatTo === Infinity || this._blocks.length < this.repeatTo) {\n        this._blocks.push(createMask(this._blockOpts));\n        this.mask += 'm';\n        return this._blocks[this._blocks.length - 1];\n      }\n    }\n    _appendCharRaw(ch, flags) {\n      if (flags === void 0) {\n        flags = {};\n      }\n      const details = new ChangeDetails();\n      for (let bi = (_this$_mapPosToBlock$ = (_this$_mapPosToBlock = this._mapPosToBlock(this.displayValue.length)) == null ? void 0 : _this$_mapPosToBlock.index) != null ? _this$_mapPosToBlock$ : Math.max(this._blocks.length - 1, 0), block, allocated;\n      // try to get a block or\n      // try to allocate a new block if not allocated already\n      block = (_this$_blocks$bi = this._blocks[bi]) != null ? _this$_blocks$bi : allocated = !allocated && this._allocateBlock(bi); ++bi) {\n        var _this$_mapPosToBlock$, _this$_mapPosToBlock, _this$_blocks$bi, _flags$_beforeTailSta;\n        const blockDetails = block._appendChar(ch, {\n          ...flags,\n          _beforeTailState: (_flags$_beforeTailSta = flags._beforeTailState) == null || (_flags$_beforeTailSta = _flags$_beforeTailSta._blocks) == null ? void 0 : _flags$_beforeTailSta[bi]\n        });\n        if (blockDetails.skip && allocated) {\n          // remove the last allocated block and break\n          this._blocks.pop();\n          this.mask = this.mask.slice(1);\n          break;\n        }\n        details.aggregate(blockDetails);\n        if (blockDetails.consumed) break; // go next char\n      }\n      return details;\n    }\n    _trimEmptyTail(fromPos, toPos) {\n      var _this$_mapPosToBlock2, _this$_mapPosToBlock3;\n      if (fromPos === void 0) {\n        fromPos = 0;\n      }\n      const firstBlockIndex = Math.max(((_this$_mapPosToBlock2 = this._mapPosToBlock(fromPos)) == null ? void 0 : _this$_mapPosToBlock2.index) || 0, this.repeatFrom, 0);\n      let lastBlockIndex;\n      if (toPos != null) lastBlockIndex = (_this$_mapPosToBlock3 = this._mapPosToBlock(toPos)) == null ? void 0 : _this$_mapPosToBlock3.index;\n      if (lastBlockIndex == null) lastBlockIndex = this._blocks.length - 1;\n      let removeCount = 0;\n      for (let blockIndex = lastBlockIndex; firstBlockIndex <= blockIndex; --blockIndex, ++removeCount) {\n        if (this._blocks[blockIndex].unmaskedValue) break;\n      }\n      if (removeCount) {\n        this._blocks.splice(lastBlockIndex - removeCount + 1, removeCount);\n        this.mask = this.mask.slice(removeCount);\n      }\n    }\n    reset() {\n      super.reset();\n      this._trimEmptyTail();\n    }\n    remove(fromPos, toPos) {\n      if (fromPos === void 0) {\n        fromPos = 0;\n      }\n      if (toPos === void 0) {\n        toPos = this.displayValue.length;\n      }\n      const removeDetails = super.remove(fromPos, toPos);\n      this._trimEmptyTail(fromPos, toPos);\n      return removeDetails;\n    }\n    totalInputPositions(fromPos, toPos) {\n      if (fromPos === void 0) {\n        fromPos = 0;\n      }\n      if (toPos == null && this.repeatTo === Infinity) return Infinity;\n      return super.totalInputPositions(fromPos, toPos);\n    }\n    get state() {\n      return super.state;\n    }\n    set state(state) {\n      this._blocks.length = state._blocks.length;\n      this.mask = this.mask.slice(0, this._blocks.length);\n      super.state = state;\n    }\n  }\n  IMask.RepeatBlock = RepeatBlock;\n  try {\n    globalThis.IMask = IMask;\n  } catch {}\n  exports.ChangeDetails = ChangeDetails;\n  exports.ChunksTailDetails = ChunksTailDetails;\n  exports.DIRECTION = DIRECTION;\n  exports.HTMLContenteditableMaskElement = HTMLContenteditableMaskElement;\n  exports.HTMLInputMaskElement = HTMLInputMaskElement;\n  exports.HTMLMaskElement = HTMLMaskElement;\n  exports.InputMask = InputMask;\n  exports.MaskElement = MaskElement;\n  exports.Masked = Masked;\n  exports.MaskedDate = MaskedDate;\n  exports.MaskedDynamic = MaskedDynamic;\n  exports.MaskedEnum = MaskedEnum;\n  exports.MaskedFunction = MaskedFunction;\n  exports.MaskedNumber = MaskedNumber;\n  exports.MaskedPattern = MaskedPattern;\n  exports.MaskedRange = MaskedRange;\n  exports.MaskedRegExp = MaskedRegExp;\n  exports.PIPE_TYPE = PIPE_TYPE;\n  exports.PatternFixedDefinition = PatternFixedDefinition;\n  exports.PatternInputDefinition = PatternInputDefinition;\n  exports.RepeatBlock = RepeatBlock;\n  exports.createMask = createMask;\n  exports.createPipe = createPipe;\n  exports.default = IMask;\n  exports.forceDirection = forceDirection;\n  exports.normalizeOpts = normalizeOpts;\n  exports.pipe = pipe;\n  Object.defineProperty(exports, '__esModule', {\n    value: true\n  });\n});\n\n//# sourceURL=webpack://brainwave/../../../themes/leocar/assets/src/scripts/utils/imask.js?");

/***/ }),

/***/ "../../../themes/leocar/assets/src/scripts/utils/modal.js":
/*!****************************************************************!*\
  !*** ../../../themes/leocar/assets/src/scripts/utils/modal.js ***!
  \****************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ modal; }\n/* harmony export */ });\nfunction modal() {\n  let body = document.body;\n  let modalWrap = document.getElementById('leo-modals');\n  let closeButtons = document.querySelectorAll('.modal .close');\n  let modalTriggers = document.querySelectorAll('.require-call, button.test-drive, button.show-conditions');\n  if (modalTriggers) {\n    modalTriggers.forEach(trigger => {\n      trigger.addEventListener('click', () => {\n        body.classList.add('modal-open');\n        modalWrap.classList.toggle('call', trigger.classList.contains('require-call'));\n        modalWrap.classList.toggle('drive', trigger.classList.contains('test-drive'));\n        modalWrap.classList.toggle('conditions', trigger.classList.contains('show-conditions'));\n      });\n    });\n  }\n  if (modalWrap) {\n    modalWrap.addEventListener('click', function (event) {\n      if (event.target === modalWrap) {\n        closeModals();\n      }\n    });\n    closeButtons.forEach(element => {\n      element.addEventListener('click', () => {\n        const modal = element.closest('.modal');\n        if (!modal) return;\n        closeModals();\n      });\n    });\n  }\n  document.addEventListener('mouseup', function (e) {\n    // Назва контейнеру\n    let container = document.querySelector('.modal.call');\n    // Умова, щоб працювало тільки коли попап відкритий\n    if (modalWrap.classList.contains('call')) {\n      if (!e.target.closest('a') && !container.contains(e.target)) {\n        closeModals();\n      }\n    }\n  });\n  document.addEventListener('mouseup', function (e) {\n    // Назва контейнеру\n    let container = document.querySelector('.modal.drive');\n    // Умова, щоб працювало тільки коли попап відкритий\n    if (modalWrap.classList.contains('drive')) {\n      if (!e.target.closest('a') && !container.contains(e.target)) {\n        closeModals();\n      }\n    }\n  });\n  document.addEventListener('mouseup', function (e) {\n    // Назва контейнеру\n    let container = document.querySelector('.modal.conditions');\n    // Умова, щоб працювало тільки коли попап відкритий\n    if (modalWrap.classList.contains('conditions')) {\n      if (!e.target.closest('a') && !container.contains(e.target)) {\n        closeModals();\n      }\n    }\n  });\n  function closeModals() {\n    modalWrap.classList.remove('call', 'drive', 'conditions');\n    body.classList.remove('modal-open');\n  }\n}\n\n//# sourceURL=webpack://brainwave/../../../themes/leocar/assets/src/scripts/utils/modal.js?");

/***/ }),

/***/ "../../../themes/leocar/assets/src/scripts/utils/popup.js":
/*!****************************************************************!*\
  !*** ../../../themes/leocar/assets/src/scripts/utils/popup.js ***!
  \****************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ popup; }\n/* harmony export */ });\nfunction popup() {\n  let body = document.body;\n  let message = document.querySelector('.leo-message');\n  if (message) {\n    message.querySelector('span').addEventListener('click', () => {\n      message.classList.toggle('open');\n    });\n  }\n}\n\n//# sourceURL=webpack://brainwave/../../../themes/leocar/assets/src/scripts/utils/popup.js?");

/***/ }),

/***/ "../../../themes/leocar/assets/src/scripts/utils/reviews.js":
/*!******************************************************************!*\
  !*** ../../../themes/leocar/assets/src/scripts/utils/reviews.js ***!
  \******************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ reviews; }\n/* harmony export */ });\nfunction reviews() {\n  //  let body = document.body;\n\n  //  let reviews = document.querySelector('.leo-reviews .reviews-list');\n  //  if (reviews) {\n  //      let reviewsBtn = document.querySelector('.leo-reviews .show-reviews');\n  //      reviewsBtn.addEventListener('click', () => {\n  //          reviews.classList.toggle('open');\n\n  //          if (reviewsBtn.textContent === \"Показати більше\") {\n  //              reviewsBtn.textContent = \"Приховати\";\n  //          } else {\n  //              reviewsBtn.textContent = \"Показати більше\";\n  //          }\n  //      });\n  //  }\n}\n\n//# sourceURL=webpack://brainwave/../../../themes/leocar/assets/src/scripts/utils/reviews.js?");

/***/ }),

/***/ "../../../themes/leocar/assets/src/scripts/utils/seo.js":
/*!**************************************************************!*\
  !*** ../../../themes/leocar/assets/src/scripts/utils/seo.js ***!
  \**************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ seo; }\n/* harmony export */ });\nfunction seo() {\n  let seo = document.querySelector('.leo-seo');\n  if (seo) {\n    let toggleButton = seo.querySelector('.button');\n    toggleButton.addEventListener('click', toggleHeight);\n  }\n  function toggleHeight() {\n    let outerDiv = seo.querySelector('.outer-text');\n    let innerDiv = seo.querySelector('.inner-text');\n    let toggleButton = seo.querySelector('.button');\n    let borderHeight = '180px';\n    if (window.screen.width > 1099) {\n      borderHeight = '102px';\n    }\n    if (outerDiv.style.height === borderHeight || outerDiv.style.height === '') {\n      outerDiv.style.height = innerDiv.clientHeight + 'px';\n      toggleButton.textContent = 'Приховати';\n    } else {\n      outerDiv.style.height = borderHeight;\n      toggleButton.textContent = 'Дивитись все';\n    }\n  }\n}\n\n//# sourceURL=webpack://brainwave/../../../themes/leocar/assets/src/scripts/utils/seo.js?");

/***/ }),

/***/ "../../../themes/leocar/assets/src/scripts/utils/swiper.js":
/*!*****************************************************************!*\
  !*** ../../../themes/leocar/assets/src/scripts/utils/swiper.js ***!
  \*****************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _plugins_brainwave_assembly_node_modules_swiper__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../../../plugins/brainwave/assembly/node_modules/swiper */ \"./node_modules/swiper/swiper.mjs\");\n/* harmony import */ var _plugins_brainwave_assembly_node_modules_swiper_modules_pagination_min_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../../../../plugins/brainwave/assembly/node_modules/swiper/modules/pagination.min.mjs */ \"./node_modules/swiper/modules/pagination.min.mjs\");\n/* harmony import */ var _plugins_brainwave_assembly_node_modules_swiper_modules_navigation_min_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../../../../plugins/brainwave/assembly/node_modules/swiper/modules/navigation.min.mjs */ \"./node_modules/swiper/modules/navigation.min.mjs\");\n\n\n\nconst ourTeamSwiper = document.querySelectorAll('.swiper');\nif (ourTeamSwiper.length > 0) {\n  new _plugins_brainwave_assembly_node_modules_swiper__WEBPACK_IMPORTED_MODULE_0__[\"default\"](document.querySelector('.leo-our-clients__slider'), {\n    modules: [_plugins_brainwave_assembly_node_modules_swiper_modules_pagination_min_mjs__WEBPACK_IMPORTED_MODULE_1__[\"default\"], _plugins_brainwave_assembly_node_modules_swiper_modules_navigation_min_mjs__WEBPACK_IMPORTED_MODULE_2__[\"default\"]],\n    slidesPerView: 3,\n    pagination: {\n      el: '.leo-our-clients__pagination',\n      type: 'bullets',\n      clickable: true,\n      dynamicBullets: false\n    },\n    navigation: {\n      nextEl: '.leo-our-clients__button_next',\n      prevEl: '.leo-our-clients__button_prev'\n    },\n    breakpoints: {\n      768: {\n        slidesPerView: 5\n      },\n      1280: {\n        slidesPerView: 7\n      }\n    }\n  });\n  new _plugins_brainwave_assembly_node_modules_swiper__WEBPACK_IMPORTED_MODULE_0__[\"default\"](document.querySelector('.leo-reviews__slider'), {\n    modules: [_plugins_brainwave_assembly_node_modules_swiper_modules_pagination_min_mjs__WEBPACK_IMPORTED_MODULE_1__[\"default\"], _plugins_brainwave_assembly_node_modules_swiper_modules_navigation_min_mjs__WEBPACK_IMPORTED_MODULE_2__[\"default\"]],\n    pagination: {\n      el: '.leo-reviews__pagination',\n      type: 'bullets',\n      clickable: true,\n      dynamicBullets: false\n    },\n    navigation: {\n      nextEl: '.leo-reviews__button_next',\n      prevEl: '.leo-reviews__button_prev'\n    },\n    breakpoints: {\n      768: {\n        slidesPerView: 2,\n        spaceBetween: 20\n      },\n      1024: {\n        slidesPerView: 3,\n        spaceBetween: 20\n      }\n    }\n  });\n}\n\n//# sourceURL=webpack://brainwave/../../../themes/leocar/assets/src/scripts/utils/swiper.js?");

/***/ }),

/***/ "./node_modules/swiper/modules/navigation.min.mjs":
/*!********************************************************!*\
  !*** ./node_modules/swiper/modules/navigation.min.mjs ***!
  \********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ Navigation; }\n/* harmony export */ });\n/* harmony import */ var _shared_create_element_if_not_defined_min_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../shared/create-element-if-not-defined.min.mjs */ \"./node_modules/swiper/shared/create-element-if-not-defined.min.mjs\");\nfunction Navigation(a){let{swiper:n,extendParams:e,on:i,emit:t}=a;e({navigation:{nextEl:null,prevEl:null,hideOnClick:!1,disabledClass:\"swiper-button-disabled\",hiddenClass:\"swiper-button-hidden\",lockClass:\"swiper-button-lock\",navigationDisabledClass:\"swiper-navigation-disabled\"}}),n.navigation={nextEl:null,prevEl:null};const s=a=>(Array.isArray(a)||(a=[a].filter((a=>!!a))),a);function l(a){let e;return a&&\"string\"==typeof a&&n.isElement&&(e=n.el.querySelector(a),e)?e:(a&&(\"string\"==typeof a&&(e=[...document.querySelectorAll(a)]),n.params.uniqueNavElements&&\"string\"==typeof a&&e.length>1&&1===n.el.querySelectorAll(a).length&&(e=n.el.querySelector(a))),a&&!e?a:e)}function o(a,e){const i=n.params.navigation;(a=s(a)).forEach((a=>{a&&(a.classList[e?\"add\":\"remove\"](...i.disabledClass.split(\" \")),\"BUTTON\"===a.tagName&&(a.disabled=e),n.params.watchOverflow&&n.enabled&&a.classList[n.isLocked?\"add\":\"remove\"](i.lockClass))}))}function r(){const{nextEl:a,prevEl:e}=n.navigation;if(n.params.loop)return o(e,!1),void o(a,!1);o(e,n.isBeginning&&!n.params.rewind),o(a,n.isEnd&&!n.params.rewind)}function d(a){a.preventDefault(),(!n.isBeginning||n.params.loop||n.params.rewind)&&(n.slidePrev(),t(\"navigationPrev\"))}function c(a){a.preventDefault(),(!n.isEnd||n.params.loop||n.params.rewind)&&(n.slideNext(),t(\"navigationNext\"))}function p(){const a=n.params.navigation;if(n.params.navigation=(0,_shared_create_element_if_not_defined_min_mjs__WEBPACK_IMPORTED_MODULE_0__.c)(n,n.originalParams.navigation,n.params.navigation,{nextEl:\"swiper-button-next\",prevEl:\"swiper-button-prev\"}),!a.nextEl&&!a.prevEl)return;let e=l(a.nextEl),i=l(a.prevEl);Object.assign(n.navigation,{nextEl:e,prevEl:i}),e=s(e),i=s(i);const t=(e,i)=>{e&&e.addEventListener(\"click\",\"next\"===i?c:d),!n.enabled&&e&&e.classList.add(...a.lockClass.split(\" \"))};e.forEach((a=>t(a,\"next\"))),i.forEach((a=>t(a,\"prev\")))}function v(){let{nextEl:a,prevEl:e}=n.navigation;a=s(a),e=s(e);const i=(a,e)=>{a.removeEventListener(\"click\",\"next\"===e?c:d),a.classList.remove(...n.params.navigation.disabledClass.split(\" \"))};a.forEach((a=>i(a,\"next\"))),e.forEach((a=>i(a,\"prev\")))}i(\"init\",(()=>{!1===n.params.navigation.enabled?g():(p(),r())})),i(\"toEdge fromEdge lock unlock\",(()=>{r()})),i(\"destroy\",(()=>{v()})),i(\"enable disable\",(()=>{let{nextEl:a,prevEl:e}=n.navigation;a=s(a),e=s(e),[...a,...e].filter((a=>!!a)).forEach((a=>a.classList[n.enabled?\"remove\":\"add\"](n.params.navigation.lockClass)))})),i(\"click\",((a,e)=>{let{nextEl:i,prevEl:l}=n.navigation;i=s(i),l=s(l);const o=e.target;if(n.params.navigation.hideOnClick&&!l.includes(o)&&!i.includes(o)){if(n.pagination&&n.params.pagination&&n.params.pagination.clickable&&(n.pagination.el===o||n.pagination.el.contains(o)))return;let a;i.length?a=i[0].classList.contains(n.params.navigation.hiddenClass):l.length&&(a=l[0].classList.contains(n.params.navigation.hiddenClass)),t(!0===a?\"navigationShow\":\"navigationHide\"),[...i,...l].filter((a=>!!a)).forEach((a=>a.classList.toggle(n.params.navigation.hiddenClass)))}}));const g=()=>{n.el.classList.add(...n.params.navigation.navigationDisabledClass.split(\" \")),v()};Object.assign(n.navigation,{enable:()=>{n.el.classList.remove(...n.params.navigation.navigationDisabledClass.split(\" \")),p(),r()},disable:g,update:r,init:p,destroy:v})}\n//# sourceMappingURL=navigation.mjs.map\n\n//# sourceURL=webpack://brainwave/./node_modules/swiper/modules/navigation.min.mjs?");

/***/ }),

/***/ "./node_modules/swiper/modules/pagination.min.mjs":
/*!********************************************************!*\
  !*** ./node_modules/swiper/modules/pagination.min.mjs ***!
  \********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ Pagination; }\n/* harmony export */ });\n/* harmony import */ var _shared_classes_to_selector_min_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../shared/classes-to-selector.min.mjs */ \"./node_modules/swiper/shared/classes-to-selector.min.mjs\");\n/* harmony import */ var _shared_create_element_if_not_defined_min_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../shared/create-element-if-not-defined.min.mjs */ \"./node_modules/swiper/shared/create-element-if-not-defined.min.mjs\");\n/* harmony import */ var _shared_utils_min_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../shared/utils.min.mjs */ \"./node_modules/swiper/shared/utils.min.mjs\");\nfunction Pagination(e){let{swiper:a,extendParams:l,on:s,emit:t}=e;const i=\"swiper-pagination\";let n;l({pagination:{el:null,bulletElement:\"span\",clickable:!1,hideOnClick:!1,renderBullet:null,renderProgressbar:null,renderFraction:null,renderCustom:null,progressbarOpposite:!1,type:\"bullets\",dynamicBullets:!1,dynamicMainBullets:1,formatFractionCurrent:e=>e,formatFractionTotal:e=>e,bulletClass:`${i}-bullet`,bulletActiveClass:`${i}-bullet-active`,modifierClass:`${i}-`,currentClass:`${i}-current`,totalClass:`${i}-total`,hiddenClass:`${i}-hidden`,progressbarFillClass:`${i}-progressbar-fill`,progressbarOppositeClass:`${i}-progressbar-opposite`,clickableClass:`${i}-clickable`,lockClass:`${i}-lock`,horizontalClass:`${i}-horizontal`,verticalClass:`${i}-vertical`,paginationDisabledClass:`${i}-disabled`}}),a.pagination={el:null,bullets:[]};let r=0;const o=e=>(Array.isArray(e)||(e=[e].filter((e=>!!e))),e);function p(){return!a.params.pagination.el||!a.pagination.el||Array.isArray(a.pagination.el)&&0===a.pagination.el.length}function c(e,l){const{bulletActiveClass:s}=a.params.pagination;e&&(e=e[(\"prev\"===l?\"previous\":\"next\")+\"ElementSibling\"])&&(e.classList.add(`${s}-${l}`),(e=e[(\"prev\"===l?\"previous\":\"next\")+\"ElementSibling\"])&&e.classList.add(`${s}-${l}-${l}`))}function d(e){const l=e.target.closest((0,_shared_classes_to_selector_min_mjs__WEBPACK_IMPORTED_MODULE_0__.c)(a.params.pagination.bulletClass));if(!l)return;e.preventDefault();const s=(0,_shared_utils_min_mjs__WEBPACK_IMPORTED_MODULE_2__.g)(l)*a.params.slidesPerGroup;if(a.params.loop){if(a.realIndex===s)return;const e=a.getSlideIndexByData(s),l=a.getSlideIndexByData(a.realIndex);e>a.slides.length-a.loopedSlides&&a.loopFix({direction:e>l?\"next\":\"prev\",activeSlideIndex:e,slideTo:!1}),a.slideToLoop(s)}else a.slideTo(s)}function u(){const e=a.rtl,l=a.params.pagination;if(p())return;let s,i,d=a.pagination.el;d=o(d);const u=a.virtual&&a.params.virtual.enabled?a.virtual.slides.length:a.slides.length,g=a.params.loop?Math.ceil(u/a.params.slidesPerGroup):a.snapGrid.length;if(a.params.loop?(i=a.previousRealIndex||0,s=a.params.slidesPerGroup>1?Math.floor(a.realIndex/a.params.slidesPerGroup):a.realIndex):void 0!==a.snapIndex?(s=a.snapIndex,i=a.previousSnapIndex):(i=a.previousIndex||0,s=a.activeIndex||0),\"bullets\"===l.type&&a.pagination.bullets&&a.pagination.bullets.length>0){const t=a.pagination.bullets;let o,p,u;if(l.dynamicBullets&&(n=(0,_shared_utils_min_mjs__WEBPACK_IMPORTED_MODULE_2__.f)(t[0],a.isHorizontal()?\"width\":\"height\",!0),d.forEach((e=>{e.style[a.isHorizontal()?\"width\":\"height\"]=n*(l.dynamicMainBullets+4)+\"px\"})),l.dynamicMainBullets>1&&void 0!==i&&(r+=s-(i||0),r>l.dynamicMainBullets-1?r=l.dynamicMainBullets-1:r<0&&(r=0)),o=Math.max(s-r,0),p=o+(Math.min(t.length,l.dynamicMainBullets)-1),u=(p+o)/2),t.forEach((e=>{const a=[...[\"\",\"-next\",\"-next-next\",\"-prev\",\"-prev-prev\",\"-main\"].map((e=>`${l.bulletActiveClass}${e}`))].map((e=>\"string\"==typeof e&&e.includes(\" \")?e.split(\" \"):e)).flat();e.classList.remove(...a)})),d.length>1)t.forEach((e=>{const t=(0,_shared_utils_min_mjs__WEBPACK_IMPORTED_MODULE_2__.g)(e);t===s?e.classList.add(...l.bulletActiveClass.split(\" \")):a.isElement&&e.setAttribute(\"part\",\"bullet\"),l.dynamicBullets&&(t>=o&&t<=p&&e.classList.add(...`${l.bulletActiveClass}-main`.split(\" \")),t===o&&c(e,\"prev\"),t===p&&c(e,\"next\"))}));else{const e=t[s];if(e&&e.classList.add(...l.bulletActiveClass.split(\" \")),a.isElement&&t.forEach(((e,a)=>{e.setAttribute(\"part\",a===s?\"bullet-active\":\"bullet\")})),l.dynamicBullets){const e=t[o],a=t[p];for(let e=o;e<=p;e+=1)t[e]&&t[e].classList.add(...`${l.bulletActiveClass}-main`.split(\" \"));c(e,\"prev\"),c(a,\"next\")}}if(l.dynamicBullets){const s=Math.min(t.length,l.dynamicMainBullets+4),i=(n*s-n)/2-u*n,r=e?\"right\":\"left\";t.forEach((e=>{e.style[a.isHorizontal()?r:\"top\"]=`${i}px`}))}}d.forEach(((e,i)=>{if(\"fraction\"===l.type&&(e.querySelectorAll((0,_shared_classes_to_selector_min_mjs__WEBPACK_IMPORTED_MODULE_0__.c)(l.currentClass)).forEach((e=>{e.textContent=l.formatFractionCurrent(s+1)})),e.querySelectorAll((0,_shared_classes_to_selector_min_mjs__WEBPACK_IMPORTED_MODULE_0__.c)(l.totalClass)).forEach((e=>{e.textContent=l.formatFractionTotal(g)}))),\"progressbar\"===l.type){let t;t=l.progressbarOpposite?a.isHorizontal()?\"vertical\":\"horizontal\":a.isHorizontal()?\"horizontal\":\"vertical\";const i=(s+1)/g;let n=1,r=1;\"horizontal\"===t?n=i:r=i,e.querySelectorAll((0,_shared_classes_to_selector_min_mjs__WEBPACK_IMPORTED_MODULE_0__.c)(l.progressbarFillClass)).forEach((e=>{e.style.transform=`translate3d(0,0,0) scaleX(${n}) scaleY(${r})`,e.style.transitionDuration=`${a.params.speed}ms`}))}\"custom\"===l.type&&l.renderCustom?(e.innerHTML=l.renderCustom(a,s+1,g),0===i&&t(\"paginationRender\",e)):(0===i&&t(\"paginationRender\",e),t(\"paginationUpdate\",e)),a.params.watchOverflow&&a.enabled&&e.classList[a.isLocked?\"add\":\"remove\"](l.lockClass)}))}function g(){const e=a.params.pagination;if(p())return;const l=a.virtual&&a.params.virtual.enabled?a.virtual.slides.length:a.slides.length;let s=a.pagination.el;s=o(s);let i=\"\";if(\"bullets\"===e.type){let s=a.params.loop?Math.ceil(l/a.params.slidesPerGroup):a.snapGrid.length;a.params.freeMode&&a.params.freeMode.enabled&&s>l&&(s=l);for(let l=0;l<s;l+=1)e.renderBullet?i+=e.renderBullet.call(a,l,e.bulletClass):i+=`<${e.bulletElement} ${a.isElement?'part=\"bullet\"':\"\"} class=\"${e.bulletClass}\"></${e.bulletElement}>`}\"fraction\"===e.type&&(i=e.renderFraction?e.renderFraction.call(a,e.currentClass,e.totalClass):`<span class=\"${e.currentClass}\"></span> / <span class=\"${e.totalClass}\"></span>`),\"progressbar\"===e.type&&(i=e.renderProgressbar?e.renderProgressbar.call(a,e.progressbarFillClass):`<span class=\"${e.progressbarFillClass}\"></span>`),a.pagination.bullets=[],s.forEach((l=>{\"custom\"!==e.type&&(l.innerHTML=i||\"\"),\"bullets\"===e.type&&a.pagination.bullets.push(...l.querySelectorAll((0,_shared_classes_to_selector_min_mjs__WEBPACK_IMPORTED_MODULE_0__.c)(e.bulletClass)))})),\"custom\"!==e.type&&t(\"paginationRender\",s[0])}function m(){a.params.pagination=(0,_shared_create_element_if_not_defined_min_mjs__WEBPACK_IMPORTED_MODULE_1__.c)(a,a.originalParams.pagination,a.params.pagination,{el:\"swiper-pagination\"});const e=a.params.pagination;if(!e.el)return;let l;\"string\"==typeof e.el&&a.isElement&&(l=a.el.querySelector(e.el)),l||\"string\"!=typeof e.el||(l=[...document.querySelectorAll(e.el)]),l||(l=e.el),l&&0!==l.length&&(a.params.uniqueNavElements&&\"string\"==typeof e.el&&Array.isArray(l)&&l.length>1&&(l=[...a.el.querySelectorAll(e.el)],l.length>1&&(l=l.filter((e=>(0,_shared_utils_min_mjs__WEBPACK_IMPORTED_MODULE_2__.a)(e,\".swiper\")[0]===a.el))[0])),Array.isArray(l)&&1===l.length&&(l=l[0]),Object.assign(a.pagination,{el:l}),l=o(l),l.forEach((l=>{\"bullets\"===e.type&&e.clickable&&l.classList.add(e.clickableClass),l.classList.add(e.modifierClass+e.type),l.classList.add(a.isHorizontal()?e.horizontalClass:e.verticalClass),\"bullets\"===e.type&&e.dynamicBullets&&(l.classList.add(`${e.modifierClass}${e.type}-dynamic`),r=0,e.dynamicMainBullets<1&&(e.dynamicMainBullets=1)),\"progressbar\"===e.type&&e.progressbarOpposite&&l.classList.add(e.progressbarOppositeClass),e.clickable&&l.addEventListener(\"click\",d),a.enabled||l.classList.add(e.lockClass)})))}function b(){const e=a.params.pagination;if(p())return;let l=a.pagination.el;l&&(l=o(l),l.forEach((l=>{l.classList.remove(e.hiddenClass),l.classList.remove(e.modifierClass+e.type),l.classList.remove(a.isHorizontal()?e.horizontalClass:e.verticalClass),e.clickable&&l.removeEventListener(\"click\",d)}))),a.pagination.bullets&&a.pagination.bullets.forEach((a=>a.classList.remove(...e.bulletActiveClass.split(\" \"))))}s(\"changeDirection\",(()=>{if(!a.pagination||!a.pagination.el)return;const e=a.params.pagination;let{el:l}=a.pagination;l=o(l),l.forEach((l=>{l.classList.remove(e.horizontalClass,e.verticalClass),l.classList.add(a.isHorizontal()?e.horizontalClass:e.verticalClass)}))})),s(\"init\",(()=>{!1===a.params.pagination.enabled?f():(m(),g(),u())})),s(\"activeIndexChange\",(()=>{void 0===a.snapIndex&&u()})),s(\"snapIndexChange\",(()=>{u()})),s(\"snapGridLengthChange\",(()=>{g(),u()})),s(\"destroy\",(()=>{b()})),s(\"enable disable\",(()=>{let{el:e}=a.pagination;e&&(e=o(e),e.forEach((e=>e.classList[a.enabled?\"remove\":\"add\"](a.params.pagination.lockClass))))})),s(\"lock unlock\",(()=>{u()})),s(\"click\",((e,l)=>{const s=l.target,i=o(a.pagination.el);if(a.params.pagination.el&&a.params.pagination.hideOnClick&&i&&i.length>0&&!s.classList.contains(a.params.pagination.bulletClass)){if(a.navigation&&(a.navigation.nextEl&&s===a.navigation.nextEl||a.navigation.prevEl&&s===a.navigation.prevEl))return;const e=i[0].classList.contains(a.params.pagination.hiddenClass);t(!0===e?\"paginationShow\":\"paginationHide\"),i.forEach((e=>e.classList.toggle(a.params.pagination.hiddenClass)))}}));const f=()=>{a.el.classList.add(a.params.pagination.paginationDisabledClass);let{el:e}=a.pagination;e&&(e=o(e),e.forEach((e=>e.classList.add(a.params.pagination.paginationDisabledClass)))),b()};Object.assign(a.pagination,{enable:()=>{a.el.classList.remove(a.params.pagination.paginationDisabledClass);let{el:e}=a.pagination;e&&(e=o(e),e.forEach((e=>e.classList.remove(a.params.pagination.paginationDisabledClass)))),m(),g(),u()},disable:f,render:g,update:u,init:m,destroy:b})}\n//# sourceMappingURL=pagination.mjs.map\n\n//# sourceURL=webpack://brainwave/./node_modules/swiper/modules/pagination.min.mjs?");

/***/ }),

/***/ "./node_modules/swiper/shared/classes-to-selector.min.mjs":
/*!****************************************************************!*\
  !*** ./node_modules/swiper/shared/classes-to-selector.min.mjs ***!
  \****************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   c: function() { return /* binding */ classesToSelector; }\n/* harmony export */ });\nfunction classesToSelector(e){return void 0===e&&(e=\"\"),`.${e.trim().replace(/([\\.:!+\\/])/g,\"\\\\$1\").replace(/ /g,\".\")}`}\n//# sourceMappingURL=classes-to-selector.mjs.map\n\n//# sourceURL=webpack://brainwave/./node_modules/swiper/shared/classes-to-selector.min.mjs?");

/***/ }),

/***/ "./node_modules/swiper/shared/create-element-if-not-defined.min.mjs":
/*!**************************************************************************!*\
  !*** ./node_modules/swiper/shared/create-element-if-not-defined.min.mjs ***!
  \**************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   c: function() { return /* binding */ createElementIfNotDefined; }\n/* harmony export */ });\n/* harmony import */ var _utils_min_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.min.mjs */ \"./node_modules/swiper/shared/utils.min.mjs\");\nfunction createElementIfNotDefined(e,t,n,a){return e.params.createElements&&Object.keys(a).forEach((l=>{if(!n[l]&&!0===n.auto){let r=(0,_utils_min_mjs__WEBPACK_IMPORTED_MODULE_0__.e)(e.el,`.${a[l]}`)[0];r||(r=(0,_utils_min_mjs__WEBPACK_IMPORTED_MODULE_0__.c)(\"div\",a[l]),r.className=a[l],e.el.append(r)),n[l]=r,t[l]=r}})),n}\n//# sourceMappingURL=create-element-if-not-defined.mjs.map\n\n//# sourceURL=webpack://brainwave/./node_modules/swiper/shared/create-element-if-not-defined.min.mjs?");

/***/ }),

/***/ "./node_modules/swiper/shared/ssr-window.esm.min.mjs":
/*!***********************************************************!*\
  !*** ./node_modules/swiper/shared/ssr-window.esm.min.mjs ***!
  \***********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   a: function() { return /* binding */ getWindow; },\n/* harmony export */   g: function() { return /* binding */ getDocument; }\n/* harmony export */ });\nfunction isObject(e){return null!==e&&\"object\"==typeof e&&\"constructor\"in e&&e.constructor===Object}function extend(e,t){void 0===e&&(e={}),void 0===t&&(t={}),Object.keys(t).forEach((n=>{void 0===e[n]?e[n]=t[n]:isObject(t[n])&&isObject(e[n])&&Object.keys(t[n]).length>0&&extend(e[n],t[n])}))}const ssrDocument={body:{},addEventListener(){},removeEventListener(){},activeElement:{blur(){},nodeName:\"\"},querySelector:()=>null,querySelectorAll:()=>[],getElementById:()=>null,createEvent:()=>({initEvent(){}}),createElement:()=>({children:[],childNodes:[],style:{},setAttribute(){},getElementsByTagName:()=>[]}),createElementNS:()=>({}),importNode:()=>null,location:{hash:\"\",host:\"\",hostname:\"\",href:\"\",origin:\"\",pathname:\"\",protocol:\"\",search:\"\"}};function getDocument(){const e=\"undefined\"!=typeof document?document:{};return extend(e,ssrDocument),e}const ssrWindow={document:ssrDocument,navigator:{userAgent:\"\"},location:{hash:\"\",host:\"\",hostname:\"\",href:\"\",origin:\"\",pathname:\"\",protocol:\"\",search:\"\"},history:{replaceState(){},pushState(){},go(){},back(){}},CustomEvent:function(){return this},addEventListener(){},removeEventListener(){},getComputedStyle:()=>({getPropertyValue:()=>\"\"}),Image(){},Date(){},screen:{},setTimeout(){},clearTimeout(){},matchMedia:()=>({}),requestAnimationFrame:e=>\"undefined\"==typeof setTimeout?(e(),null):setTimeout(e,0),cancelAnimationFrame(e){\"undefined\"!=typeof setTimeout&&clearTimeout(e)}};function getWindow(){const e=\"undefined\"!=typeof window?window:{};return extend(e,ssrWindow),e}\n//# sourceMappingURL=ssr-window.esm.mjs.map\n\n//# sourceURL=webpack://brainwave/./node_modules/swiper/shared/ssr-window.esm.min.mjs?");

/***/ }),

/***/ "./node_modules/swiper/shared/ssr-window.esm.mjs":
/*!*******************************************************!*\
  !*** ./node_modules/swiper/shared/ssr-window.esm.mjs ***!
  \*******************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   a: function() { return /* binding */ getWindow; },\n/* harmony export */   g: function() { return /* binding */ getDocument; }\n/* harmony export */ });\n/**\n * SSR Window 4.0.2\n * Better handling for window object in SSR environment\n * https://github.com/nolimits4web/ssr-window\n *\n * Copyright 2021, Vladimir Kharlampidi\n *\n * Licensed under MIT\n *\n * Released on: December 13, 2021\n */\n/* eslint-disable no-param-reassign */\nfunction isObject(obj) {\n  return obj !== null && typeof obj === 'object' && 'constructor' in obj && obj.constructor === Object;\n}\nfunction extend(target, src) {\n  if (target === void 0) {\n    target = {};\n  }\n  if (src === void 0) {\n    src = {};\n  }\n  Object.keys(src).forEach(key => {\n    if (typeof target[key] === 'undefined') target[key] = src[key];else if (isObject(src[key]) && isObject(target[key]) && Object.keys(src[key]).length > 0) {\n      extend(target[key], src[key]);\n    }\n  });\n}\nconst ssrDocument = {\n  body: {},\n  addEventListener() {},\n  removeEventListener() {},\n  activeElement: {\n    blur() {},\n    nodeName: ''\n  },\n  querySelector() {\n    return null;\n  },\n  querySelectorAll() {\n    return [];\n  },\n  getElementById() {\n    return null;\n  },\n  createEvent() {\n    return {\n      initEvent() {}\n    };\n  },\n  createElement() {\n    return {\n      children: [],\n      childNodes: [],\n      style: {},\n      setAttribute() {},\n      getElementsByTagName() {\n        return [];\n      }\n    };\n  },\n  createElementNS() {\n    return {};\n  },\n  importNode() {\n    return null;\n  },\n  location: {\n    hash: '',\n    host: '',\n    hostname: '',\n    href: '',\n    origin: '',\n    pathname: '',\n    protocol: '',\n    search: ''\n  }\n};\nfunction getDocument() {\n  const doc = typeof document !== 'undefined' ? document : {};\n  extend(doc, ssrDocument);\n  return doc;\n}\nconst ssrWindow = {\n  document: ssrDocument,\n  navigator: {\n    userAgent: ''\n  },\n  location: {\n    hash: '',\n    host: '',\n    hostname: '',\n    href: '',\n    origin: '',\n    pathname: '',\n    protocol: '',\n    search: ''\n  },\n  history: {\n    replaceState() {},\n    pushState() {},\n    go() {},\n    back() {}\n  },\n  CustomEvent: function CustomEvent() {\n    return this;\n  },\n  addEventListener() {},\n  removeEventListener() {},\n  getComputedStyle() {\n    return {\n      getPropertyValue() {\n        return '';\n      }\n    };\n  },\n  Image() {},\n  Date() {},\n  screen: {},\n  setTimeout() {},\n  clearTimeout() {},\n  matchMedia() {\n    return {};\n  },\n  requestAnimationFrame(callback) {\n    if (typeof setTimeout === 'undefined') {\n      callback();\n      return null;\n    }\n    return setTimeout(callback, 0);\n  },\n  cancelAnimationFrame(id) {\n    if (typeof setTimeout === 'undefined') {\n      return;\n    }\n    clearTimeout(id);\n  }\n};\nfunction getWindow() {\n  const win = typeof window !== 'undefined' ? window : {};\n  extend(win, ssrWindow);\n  return win;\n}\n\n\n\n\n//# sourceURL=webpack://brainwave/./node_modules/swiper/shared/ssr-window.esm.mjs?");

/***/ }),

/***/ "./node_modules/swiper/shared/swiper-core.mjs":
/*!****************************************************!*\
  !*** ./node_modules/swiper/shared/swiper-core.mjs ***!
  \****************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   S: function() { return /* binding */ Swiper; },\n/* harmony export */   d: function() { return /* binding */ defaults; }\n/* harmony export */ });\n/* harmony import */ var _ssr_window_esm_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ssr-window.esm.mjs */ \"./node_modules/swiper/shared/ssr-window.esm.mjs\");\n/* harmony import */ var _utils_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.mjs */ \"./node_modules/swiper/shared/utils.mjs\");\n\n\n\nlet support;\nfunction calcSupport() {\n  const window = (0,_ssr_window_esm_mjs__WEBPACK_IMPORTED_MODULE_0__.a)();\n  const document = (0,_ssr_window_esm_mjs__WEBPACK_IMPORTED_MODULE_0__.g)();\n  return {\n    smoothScroll: document.documentElement && document.documentElement.style && 'scrollBehavior' in document.documentElement.style,\n    touch: !!('ontouchstart' in window || window.DocumentTouch && document instanceof window.DocumentTouch)\n  };\n}\nfunction getSupport() {\n  if (!support) {\n    support = calcSupport();\n  }\n  return support;\n}\n\nlet deviceCached;\nfunction calcDevice(_temp) {\n  let {\n    userAgent\n  } = _temp === void 0 ? {} : _temp;\n  const support = getSupport();\n  const window = (0,_ssr_window_esm_mjs__WEBPACK_IMPORTED_MODULE_0__.a)();\n  const platform = window.navigator.platform;\n  const ua = userAgent || window.navigator.userAgent;\n  const device = {\n    ios: false,\n    android: false\n  };\n  const screenWidth = window.screen.width;\n  const screenHeight = window.screen.height;\n  const android = ua.match(/(Android);?[\\s\\/]+([\\d.]+)?/); // eslint-disable-line\n  let ipad = ua.match(/(iPad).*OS\\s([\\d_]+)/);\n  const ipod = ua.match(/(iPod)(.*OS\\s([\\d_]+))?/);\n  const iphone = !ipad && ua.match(/(iPhone\\sOS|iOS)\\s([\\d_]+)/);\n  const windows = platform === 'Win32';\n  let macos = platform === 'MacIntel';\n\n  // iPadOs 13 fix\n  const iPadScreens = ['1024x1366', '1366x1024', '834x1194', '1194x834', '834x1112', '1112x834', '768x1024', '1024x768', '820x1180', '1180x820', '810x1080', '1080x810'];\n  if (!ipad && macos && support.touch && iPadScreens.indexOf(`${screenWidth}x${screenHeight}`) >= 0) {\n    ipad = ua.match(/(Version)\\/([\\d.]+)/);\n    if (!ipad) ipad = [0, 1, '13_0_0'];\n    macos = false;\n  }\n\n  // Android\n  if (android && !windows) {\n    device.os = 'android';\n    device.android = true;\n  }\n  if (ipad || iphone || ipod) {\n    device.os = 'ios';\n    device.ios = true;\n  }\n\n  // Export object\n  return device;\n}\nfunction getDevice(overrides) {\n  if (overrides === void 0) {\n    overrides = {};\n  }\n  if (!deviceCached) {\n    deviceCached = calcDevice(overrides);\n  }\n  return deviceCached;\n}\n\nlet browser;\nfunction calcBrowser() {\n  const window = (0,_ssr_window_esm_mjs__WEBPACK_IMPORTED_MODULE_0__.a)();\n  let needPerspectiveFix = false;\n  function isSafari() {\n    const ua = window.navigator.userAgent.toLowerCase();\n    return ua.indexOf('safari') >= 0 && ua.indexOf('chrome') < 0 && ua.indexOf('android') < 0;\n  }\n  if (isSafari()) {\n    const ua = String(window.navigator.userAgent);\n    if (ua.includes('Version/')) {\n      const [major, minor] = ua.split('Version/')[1].split(' ')[0].split('.').map(num => Number(num));\n      needPerspectiveFix = major < 16 || major === 16 && minor < 2;\n    }\n  }\n  return {\n    isSafari: needPerspectiveFix || isSafari(),\n    needPerspectiveFix,\n    isWebView: /(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/i.test(window.navigator.userAgent)\n  };\n}\nfunction getBrowser() {\n  if (!browser) {\n    browser = calcBrowser();\n  }\n  return browser;\n}\n\nfunction Resize(_ref) {\n  let {\n    swiper,\n    on,\n    emit\n  } = _ref;\n  const window = (0,_ssr_window_esm_mjs__WEBPACK_IMPORTED_MODULE_0__.a)();\n  let observer = null;\n  let animationFrame = null;\n  const resizeHandler = () => {\n    if (!swiper || swiper.destroyed || !swiper.initialized) return;\n    emit('beforeResize');\n    emit('resize');\n  };\n  const createObserver = () => {\n    if (!swiper || swiper.destroyed || !swiper.initialized) return;\n    observer = new ResizeObserver(entries => {\n      animationFrame = window.requestAnimationFrame(() => {\n        const {\n          width,\n          height\n        } = swiper;\n        let newWidth = width;\n        let newHeight = height;\n        entries.forEach(_ref2 => {\n          let {\n            contentBoxSize,\n            contentRect,\n            target\n          } = _ref2;\n          if (target && target !== swiper.el) return;\n          newWidth = contentRect ? contentRect.width : (contentBoxSize[0] || contentBoxSize).inlineSize;\n          newHeight = contentRect ? contentRect.height : (contentBoxSize[0] || contentBoxSize).blockSize;\n        });\n        if (newWidth !== width || newHeight !== height) {\n          resizeHandler();\n        }\n      });\n    });\n    observer.observe(swiper.el);\n  };\n  const removeObserver = () => {\n    if (animationFrame) {\n      window.cancelAnimationFrame(animationFrame);\n    }\n    if (observer && observer.unobserve && swiper.el) {\n      observer.unobserve(swiper.el);\n      observer = null;\n    }\n  };\n  const orientationChangeHandler = () => {\n    if (!swiper || swiper.destroyed || !swiper.initialized) return;\n    emit('orientationchange');\n  };\n  on('init', () => {\n    if (swiper.params.resizeObserver && typeof window.ResizeObserver !== 'undefined') {\n      createObserver();\n      return;\n    }\n    window.addEventListener('resize', resizeHandler);\n    window.addEventListener('orientationchange', orientationChangeHandler);\n  });\n  on('destroy', () => {\n    removeObserver();\n    window.removeEventListener('resize', resizeHandler);\n    window.removeEventListener('orientationchange', orientationChangeHandler);\n  });\n}\n\nfunction Observer(_ref) {\n  let {\n    swiper,\n    extendParams,\n    on,\n    emit\n  } = _ref;\n  const observers = [];\n  const window = (0,_ssr_window_esm_mjs__WEBPACK_IMPORTED_MODULE_0__.a)();\n  const attach = function (target, options) {\n    if (options === void 0) {\n      options = {};\n    }\n    const ObserverFunc = window.MutationObserver || window.WebkitMutationObserver;\n    const observer = new ObserverFunc(mutations => {\n      // The observerUpdate event should only be triggered\n      // once despite the number of mutations.  Additional\n      // triggers are redundant and are very costly\n      if (swiper.__preventObserver__) return;\n      if (mutations.length === 1) {\n        emit('observerUpdate', mutations[0]);\n        return;\n      }\n      const observerUpdate = function observerUpdate() {\n        emit('observerUpdate', mutations[0]);\n      };\n      if (window.requestAnimationFrame) {\n        window.requestAnimationFrame(observerUpdate);\n      } else {\n        window.setTimeout(observerUpdate, 0);\n      }\n    });\n    observer.observe(target, {\n      attributes: typeof options.attributes === 'undefined' ? true : options.attributes,\n      childList: typeof options.childList === 'undefined' ? true : options.childList,\n      characterData: typeof options.characterData === 'undefined' ? true : options.characterData\n    });\n    observers.push(observer);\n  };\n  const init = () => {\n    if (!swiper.params.observer) return;\n    if (swiper.params.observeParents) {\n      const containerParents = (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.a)(swiper.el);\n      for (let i = 0; i < containerParents.length; i += 1) {\n        attach(containerParents[i]);\n      }\n    }\n    // Observe container\n    attach(swiper.el, {\n      childList: swiper.params.observeSlideChildren\n    });\n\n    // Observe wrapper\n    attach(swiper.wrapperEl, {\n      attributes: false\n    });\n  };\n  const destroy = () => {\n    observers.forEach(observer => {\n      observer.disconnect();\n    });\n    observers.splice(0, observers.length);\n  };\n  extendParams({\n    observer: false,\n    observeParents: false,\n    observeSlideChildren: false\n  });\n  on('init', init);\n  on('destroy', destroy);\n}\n\n/* eslint-disable no-underscore-dangle */\n\nvar eventsEmitter = {\n  on(events, handler, priority) {\n    const self = this;\n    if (!self.eventsListeners || self.destroyed) return self;\n    if (typeof handler !== 'function') return self;\n    const method = priority ? 'unshift' : 'push';\n    events.split(' ').forEach(event => {\n      if (!self.eventsListeners[event]) self.eventsListeners[event] = [];\n      self.eventsListeners[event][method](handler);\n    });\n    return self;\n  },\n  once(events, handler, priority) {\n    const self = this;\n    if (!self.eventsListeners || self.destroyed) return self;\n    if (typeof handler !== 'function') return self;\n    function onceHandler() {\n      self.off(events, onceHandler);\n      if (onceHandler.__emitterProxy) {\n        delete onceHandler.__emitterProxy;\n      }\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n      handler.apply(self, args);\n    }\n    onceHandler.__emitterProxy = handler;\n    return self.on(events, onceHandler, priority);\n  },\n  onAny(handler, priority) {\n    const self = this;\n    if (!self.eventsListeners || self.destroyed) return self;\n    if (typeof handler !== 'function') return self;\n    const method = priority ? 'unshift' : 'push';\n    if (self.eventsAnyListeners.indexOf(handler) < 0) {\n      self.eventsAnyListeners[method](handler);\n    }\n    return self;\n  },\n  offAny(handler) {\n    const self = this;\n    if (!self.eventsListeners || self.destroyed) return self;\n    if (!self.eventsAnyListeners) return self;\n    const index = self.eventsAnyListeners.indexOf(handler);\n    if (index >= 0) {\n      self.eventsAnyListeners.splice(index, 1);\n    }\n    return self;\n  },\n  off(events, handler) {\n    const self = this;\n    if (!self.eventsListeners || self.destroyed) return self;\n    if (!self.eventsListeners) return self;\n    events.split(' ').forEach(event => {\n      if (typeof handler === 'undefined') {\n        self.eventsListeners[event] = [];\n      } else if (self.eventsListeners[event]) {\n        self.eventsListeners[event].forEach((eventHandler, index) => {\n          if (eventHandler === handler || eventHandler.__emitterProxy && eventHandler.__emitterProxy === handler) {\n            self.eventsListeners[event].splice(index, 1);\n          }\n        });\n      }\n    });\n    return self;\n  },\n  emit() {\n    const self = this;\n    if (!self.eventsListeners || self.destroyed) return self;\n    if (!self.eventsListeners) return self;\n    let events;\n    let data;\n    let context;\n    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      args[_key2] = arguments[_key2];\n    }\n    if (typeof args[0] === 'string' || Array.isArray(args[0])) {\n      events = args[0];\n      data = args.slice(1, args.length);\n      context = self;\n    } else {\n      events = args[0].events;\n      data = args[0].data;\n      context = args[0].context || self;\n    }\n    data.unshift(context);\n    const eventsArray = Array.isArray(events) ? events : events.split(' ');\n    eventsArray.forEach(event => {\n      if (self.eventsAnyListeners && self.eventsAnyListeners.length) {\n        self.eventsAnyListeners.forEach(eventHandler => {\n          eventHandler.apply(context, [event, ...data]);\n        });\n      }\n      if (self.eventsListeners && self.eventsListeners[event]) {\n        self.eventsListeners[event].forEach(eventHandler => {\n          eventHandler.apply(context, data);\n        });\n      }\n    });\n    return self;\n  }\n};\n\nfunction updateSize() {\n  const swiper = this;\n  let width;\n  let height;\n  const el = swiper.el;\n  if (typeof swiper.params.width !== 'undefined' && swiper.params.width !== null) {\n    width = swiper.params.width;\n  } else {\n    width = el.clientWidth;\n  }\n  if (typeof swiper.params.height !== 'undefined' && swiper.params.height !== null) {\n    height = swiper.params.height;\n  } else {\n    height = el.clientHeight;\n  }\n  if (width === 0 && swiper.isHorizontal() || height === 0 && swiper.isVertical()) {\n    return;\n  }\n\n  // Subtract paddings\n  width = width - parseInt((0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.l)(el, 'padding-left') || 0, 10) - parseInt((0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.l)(el, 'padding-right') || 0, 10);\n  height = height - parseInt((0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.l)(el, 'padding-top') || 0, 10) - parseInt((0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.l)(el, 'padding-bottom') || 0, 10);\n  if (Number.isNaN(width)) width = 0;\n  if (Number.isNaN(height)) height = 0;\n  Object.assign(swiper, {\n    width,\n    height,\n    size: swiper.isHorizontal() ? width : height\n  });\n}\n\nfunction updateSlides() {\n  const swiper = this;\n  function getDirectionLabel(property) {\n    if (swiper.isHorizontal()) {\n      return property;\n    }\n    // prettier-ignore\n    return {\n      'width': 'height',\n      'margin-top': 'margin-left',\n      'margin-bottom ': 'margin-right',\n      'margin-left': 'margin-top',\n      'margin-right': 'margin-bottom',\n      'padding-left': 'padding-top',\n      'padding-right': 'padding-bottom',\n      'marginRight': 'marginBottom'\n    }[property];\n  }\n  function getDirectionPropertyValue(node, label) {\n    return parseFloat(node.getPropertyValue(getDirectionLabel(label)) || 0);\n  }\n  const params = swiper.params;\n  const {\n    wrapperEl,\n    slidesEl,\n    size: swiperSize,\n    rtlTranslate: rtl,\n    wrongRTL\n  } = swiper;\n  const isVirtual = swiper.virtual && params.virtual.enabled;\n  const previousSlidesLength = isVirtual ? swiper.virtual.slides.length : swiper.slides.length;\n  const slides = (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.e)(slidesEl, `.${swiper.params.slideClass}, swiper-slide`);\n  const slidesLength = isVirtual ? swiper.virtual.slides.length : slides.length;\n  let snapGrid = [];\n  const slidesGrid = [];\n  const slidesSizesGrid = [];\n  let offsetBefore = params.slidesOffsetBefore;\n  if (typeof offsetBefore === 'function') {\n    offsetBefore = params.slidesOffsetBefore.call(swiper);\n  }\n  let offsetAfter = params.slidesOffsetAfter;\n  if (typeof offsetAfter === 'function') {\n    offsetAfter = params.slidesOffsetAfter.call(swiper);\n  }\n  const previousSnapGridLength = swiper.snapGrid.length;\n  const previousSlidesGridLength = swiper.slidesGrid.length;\n  let spaceBetween = params.spaceBetween;\n  let slidePosition = -offsetBefore;\n  let prevSlideSize = 0;\n  let index = 0;\n  if (typeof swiperSize === 'undefined') {\n    return;\n  }\n  if (typeof spaceBetween === 'string' && spaceBetween.indexOf('%') >= 0) {\n    spaceBetween = parseFloat(spaceBetween.replace('%', '')) / 100 * swiperSize;\n  } else if (typeof spaceBetween === 'string') {\n    spaceBetween = parseFloat(spaceBetween);\n  }\n  swiper.virtualSize = -spaceBetween;\n\n  // reset margins\n  slides.forEach(slideEl => {\n    if (rtl) {\n      slideEl.style.marginLeft = '';\n    } else {\n      slideEl.style.marginRight = '';\n    }\n    slideEl.style.marginBottom = '';\n    slideEl.style.marginTop = '';\n  });\n\n  // reset cssMode offsets\n  if (params.centeredSlides && params.cssMode) {\n    (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.s)(wrapperEl, '--swiper-centered-offset-before', '');\n    (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.s)(wrapperEl, '--swiper-centered-offset-after', '');\n  }\n  const gridEnabled = params.grid && params.grid.rows > 1 && swiper.grid;\n  if (gridEnabled) {\n    swiper.grid.initSlides(slidesLength);\n  }\n\n  // Calc slides\n  let slideSize;\n  const shouldResetSlideSize = params.slidesPerView === 'auto' && params.breakpoints && Object.keys(params.breakpoints).filter(key => {\n    return typeof params.breakpoints[key].slidesPerView !== 'undefined';\n  }).length > 0;\n  for (let i = 0; i < slidesLength; i += 1) {\n    slideSize = 0;\n    let slide;\n    if (slides[i]) slide = slides[i];\n    if (gridEnabled) {\n      swiper.grid.updateSlide(i, slide, slidesLength, getDirectionLabel);\n    }\n    if (slides[i] && (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.l)(slide, 'display') === 'none') continue; // eslint-disable-line\n\n    if (params.slidesPerView === 'auto') {\n      if (shouldResetSlideSize) {\n        slides[i].style[getDirectionLabel('width')] = ``;\n      }\n      const slideStyles = getComputedStyle(slide);\n      const currentTransform = slide.style.transform;\n      const currentWebKitTransform = slide.style.webkitTransform;\n      if (currentTransform) {\n        slide.style.transform = 'none';\n      }\n      if (currentWebKitTransform) {\n        slide.style.webkitTransform = 'none';\n      }\n      if (params.roundLengths) {\n        slideSize = swiper.isHorizontal() ? (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.f)(slide, 'width', true) : (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.f)(slide, 'height', true);\n      } else {\n        // eslint-disable-next-line\n        const width = getDirectionPropertyValue(slideStyles, 'width');\n        const paddingLeft = getDirectionPropertyValue(slideStyles, 'padding-left');\n        const paddingRight = getDirectionPropertyValue(slideStyles, 'padding-right');\n        const marginLeft = getDirectionPropertyValue(slideStyles, 'margin-left');\n        const marginRight = getDirectionPropertyValue(slideStyles, 'margin-right');\n        const boxSizing = slideStyles.getPropertyValue('box-sizing');\n        if (boxSizing && boxSizing === 'border-box') {\n          slideSize = width + marginLeft + marginRight;\n        } else {\n          const {\n            clientWidth,\n            offsetWidth\n          } = slide;\n          slideSize = width + paddingLeft + paddingRight + marginLeft + marginRight + (offsetWidth - clientWidth);\n        }\n      }\n      if (currentTransform) {\n        slide.style.transform = currentTransform;\n      }\n      if (currentWebKitTransform) {\n        slide.style.webkitTransform = currentWebKitTransform;\n      }\n      if (params.roundLengths) slideSize = Math.floor(slideSize);\n    } else {\n      slideSize = (swiperSize - (params.slidesPerView - 1) * spaceBetween) / params.slidesPerView;\n      if (params.roundLengths) slideSize = Math.floor(slideSize);\n      if (slides[i]) {\n        slides[i].style[getDirectionLabel('width')] = `${slideSize}px`;\n      }\n    }\n    if (slides[i]) {\n      slides[i].swiperSlideSize = slideSize;\n    }\n    slidesSizesGrid.push(slideSize);\n    if (params.centeredSlides) {\n      slidePosition = slidePosition + slideSize / 2 + prevSlideSize / 2 + spaceBetween;\n      if (prevSlideSize === 0 && i !== 0) slidePosition = slidePosition - swiperSize / 2 - spaceBetween;\n      if (i === 0) slidePosition = slidePosition - swiperSize / 2 - spaceBetween;\n      if (Math.abs(slidePosition) < 1 / 1000) slidePosition = 0;\n      if (params.roundLengths) slidePosition = Math.floor(slidePosition);\n      if (index % params.slidesPerGroup === 0) snapGrid.push(slidePosition);\n      slidesGrid.push(slidePosition);\n    } else {\n      if (params.roundLengths) slidePosition = Math.floor(slidePosition);\n      if ((index - Math.min(swiper.params.slidesPerGroupSkip, index)) % swiper.params.slidesPerGroup === 0) snapGrid.push(slidePosition);\n      slidesGrid.push(slidePosition);\n      slidePosition = slidePosition + slideSize + spaceBetween;\n    }\n    swiper.virtualSize += slideSize + spaceBetween;\n    prevSlideSize = slideSize;\n    index += 1;\n  }\n  swiper.virtualSize = Math.max(swiper.virtualSize, swiperSize) + offsetAfter;\n  if (rtl && wrongRTL && (params.effect === 'slide' || params.effect === 'coverflow')) {\n    wrapperEl.style.width = `${swiper.virtualSize + spaceBetween}px`;\n  }\n  if (params.setWrapperSize) {\n    wrapperEl.style[getDirectionLabel('width')] = `${swiper.virtualSize + spaceBetween}px`;\n  }\n  if (gridEnabled) {\n    swiper.grid.updateWrapperSize(slideSize, snapGrid, getDirectionLabel);\n  }\n\n  // Remove last grid elements depending on width\n  if (!params.centeredSlides) {\n    const newSlidesGrid = [];\n    for (let i = 0; i < snapGrid.length; i += 1) {\n      let slidesGridItem = snapGrid[i];\n      if (params.roundLengths) slidesGridItem = Math.floor(slidesGridItem);\n      if (snapGrid[i] <= swiper.virtualSize - swiperSize) {\n        newSlidesGrid.push(slidesGridItem);\n      }\n    }\n    snapGrid = newSlidesGrid;\n    if (Math.floor(swiper.virtualSize - swiperSize) - Math.floor(snapGrid[snapGrid.length - 1]) > 1) {\n      snapGrid.push(swiper.virtualSize - swiperSize);\n    }\n  }\n  if (isVirtual && params.loop) {\n    const size = slidesSizesGrid[0] + spaceBetween;\n    if (params.slidesPerGroup > 1) {\n      const groups = Math.ceil((swiper.virtual.slidesBefore + swiper.virtual.slidesAfter) / params.slidesPerGroup);\n      const groupSize = size * params.slidesPerGroup;\n      for (let i = 0; i < groups; i += 1) {\n        snapGrid.push(snapGrid[snapGrid.length - 1] + groupSize);\n      }\n    }\n    for (let i = 0; i < swiper.virtual.slidesBefore + swiper.virtual.slidesAfter; i += 1) {\n      if (params.slidesPerGroup === 1) {\n        snapGrid.push(snapGrid[snapGrid.length - 1] + size);\n      }\n      slidesGrid.push(slidesGrid[slidesGrid.length - 1] + size);\n      swiper.virtualSize += size;\n    }\n  }\n  if (snapGrid.length === 0) snapGrid = [0];\n  if (spaceBetween !== 0) {\n    const key = swiper.isHorizontal() && rtl ? 'marginLeft' : getDirectionLabel('marginRight');\n    slides.filter((_, slideIndex) => {\n      if (!params.cssMode || params.loop) return true;\n      if (slideIndex === slides.length - 1) {\n        return false;\n      }\n      return true;\n    }).forEach(slideEl => {\n      slideEl.style[key] = `${spaceBetween}px`;\n    });\n  }\n  if (params.centeredSlides && params.centeredSlidesBounds) {\n    let allSlidesSize = 0;\n    slidesSizesGrid.forEach(slideSizeValue => {\n      allSlidesSize += slideSizeValue + (spaceBetween || 0);\n    });\n    allSlidesSize -= spaceBetween;\n    const maxSnap = allSlidesSize - swiperSize;\n    snapGrid = snapGrid.map(snap => {\n      if (snap <= 0) return -offsetBefore;\n      if (snap > maxSnap) return maxSnap + offsetAfter;\n      return snap;\n    });\n  }\n  if (params.centerInsufficientSlides) {\n    let allSlidesSize = 0;\n    slidesSizesGrid.forEach(slideSizeValue => {\n      allSlidesSize += slideSizeValue + (spaceBetween || 0);\n    });\n    allSlidesSize -= spaceBetween;\n    if (allSlidesSize < swiperSize) {\n      const allSlidesOffset = (swiperSize - allSlidesSize) / 2;\n      snapGrid.forEach((snap, snapIndex) => {\n        snapGrid[snapIndex] = snap - allSlidesOffset;\n      });\n      slidesGrid.forEach((snap, snapIndex) => {\n        slidesGrid[snapIndex] = snap + allSlidesOffset;\n      });\n    }\n  }\n  Object.assign(swiper, {\n    slides,\n    snapGrid,\n    slidesGrid,\n    slidesSizesGrid\n  });\n  if (params.centeredSlides && params.cssMode && !params.centeredSlidesBounds) {\n    (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.s)(wrapperEl, '--swiper-centered-offset-before', `${-snapGrid[0]}px`);\n    (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.s)(wrapperEl, '--swiper-centered-offset-after', `${swiper.size / 2 - slidesSizesGrid[slidesSizesGrid.length - 1] / 2}px`);\n    const addToSnapGrid = -swiper.snapGrid[0];\n    const addToSlidesGrid = -swiper.slidesGrid[0];\n    swiper.snapGrid = swiper.snapGrid.map(v => v + addToSnapGrid);\n    swiper.slidesGrid = swiper.slidesGrid.map(v => v + addToSlidesGrid);\n  }\n  if (slidesLength !== previousSlidesLength) {\n    swiper.emit('slidesLengthChange');\n  }\n  if (snapGrid.length !== previousSnapGridLength) {\n    if (swiper.params.watchOverflow) swiper.checkOverflow();\n    swiper.emit('snapGridLengthChange');\n  }\n  if (slidesGrid.length !== previousSlidesGridLength) {\n    swiper.emit('slidesGridLengthChange');\n  }\n  if (params.watchSlidesProgress) {\n    swiper.updateSlidesOffset();\n  }\n  if (!isVirtual && !params.cssMode && (params.effect === 'slide' || params.effect === 'fade')) {\n    const backFaceHiddenClass = `${params.containerModifierClass}backface-hidden`;\n    const hasClassBackfaceClassAdded = swiper.el.classList.contains(backFaceHiddenClass);\n    if (slidesLength <= params.maxBackfaceHiddenSlides) {\n      if (!hasClassBackfaceClassAdded) swiper.el.classList.add(backFaceHiddenClass);\n    } else if (hasClassBackfaceClassAdded) {\n      swiper.el.classList.remove(backFaceHiddenClass);\n    }\n  }\n}\n\nfunction updateAutoHeight(speed) {\n  const swiper = this;\n  const activeSlides = [];\n  const isVirtual = swiper.virtual && swiper.params.virtual.enabled;\n  let newHeight = 0;\n  let i;\n  if (typeof speed === 'number') {\n    swiper.setTransition(speed);\n  } else if (speed === true) {\n    swiper.setTransition(swiper.params.speed);\n  }\n  const getSlideByIndex = index => {\n    if (isVirtual) {\n      return swiper.slides[swiper.getSlideIndexByData(index)];\n    }\n    return swiper.slides[index];\n  };\n  // Find slides currently in view\n  if (swiper.params.slidesPerView !== 'auto' && swiper.params.slidesPerView > 1) {\n    if (swiper.params.centeredSlides) {\n      (swiper.visibleSlides || []).forEach(slide => {\n        activeSlides.push(slide);\n      });\n    } else {\n      for (i = 0; i < Math.ceil(swiper.params.slidesPerView); i += 1) {\n        const index = swiper.activeIndex + i;\n        if (index > swiper.slides.length && !isVirtual) break;\n        activeSlides.push(getSlideByIndex(index));\n      }\n    }\n  } else {\n    activeSlides.push(getSlideByIndex(swiper.activeIndex));\n  }\n\n  // Find new height from highest slide in view\n  for (i = 0; i < activeSlides.length; i += 1) {\n    if (typeof activeSlides[i] !== 'undefined') {\n      const height = activeSlides[i].offsetHeight;\n      newHeight = height > newHeight ? height : newHeight;\n    }\n  }\n\n  // Update Height\n  if (newHeight || newHeight === 0) swiper.wrapperEl.style.height = `${newHeight}px`;\n}\n\nfunction updateSlidesOffset() {\n  const swiper = this;\n  const slides = swiper.slides;\n  // eslint-disable-next-line\n  const minusOffset = swiper.isElement ? swiper.isHorizontal() ? swiper.wrapperEl.offsetLeft : swiper.wrapperEl.offsetTop : 0;\n  for (let i = 0; i < slides.length; i += 1) {\n    slides[i].swiperSlideOffset = (swiper.isHorizontal() ? slides[i].offsetLeft : slides[i].offsetTop) - minusOffset - swiper.cssOverflowAdjustment();\n  }\n}\n\nfunction updateSlidesProgress(translate) {\n  if (translate === void 0) {\n    translate = this && this.translate || 0;\n  }\n  const swiper = this;\n  const params = swiper.params;\n  const {\n    slides,\n    rtlTranslate: rtl,\n    snapGrid\n  } = swiper;\n  if (slides.length === 0) return;\n  if (typeof slides[0].swiperSlideOffset === 'undefined') swiper.updateSlidesOffset();\n  let offsetCenter = -translate;\n  if (rtl) offsetCenter = translate;\n\n  // Visible Slides\n  slides.forEach(slideEl => {\n    slideEl.classList.remove(params.slideVisibleClass);\n  });\n  swiper.visibleSlidesIndexes = [];\n  swiper.visibleSlides = [];\n  let spaceBetween = params.spaceBetween;\n  if (typeof spaceBetween === 'string' && spaceBetween.indexOf('%') >= 0) {\n    spaceBetween = parseFloat(spaceBetween.replace('%', '')) / 100 * swiper.size;\n  } else if (typeof spaceBetween === 'string') {\n    spaceBetween = parseFloat(spaceBetween);\n  }\n  for (let i = 0; i < slides.length; i += 1) {\n    const slide = slides[i];\n    let slideOffset = slide.swiperSlideOffset;\n    if (params.cssMode && params.centeredSlides) {\n      slideOffset -= slides[0].swiperSlideOffset;\n    }\n    const slideProgress = (offsetCenter + (params.centeredSlides ? swiper.minTranslate() : 0) - slideOffset) / (slide.swiperSlideSize + spaceBetween);\n    const originalSlideProgress = (offsetCenter - snapGrid[0] + (params.centeredSlides ? swiper.minTranslate() : 0) - slideOffset) / (slide.swiperSlideSize + spaceBetween);\n    const slideBefore = -(offsetCenter - slideOffset);\n    const slideAfter = slideBefore + swiper.slidesSizesGrid[i];\n    const isVisible = slideBefore >= 0 && slideBefore < swiper.size - 1 || slideAfter > 1 && slideAfter <= swiper.size || slideBefore <= 0 && slideAfter >= swiper.size;\n    if (isVisible) {\n      swiper.visibleSlides.push(slide);\n      swiper.visibleSlidesIndexes.push(i);\n      slides[i].classList.add(params.slideVisibleClass);\n    }\n    slide.progress = rtl ? -slideProgress : slideProgress;\n    slide.originalProgress = rtl ? -originalSlideProgress : originalSlideProgress;\n  }\n}\n\nfunction updateProgress(translate) {\n  const swiper = this;\n  if (typeof translate === 'undefined') {\n    const multiplier = swiper.rtlTranslate ? -1 : 1;\n    // eslint-disable-next-line\n    translate = swiper && swiper.translate && swiper.translate * multiplier || 0;\n  }\n  const params = swiper.params;\n  const translatesDiff = swiper.maxTranslate() - swiper.minTranslate();\n  let {\n    progress,\n    isBeginning,\n    isEnd,\n    progressLoop\n  } = swiper;\n  const wasBeginning = isBeginning;\n  const wasEnd = isEnd;\n  if (translatesDiff === 0) {\n    progress = 0;\n    isBeginning = true;\n    isEnd = true;\n  } else {\n    progress = (translate - swiper.minTranslate()) / translatesDiff;\n    const isBeginningRounded = Math.abs(translate - swiper.minTranslate()) < 1;\n    const isEndRounded = Math.abs(translate - swiper.maxTranslate()) < 1;\n    isBeginning = isBeginningRounded || progress <= 0;\n    isEnd = isEndRounded || progress >= 1;\n    if (isBeginningRounded) progress = 0;\n    if (isEndRounded) progress = 1;\n  }\n  if (params.loop) {\n    const firstSlideIndex = swiper.getSlideIndexByData(0);\n    const lastSlideIndex = swiper.getSlideIndexByData(swiper.slides.length - 1);\n    const firstSlideTranslate = swiper.slidesGrid[firstSlideIndex];\n    const lastSlideTranslate = swiper.slidesGrid[lastSlideIndex];\n    const translateMax = swiper.slidesGrid[swiper.slidesGrid.length - 1];\n    const translateAbs = Math.abs(translate);\n    if (translateAbs >= firstSlideTranslate) {\n      progressLoop = (translateAbs - firstSlideTranslate) / translateMax;\n    } else {\n      progressLoop = (translateAbs + translateMax - lastSlideTranslate) / translateMax;\n    }\n    if (progressLoop > 1) progressLoop -= 1;\n  }\n  Object.assign(swiper, {\n    progress,\n    progressLoop,\n    isBeginning,\n    isEnd\n  });\n  if (params.watchSlidesProgress || params.centeredSlides && params.autoHeight) swiper.updateSlidesProgress(translate);\n  if (isBeginning && !wasBeginning) {\n    swiper.emit('reachBeginning toEdge');\n  }\n  if (isEnd && !wasEnd) {\n    swiper.emit('reachEnd toEdge');\n  }\n  if (wasBeginning && !isBeginning || wasEnd && !isEnd) {\n    swiper.emit('fromEdge');\n  }\n  swiper.emit('progress', progress);\n}\n\nfunction updateSlidesClasses() {\n  const swiper = this;\n  const {\n    slides,\n    params,\n    slidesEl,\n    activeIndex\n  } = swiper;\n  const isVirtual = swiper.virtual && params.virtual.enabled;\n  const getFilteredSlide = selector => {\n    return (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.e)(slidesEl, `.${params.slideClass}${selector}, swiper-slide${selector}`)[0];\n  };\n  slides.forEach(slideEl => {\n    slideEl.classList.remove(params.slideActiveClass, params.slideNextClass, params.slidePrevClass);\n  });\n  let activeSlide;\n  if (isVirtual) {\n    if (params.loop) {\n      let slideIndex = activeIndex - swiper.virtual.slidesBefore;\n      if (slideIndex < 0) slideIndex = swiper.virtual.slides.length + slideIndex;\n      if (slideIndex >= swiper.virtual.slides.length) slideIndex -= swiper.virtual.slides.length;\n      activeSlide = getFilteredSlide(`[data-swiper-slide-index=\"${slideIndex}\"]`);\n    } else {\n      activeSlide = getFilteredSlide(`[data-swiper-slide-index=\"${activeIndex}\"]`);\n    }\n  } else {\n    activeSlide = slides[activeIndex];\n  }\n  if (activeSlide) {\n    // Active classes\n    activeSlide.classList.add(params.slideActiveClass);\n\n    // Next Slide\n    let nextSlide = (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.m)(activeSlide, `.${params.slideClass}, swiper-slide`)[0];\n    if (params.loop && !nextSlide) {\n      nextSlide = slides[0];\n    }\n    if (nextSlide) {\n      nextSlide.classList.add(params.slideNextClass);\n    }\n    // Prev Slide\n    let prevSlide = (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.o)(activeSlide, `.${params.slideClass}, swiper-slide`)[0];\n    if (params.loop && !prevSlide === 0) {\n      prevSlide = slides[slides.length - 1];\n    }\n    if (prevSlide) {\n      prevSlide.classList.add(params.slidePrevClass);\n    }\n  }\n  swiper.emitSlidesClasses();\n}\n\nconst processLazyPreloader = (swiper, imageEl) => {\n  if (!swiper || swiper.destroyed || !swiper.params) return;\n  const slideSelector = () => swiper.isElement ? `swiper-slide` : `.${swiper.params.slideClass}`;\n  const slideEl = imageEl.closest(slideSelector());\n  if (slideEl) {\n    const lazyEl = slideEl.querySelector(`.${swiper.params.lazyPreloaderClass}`);\n    if (lazyEl) lazyEl.remove();\n  }\n};\nconst unlazy = (swiper, index) => {\n  if (!swiper.slides[index]) return;\n  const imageEl = swiper.slides[index].querySelector('[loading=\"lazy\"]');\n  if (imageEl) imageEl.removeAttribute('loading');\n};\nconst preload = swiper => {\n  if (!swiper || swiper.destroyed || !swiper.params) return;\n  let amount = swiper.params.lazyPreloadPrevNext;\n  const len = swiper.slides.length;\n  if (!len || !amount || amount < 0) return;\n  amount = Math.min(amount, len);\n  const slidesPerView = swiper.params.slidesPerView === 'auto' ? swiper.slidesPerViewDynamic() : Math.ceil(swiper.params.slidesPerView);\n  const activeIndex = swiper.activeIndex;\n  if (swiper.params.grid && swiper.params.grid.rows > 1) {\n    const activeColumn = activeIndex;\n    const preloadColumns = [activeColumn - amount];\n    preloadColumns.push(...Array.from({\n      length: amount\n    }).map((_, i) => {\n      return activeColumn + slidesPerView + i;\n    }));\n    swiper.slides.forEach((slideEl, i) => {\n      if (preloadColumns.includes(slideEl.column)) unlazy(swiper, i);\n    });\n    return;\n  }\n  const slideIndexLastInView = activeIndex + slidesPerView - 1;\n  if (swiper.params.rewind || swiper.params.loop) {\n    for (let i = activeIndex - amount; i <= slideIndexLastInView + amount; i += 1) {\n      const realIndex = (i % len + len) % len;\n      if (realIndex < activeIndex || realIndex > slideIndexLastInView) unlazy(swiper, realIndex);\n    }\n  } else {\n    for (let i = Math.max(activeIndex - amount, 0); i <= Math.min(slideIndexLastInView + amount, len - 1); i += 1) {\n      if (i !== activeIndex && (i > slideIndexLastInView || i < activeIndex)) {\n        unlazy(swiper, i);\n      }\n    }\n  }\n};\n\nfunction getActiveIndexByTranslate(swiper) {\n  const {\n    slidesGrid,\n    params\n  } = swiper;\n  const translate = swiper.rtlTranslate ? swiper.translate : -swiper.translate;\n  let activeIndex;\n  for (let i = 0; i < slidesGrid.length; i += 1) {\n    if (typeof slidesGrid[i + 1] !== 'undefined') {\n      if (translate >= slidesGrid[i] && translate < slidesGrid[i + 1] - (slidesGrid[i + 1] - slidesGrid[i]) / 2) {\n        activeIndex = i;\n      } else if (translate >= slidesGrid[i] && translate < slidesGrid[i + 1]) {\n        activeIndex = i + 1;\n      }\n    } else if (translate >= slidesGrid[i]) {\n      activeIndex = i;\n    }\n  }\n  // Normalize slideIndex\n  if (params.normalizeSlideIndex) {\n    if (activeIndex < 0 || typeof activeIndex === 'undefined') activeIndex = 0;\n  }\n  return activeIndex;\n}\nfunction updateActiveIndex(newActiveIndex) {\n  const swiper = this;\n  const translate = swiper.rtlTranslate ? swiper.translate : -swiper.translate;\n  const {\n    snapGrid,\n    params,\n    activeIndex: previousIndex,\n    realIndex: previousRealIndex,\n    snapIndex: previousSnapIndex\n  } = swiper;\n  let activeIndex = newActiveIndex;\n  let snapIndex;\n  const getVirtualRealIndex = aIndex => {\n    let realIndex = aIndex - swiper.virtual.slidesBefore;\n    if (realIndex < 0) {\n      realIndex = swiper.virtual.slides.length + realIndex;\n    }\n    if (realIndex >= swiper.virtual.slides.length) {\n      realIndex -= swiper.virtual.slides.length;\n    }\n    return realIndex;\n  };\n  if (typeof activeIndex === 'undefined') {\n    activeIndex = getActiveIndexByTranslate(swiper);\n  }\n  if (snapGrid.indexOf(translate) >= 0) {\n    snapIndex = snapGrid.indexOf(translate);\n  } else {\n    const skip = Math.min(params.slidesPerGroupSkip, activeIndex);\n    snapIndex = skip + Math.floor((activeIndex - skip) / params.slidesPerGroup);\n  }\n  if (snapIndex >= snapGrid.length) snapIndex = snapGrid.length - 1;\n  if (activeIndex === previousIndex) {\n    if (snapIndex !== previousSnapIndex) {\n      swiper.snapIndex = snapIndex;\n      swiper.emit('snapIndexChange');\n    }\n    if (swiper.params.loop && swiper.virtual && swiper.params.virtual.enabled) {\n      swiper.realIndex = getVirtualRealIndex(activeIndex);\n    }\n    return;\n  }\n  // Get real index\n  let realIndex;\n  if (swiper.virtual && params.virtual.enabled && params.loop) {\n    realIndex = getVirtualRealIndex(activeIndex);\n  } else if (swiper.slides[activeIndex]) {\n    realIndex = parseInt(swiper.slides[activeIndex].getAttribute('data-swiper-slide-index') || activeIndex, 10);\n  } else {\n    realIndex = activeIndex;\n  }\n  Object.assign(swiper, {\n    previousSnapIndex,\n    snapIndex,\n    previousRealIndex,\n    realIndex,\n    previousIndex,\n    activeIndex\n  });\n  if (swiper.initialized) {\n    preload(swiper);\n  }\n  swiper.emit('activeIndexChange');\n  swiper.emit('snapIndexChange');\n  if (previousRealIndex !== realIndex) {\n    swiper.emit('realIndexChange');\n  }\n  if (swiper.initialized || swiper.params.runCallbacksOnInit) {\n    swiper.emit('slideChange');\n  }\n}\n\nfunction updateClickedSlide(e) {\n  const swiper = this;\n  const params = swiper.params;\n  const slide = e.closest(`.${params.slideClass}, swiper-slide`);\n  let slideFound = false;\n  let slideIndex;\n  if (slide) {\n    for (let i = 0; i < swiper.slides.length; i += 1) {\n      if (swiper.slides[i] === slide) {\n        slideFound = true;\n        slideIndex = i;\n        break;\n      }\n    }\n  }\n  if (slide && slideFound) {\n    swiper.clickedSlide = slide;\n    if (swiper.virtual && swiper.params.virtual.enabled) {\n      swiper.clickedIndex = parseInt(slide.getAttribute('data-swiper-slide-index'), 10);\n    } else {\n      swiper.clickedIndex = slideIndex;\n    }\n  } else {\n    swiper.clickedSlide = undefined;\n    swiper.clickedIndex = undefined;\n    return;\n  }\n  if (params.slideToClickedSlide && swiper.clickedIndex !== undefined && swiper.clickedIndex !== swiper.activeIndex) {\n    swiper.slideToClickedSlide();\n  }\n}\n\nvar update = {\n  updateSize,\n  updateSlides,\n  updateAutoHeight,\n  updateSlidesOffset,\n  updateSlidesProgress,\n  updateProgress,\n  updateSlidesClasses,\n  updateActiveIndex,\n  updateClickedSlide\n};\n\nfunction getSwiperTranslate(axis) {\n  if (axis === void 0) {\n    axis = this.isHorizontal() ? 'x' : 'y';\n  }\n  const swiper = this;\n  const {\n    params,\n    rtlTranslate: rtl,\n    translate,\n    wrapperEl\n  } = swiper;\n  if (params.virtualTranslate) {\n    return rtl ? -translate : translate;\n  }\n  if (params.cssMode) {\n    return translate;\n  }\n  let currentTranslate = (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.h)(wrapperEl, axis);\n  currentTranslate += swiper.cssOverflowAdjustment();\n  if (rtl) currentTranslate = -currentTranslate;\n  return currentTranslate || 0;\n}\n\nfunction setTranslate(translate, byController) {\n  const swiper = this;\n  const {\n    rtlTranslate: rtl,\n    params,\n    wrapperEl,\n    progress\n  } = swiper;\n  let x = 0;\n  let y = 0;\n  const z = 0;\n  if (swiper.isHorizontal()) {\n    x = rtl ? -translate : translate;\n  } else {\n    y = translate;\n  }\n  if (params.roundLengths) {\n    x = Math.floor(x);\n    y = Math.floor(y);\n  }\n  swiper.previousTranslate = swiper.translate;\n  swiper.translate = swiper.isHorizontal() ? x : y;\n  if (params.cssMode) {\n    wrapperEl[swiper.isHorizontal() ? 'scrollLeft' : 'scrollTop'] = swiper.isHorizontal() ? -x : -y;\n  } else if (!params.virtualTranslate) {\n    if (swiper.isHorizontal()) {\n      x -= swiper.cssOverflowAdjustment();\n    } else {\n      y -= swiper.cssOverflowAdjustment();\n    }\n    wrapperEl.style.transform = `translate3d(${x}px, ${y}px, ${z}px)`;\n  }\n\n  // Check if we need to update progress\n  let newProgress;\n  const translatesDiff = swiper.maxTranslate() - swiper.minTranslate();\n  if (translatesDiff === 0) {\n    newProgress = 0;\n  } else {\n    newProgress = (translate - swiper.minTranslate()) / translatesDiff;\n  }\n  if (newProgress !== progress) {\n    swiper.updateProgress(translate);\n  }\n  swiper.emit('setTranslate', swiper.translate, byController);\n}\n\nfunction minTranslate() {\n  return -this.snapGrid[0];\n}\n\nfunction maxTranslate() {\n  return -this.snapGrid[this.snapGrid.length - 1];\n}\n\nfunction translateTo(translate, speed, runCallbacks, translateBounds, internal) {\n  if (translate === void 0) {\n    translate = 0;\n  }\n  if (speed === void 0) {\n    speed = this.params.speed;\n  }\n  if (runCallbacks === void 0) {\n    runCallbacks = true;\n  }\n  if (translateBounds === void 0) {\n    translateBounds = true;\n  }\n  const swiper = this;\n  const {\n    params,\n    wrapperEl\n  } = swiper;\n  if (swiper.animating && params.preventInteractionOnTransition) {\n    return false;\n  }\n  const minTranslate = swiper.minTranslate();\n  const maxTranslate = swiper.maxTranslate();\n  let newTranslate;\n  if (translateBounds && translate > minTranslate) newTranslate = minTranslate;else if (translateBounds && translate < maxTranslate) newTranslate = maxTranslate;else newTranslate = translate;\n\n  // Update progress\n  swiper.updateProgress(newTranslate);\n  if (params.cssMode) {\n    const isH = swiper.isHorizontal();\n    if (speed === 0) {\n      wrapperEl[isH ? 'scrollLeft' : 'scrollTop'] = -newTranslate;\n    } else {\n      if (!swiper.support.smoothScroll) {\n        (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.p)({\n          swiper,\n          targetPosition: -newTranslate,\n          side: isH ? 'left' : 'top'\n        });\n        return true;\n      }\n      wrapperEl.scrollTo({\n        [isH ? 'left' : 'top']: -newTranslate,\n        behavior: 'smooth'\n      });\n    }\n    return true;\n  }\n  if (speed === 0) {\n    swiper.setTransition(0);\n    swiper.setTranslate(newTranslate);\n    if (runCallbacks) {\n      swiper.emit('beforeTransitionStart', speed, internal);\n      swiper.emit('transitionEnd');\n    }\n  } else {\n    swiper.setTransition(speed);\n    swiper.setTranslate(newTranslate);\n    if (runCallbacks) {\n      swiper.emit('beforeTransitionStart', speed, internal);\n      swiper.emit('transitionStart');\n    }\n    if (!swiper.animating) {\n      swiper.animating = true;\n      if (!swiper.onTranslateToWrapperTransitionEnd) {\n        swiper.onTranslateToWrapperTransitionEnd = function transitionEnd(e) {\n          if (!swiper || swiper.destroyed) return;\n          if (e.target !== this) return;\n          swiper.wrapperEl.removeEventListener('transitionend', swiper.onTranslateToWrapperTransitionEnd);\n          swiper.onTranslateToWrapperTransitionEnd = null;\n          delete swiper.onTranslateToWrapperTransitionEnd;\n          if (runCallbacks) {\n            swiper.emit('transitionEnd');\n          }\n        };\n      }\n      swiper.wrapperEl.addEventListener('transitionend', swiper.onTranslateToWrapperTransitionEnd);\n    }\n  }\n  return true;\n}\n\nvar translate = {\n  getTranslate: getSwiperTranslate,\n  setTranslate,\n  minTranslate,\n  maxTranslate,\n  translateTo\n};\n\nfunction setTransition(duration, byController) {\n  const swiper = this;\n  if (!swiper.params.cssMode) {\n    swiper.wrapperEl.style.transitionDuration = `${duration}ms`;\n  }\n  swiper.emit('setTransition', duration, byController);\n}\n\nfunction transitionEmit(_ref) {\n  let {\n    swiper,\n    runCallbacks,\n    direction,\n    step\n  } = _ref;\n  const {\n    activeIndex,\n    previousIndex\n  } = swiper;\n  let dir = direction;\n  if (!dir) {\n    if (activeIndex > previousIndex) dir = 'next';else if (activeIndex < previousIndex) dir = 'prev';else dir = 'reset';\n  }\n  swiper.emit(`transition${step}`);\n  if (runCallbacks && activeIndex !== previousIndex) {\n    if (dir === 'reset') {\n      swiper.emit(`slideResetTransition${step}`);\n      return;\n    }\n    swiper.emit(`slideChangeTransition${step}`);\n    if (dir === 'next') {\n      swiper.emit(`slideNextTransition${step}`);\n    } else {\n      swiper.emit(`slidePrevTransition${step}`);\n    }\n  }\n}\n\nfunction transitionStart(runCallbacks, direction) {\n  if (runCallbacks === void 0) {\n    runCallbacks = true;\n  }\n  const swiper = this;\n  const {\n    params\n  } = swiper;\n  if (params.cssMode) return;\n  if (params.autoHeight) {\n    swiper.updateAutoHeight();\n  }\n  transitionEmit({\n    swiper,\n    runCallbacks,\n    direction,\n    step: 'Start'\n  });\n}\n\nfunction transitionEnd(runCallbacks, direction) {\n  if (runCallbacks === void 0) {\n    runCallbacks = true;\n  }\n  const swiper = this;\n  const {\n    params\n  } = swiper;\n  swiper.animating = false;\n  if (params.cssMode) return;\n  swiper.setTransition(0);\n  transitionEmit({\n    swiper,\n    runCallbacks,\n    direction,\n    step: 'End'\n  });\n}\n\nvar transition = {\n  setTransition,\n  transitionStart,\n  transitionEnd\n};\n\nfunction slideTo(index, speed, runCallbacks, internal, initial) {\n  if (index === void 0) {\n    index = 0;\n  }\n  if (speed === void 0) {\n    speed = this.params.speed;\n  }\n  if (runCallbacks === void 0) {\n    runCallbacks = true;\n  }\n  if (typeof index === 'string') {\n    index = parseInt(index, 10);\n  }\n  const swiper = this;\n  let slideIndex = index;\n  if (slideIndex < 0) slideIndex = 0;\n  const {\n    params,\n    snapGrid,\n    slidesGrid,\n    previousIndex,\n    activeIndex,\n    rtlTranslate: rtl,\n    wrapperEl,\n    enabled\n  } = swiper;\n  if (swiper.animating && params.preventInteractionOnTransition || !enabled && !internal && !initial) {\n    return false;\n  }\n  const skip = Math.min(swiper.params.slidesPerGroupSkip, slideIndex);\n  let snapIndex = skip + Math.floor((slideIndex - skip) / swiper.params.slidesPerGroup);\n  if (snapIndex >= snapGrid.length) snapIndex = snapGrid.length - 1;\n  const translate = -snapGrid[snapIndex];\n  // Normalize slideIndex\n  if (params.normalizeSlideIndex) {\n    for (let i = 0; i < slidesGrid.length; i += 1) {\n      const normalizedTranslate = -Math.floor(translate * 100);\n      const normalizedGrid = Math.floor(slidesGrid[i] * 100);\n      const normalizedGridNext = Math.floor(slidesGrid[i + 1] * 100);\n      if (typeof slidesGrid[i + 1] !== 'undefined') {\n        if (normalizedTranslate >= normalizedGrid && normalizedTranslate < normalizedGridNext - (normalizedGridNext - normalizedGrid) / 2) {\n          slideIndex = i;\n        } else if (normalizedTranslate >= normalizedGrid && normalizedTranslate < normalizedGridNext) {\n          slideIndex = i + 1;\n        }\n      } else if (normalizedTranslate >= normalizedGrid) {\n        slideIndex = i;\n      }\n    }\n  }\n  // Directions locks\n  if (swiper.initialized && slideIndex !== activeIndex) {\n    if (!swiper.allowSlideNext && (rtl ? translate > swiper.translate && translate > swiper.minTranslate() : translate < swiper.translate && translate < swiper.minTranslate())) {\n      return false;\n    }\n    if (!swiper.allowSlidePrev && translate > swiper.translate && translate > swiper.maxTranslate()) {\n      if ((activeIndex || 0) !== slideIndex) {\n        return false;\n      }\n    }\n  }\n  if (slideIndex !== (previousIndex || 0) && runCallbacks) {\n    swiper.emit('beforeSlideChangeStart');\n  }\n\n  // Update progress\n  swiper.updateProgress(translate);\n  let direction;\n  if (slideIndex > activeIndex) direction = 'next';else if (slideIndex < activeIndex) direction = 'prev';else direction = 'reset';\n\n  // Update Index\n  if (rtl && -translate === swiper.translate || !rtl && translate === swiper.translate) {\n    swiper.updateActiveIndex(slideIndex);\n    // Update Height\n    if (params.autoHeight) {\n      swiper.updateAutoHeight();\n    }\n    swiper.updateSlidesClasses();\n    if (params.effect !== 'slide') {\n      swiper.setTranslate(translate);\n    }\n    if (direction !== 'reset') {\n      swiper.transitionStart(runCallbacks, direction);\n      swiper.transitionEnd(runCallbacks, direction);\n    }\n    return false;\n  }\n  if (params.cssMode) {\n    const isH = swiper.isHorizontal();\n    const t = rtl ? translate : -translate;\n    if (speed === 0) {\n      const isVirtual = swiper.virtual && swiper.params.virtual.enabled;\n      if (isVirtual) {\n        swiper.wrapperEl.style.scrollSnapType = 'none';\n        swiper._immediateVirtual = true;\n      }\n      if (isVirtual && !swiper._cssModeVirtualInitialSet && swiper.params.initialSlide > 0) {\n        swiper._cssModeVirtualInitialSet = true;\n        requestAnimationFrame(() => {\n          wrapperEl[isH ? 'scrollLeft' : 'scrollTop'] = t;\n        });\n      } else {\n        wrapperEl[isH ? 'scrollLeft' : 'scrollTop'] = t;\n      }\n      if (isVirtual) {\n        requestAnimationFrame(() => {\n          swiper.wrapperEl.style.scrollSnapType = '';\n          swiper._immediateVirtual = false;\n        });\n      }\n    } else {\n      if (!swiper.support.smoothScroll) {\n        (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.p)({\n          swiper,\n          targetPosition: t,\n          side: isH ? 'left' : 'top'\n        });\n        return true;\n      }\n      wrapperEl.scrollTo({\n        [isH ? 'left' : 'top']: t,\n        behavior: 'smooth'\n      });\n    }\n    return true;\n  }\n  swiper.setTransition(speed);\n  swiper.setTranslate(translate);\n  swiper.updateActiveIndex(slideIndex);\n  swiper.updateSlidesClasses();\n  swiper.emit('beforeTransitionStart', speed, internal);\n  swiper.transitionStart(runCallbacks, direction);\n  if (speed === 0) {\n    swiper.transitionEnd(runCallbacks, direction);\n  } else if (!swiper.animating) {\n    swiper.animating = true;\n    if (!swiper.onSlideToWrapperTransitionEnd) {\n      swiper.onSlideToWrapperTransitionEnd = function transitionEnd(e) {\n        if (!swiper || swiper.destroyed) return;\n        if (e.target !== this) return;\n        swiper.wrapperEl.removeEventListener('transitionend', swiper.onSlideToWrapperTransitionEnd);\n        swiper.onSlideToWrapperTransitionEnd = null;\n        delete swiper.onSlideToWrapperTransitionEnd;\n        swiper.transitionEnd(runCallbacks, direction);\n      };\n    }\n    swiper.wrapperEl.addEventListener('transitionend', swiper.onSlideToWrapperTransitionEnd);\n  }\n  return true;\n}\n\nfunction slideToLoop(index, speed, runCallbacks, internal) {\n  if (index === void 0) {\n    index = 0;\n  }\n  if (speed === void 0) {\n    speed = this.params.speed;\n  }\n  if (runCallbacks === void 0) {\n    runCallbacks = true;\n  }\n  if (typeof index === 'string') {\n    const indexAsNumber = parseInt(index, 10);\n    index = indexAsNumber;\n  }\n  const swiper = this;\n  let newIndex = index;\n  if (swiper.params.loop) {\n    if (swiper.virtual && swiper.params.virtual.enabled) {\n      // eslint-disable-next-line\n      newIndex = newIndex + swiper.virtual.slidesBefore;\n    } else {\n      newIndex = swiper.getSlideIndexByData(newIndex);\n    }\n  }\n  return swiper.slideTo(newIndex, speed, runCallbacks, internal);\n}\n\n/* eslint no-unused-vars: \"off\" */\nfunction slideNext(speed, runCallbacks, internal) {\n  if (speed === void 0) {\n    speed = this.params.speed;\n  }\n  if (runCallbacks === void 0) {\n    runCallbacks = true;\n  }\n  const swiper = this;\n  const {\n    enabled,\n    params,\n    animating\n  } = swiper;\n  if (!enabled) return swiper;\n  let perGroup = params.slidesPerGroup;\n  if (params.slidesPerView === 'auto' && params.slidesPerGroup === 1 && params.slidesPerGroupAuto) {\n    perGroup = Math.max(swiper.slidesPerViewDynamic('current', true), 1);\n  }\n  const increment = swiper.activeIndex < params.slidesPerGroupSkip ? 1 : perGroup;\n  const isVirtual = swiper.virtual && params.virtual.enabled;\n  if (params.loop) {\n    if (animating && !isVirtual && params.loopPreventsSliding) return false;\n    swiper.loopFix({\n      direction: 'next'\n    });\n    // eslint-disable-next-line\n    swiper._clientLeft = swiper.wrapperEl.clientLeft;\n  }\n  if (params.rewind && swiper.isEnd) {\n    return swiper.slideTo(0, speed, runCallbacks, internal);\n  }\n  return swiper.slideTo(swiper.activeIndex + increment, speed, runCallbacks, internal);\n}\n\n/* eslint no-unused-vars: \"off\" */\nfunction slidePrev(speed, runCallbacks, internal) {\n  if (speed === void 0) {\n    speed = this.params.speed;\n  }\n  if (runCallbacks === void 0) {\n    runCallbacks = true;\n  }\n  const swiper = this;\n  const {\n    params,\n    snapGrid,\n    slidesGrid,\n    rtlTranslate,\n    enabled,\n    animating\n  } = swiper;\n  if (!enabled) return swiper;\n  const isVirtual = swiper.virtual && params.virtual.enabled;\n  if (params.loop) {\n    if (animating && !isVirtual && params.loopPreventsSliding) return false;\n    swiper.loopFix({\n      direction: 'prev'\n    });\n    // eslint-disable-next-line\n    swiper._clientLeft = swiper.wrapperEl.clientLeft;\n  }\n  const translate = rtlTranslate ? swiper.translate : -swiper.translate;\n  function normalize(val) {\n    if (val < 0) return -Math.floor(Math.abs(val));\n    return Math.floor(val);\n  }\n  const normalizedTranslate = normalize(translate);\n  const normalizedSnapGrid = snapGrid.map(val => normalize(val));\n  let prevSnap = snapGrid[normalizedSnapGrid.indexOf(normalizedTranslate) - 1];\n  if (typeof prevSnap === 'undefined' && params.cssMode) {\n    let prevSnapIndex;\n    snapGrid.forEach((snap, snapIndex) => {\n      if (normalizedTranslate >= snap) {\n        // prevSnap = snap;\n        prevSnapIndex = snapIndex;\n      }\n    });\n    if (typeof prevSnapIndex !== 'undefined') {\n      prevSnap = snapGrid[prevSnapIndex > 0 ? prevSnapIndex - 1 : prevSnapIndex];\n    }\n  }\n  let prevIndex = 0;\n  if (typeof prevSnap !== 'undefined') {\n    prevIndex = slidesGrid.indexOf(prevSnap);\n    if (prevIndex < 0) prevIndex = swiper.activeIndex - 1;\n    if (params.slidesPerView === 'auto' && params.slidesPerGroup === 1 && params.slidesPerGroupAuto) {\n      prevIndex = prevIndex - swiper.slidesPerViewDynamic('previous', true) + 1;\n      prevIndex = Math.max(prevIndex, 0);\n    }\n  }\n  if (params.rewind && swiper.isBeginning) {\n    const lastIndex = swiper.params.virtual && swiper.params.virtual.enabled && swiper.virtual ? swiper.virtual.slides.length - 1 : swiper.slides.length - 1;\n    return swiper.slideTo(lastIndex, speed, runCallbacks, internal);\n  }\n  return swiper.slideTo(prevIndex, speed, runCallbacks, internal);\n}\n\n/* eslint no-unused-vars: \"off\" */\nfunction slideReset(speed, runCallbacks, internal) {\n  if (speed === void 0) {\n    speed = this.params.speed;\n  }\n  if (runCallbacks === void 0) {\n    runCallbacks = true;\n  }\n  const swiper = this;\n  return swiper.slideTo(swiper.activeIndex, speed, runCallbacks, internal);\n}\n\n/* eslint no-unused-vars: \"off\" */\nfunction slideToClosest(speed, runCallbacks, internal, threshold) {\n  if (speed === void 0) {\n    speed = this.params.speed;\n  }\n  if (runCallbacks === void 0) {\n    runCallbacks = true;\n  }\n  if (threshold === void 0) {\n    threshold = 0.5;\n  }\n  const swiper = this;\n  let index = swiper.activeIndex;\n  const skip = Math.min(swiper.params.slidesPerGroupSkip, index);\n  const snapIndex = skip + Math.floor((index - skip) / swiper.params.slidesPerGroup);\n  const translate = swiper.rtlTranslate ? swiper.translate : -swiper.translate;\n  if (translate >= swiper.snapGrid[snapIndex]) {\n    // The current translate is on or after the current snap index, so the choice\n    // is between the current index and the one after it.\n    const currentSnap = swiper.snapGrid[snapIndex];\n    const nextSnap = swiper.snapGrid[snapIndex + 1];\n    if (translate - currentSnap > (nextSnap - currentSnap) * threshold) {\n      index += swiper.params.slidesPerGroup;\n    }\n  } else {\n    // The current translate is before the current snap index, so the choice\n    // is between the current index and the one before it.\n    const prevSnap = swiper.snapGrid[snapIndex - 1];\n    const currentSnap = swiper.snapGrid[snapIndex];\n    if (translate - prevSnap <= (currentSnap - prevSnap) * threshold) {\n      index -= swiper.params.slidesPerGroup;\n    }\n  }\n  index = Math.max(index, 0);\n  index = Math.min(index, swiper.slidesGrid.length - 1);\n  return swiper.slideTo(index, speed, runCallbacks, internal);\n}\n\nfunction slideToClickedSlide() {\n  const swiper = this;\n  const {\n    params,\n    slidesEl\n  } = swiper;\n  const slidesPerView = params.slidesPerView === 'auto' ? swiper.slidesPerViewDynamic() : params.slidesPerView;\n  let slideToIndex = swiper.clickedIndex;\n  let realIndex;\n  const slideSelector = swiper.isElement ? `swiper-slide` : `.${params.slideClass}`;\n  if (params.loop) {\n    if (swiper.animating) return;\n    realIndex = parseInt(swiper.clickedSlide.getAttribute('data-swiper-slide-index'), 10);\n    if (params.centeredSlides) {\n      if (slideToIndex < swiper.loopedSlides - slidesPerView / 2 || slideToIndex > swiper.slides.length - swiper.loopedSlides + slidesPerView / 2) {\n        swiper.loopFix();\n        slideToIndex = swiper.getSlideIndex((0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.e)(slidesEl, `${slideSelector}[data-swiper-slide-index=\"${realIndex}\"]`)[0]);\n        (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.n)(() => {\n          swiper.slideTo(slideToIndex);\n        });\n      } else {\n        swiper.slideTo(slideToIndex);\n      }\n    } else if (slideToIndex > swiper.slides.length - slidesPerView) {\n      swiper.loopFix();\n      slideToIndex = swiper.getSlideIndex((0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.e)(slidesEl, `${slideSelector}[data-swiper-slide-index=\"${realIndex}\"]`)[0]);\n      (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.n)(() => {\n        swiper.slideTo(slideToIndex);\n      });\n    } else {\n      swiper.slideTo(slideToIndex);\n    }\n  } else {\n    swiper.slideTo(slideToIndex);\n  }\n}\n\nvar slide = {\n  slideTo,\n  slideToLoop,\n  slideNext,\n  slidePrev,\n  slideReset,\n  slideToClosest,\n  slideToClickedSlide\n};\n\nfunction loopCreate(slideRealIndex) {\n  const swiper = this;\n  const {\n    params,\n    slidesEl\n  } = swiper;\n  if (!params.loop || swiper.virtual && swiper.params.virtual.enabled) return;\n  const slides = (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.e)(slidesEl, `.${params.slideClass}, swiper-slide`);\n  slides.forEach((el, index) => {\n    el.setAttribute('data-swiper-slide-index', index);\n  });\n  swiper.loopFix({\n    slideRealIndex,\n    direction: params.centeredSlides ? undefined : 'next'\n  });\n}\n\nfunction loopFix(_temp) {\n  let {\n    slideRealIndex,\n    slideTo = true,\n    direction,\n    setTranslate,\n    activeSlideIndex,\n    byController,\n    byMousewheel\n  } = _temp === void 0 ? {} : _temp;\n  const swiper = this;\n  if (!swiper.params.loop) return;\n  swiper.emit('beforeLoopFix');\n  const {\n    slides,\n    allowSlidePrev,\n    allowSlideNext,\n    slidesEl,\n    params\n  } = swiper;\n  swiper.allowSlidePrev = true;\n  swiper.allowSlideNext = true;\n  if (swiper.virtual && params.virtual.enabled) {\n    if (slideTo) {\n      if (!params.centeredSlides && swiper.snapIndex === 0) {\n        swiper.slideTo(swiper.virtual.slides.length, 0, false, true);\n      } else if (params.centeredSlides && swiper.snapIndex < params.slidesPerView) {\n        swiper.slideTo(swiper.virtual.slides.length + swiper.snapIndex, 0, false, true);\n      } else if (swiper.snapIndex === swiper.snapGrid.length - 1) {\n        swiper.slideTo(swiper.virtual.slidesBefore, 0, false, true);\n      }\n    }\n    swiper.allowSlidePrev = allowSlidePrev;\n    swiper.allowSlideNext = allowSlideNext;\n    swiper.emit('loopFix');\n    return;\n  }\n  const slidesPerView = params.slidesPerView === 'auto' ? swiper.slidesPerViewDynamic() : Math.ceil(parseFloat(params.slidesPerView, 10));\n  let loopedSlides = params.loopedSlides || slidesPerView;\n  if (loopedSlides % params.slidesPerGroup !== 0) {\n    loopedSlides += params.slidesPerGroup - loopedSlides % params.slidesPerGroup;\n  }\n  swiper.loopedSlides = loopedSlides;\n  const prependSlidesIndexes = [];\n  const appendSlidesIndexes = [];\n  let activeIndex = swiper.activeIndex;\n  if (typeof activeSlideIndex === 'undefined') {\n    activeSlideIndex = swiper.getSlideIndex(swiper.slides.filter(el => el.classList.contains(params.slideActiveClass))[0]);\n  } else {\n    activeIndex = activeSlideIndex;\n  }\n  const isNext = direction === 'next' || !direction;\n  const isPrev = direction === 'prev' || !direction;\n  let slidesPrepended = 0;\n  let slidesAppended = 0;\n  // prepend last slides before start\n  if (activeSlideIndex < loopedSlides) {\n    slidesPrepended = Math.max(loopedSlides - activeSlideIndex, params.slidesPerGroup);\n    for (let i = 0; i < loopedSlides - activeSlideIndex; i += 1) {\n      const index = i - Math.floor(i / slides.length) * slides.length;\n      prependSlidesIndexes.push(slides.length - index - 1);\n    }\n  } else if (activeSlideIndex /* + slidesPerView */ > swiper.slides.length - loopedSlides * 2) {\n    slidesAppended = Math.max(activeSlideIndex - (swiper.slides.length - loopedSlides * 2), params.slidesPerGroup);\n    for (let i = 0; i < slidesAppended; i += 1) {\n      const index = i - Math.floor(i / slides.length) * slides.length;\n      appendSlidesIndexes.push(index);\n    }\n  }\n  if (isPrev) {\n    prependSlidesIndexes.forEach(index => {\n      swiper.slides[index].swiperLoopMoveDOM = true;\n      slidesEl.prepend(swiper.slides[index]);\n      swiper.slides[index].swiperLoopMoveDOM = false;\n    });\n  }\n  if (isNext) {\n    appendSlidesIndexes.forEach(index => {\n      swiper.slides[index].swiperLoopMoveDOM = true;\n      slidesEl.append(swiper.slides[index]);\n      swiper.slides[index].swiperLoopMoveDOM = false;\n    });\n  }\n  swiper.recalcSlides();\n  if (params.slidesPerView === 'auto') {\n    swiper.updateSlides();\n  }\n  if (params.watchSlidesProgress) {\n    swiper.updateSlidesOffset();\n  }\n  if (slideTo) {\n    if (prependSlidesIndexes.length > 0 && isPrev) {\n      if (typeof slideRealIndex === 'undefined') {\n        const currentSlideTranslate = swiper.slidesGrid[activeIndex];\n        const newSlideTranslate = swiper.slidesGrid[activeIndex + slidesPrepended];\n        const diff = newSlideTranslate - currentSlideTranslate;\n        if (byMousewheel) {\n          swiper.setTranslate(swiper.translate - diff);\n        } else {\n          swiper.slideTo(activeIndex + slidesPrepended, 0, false, true);\n          if (setTranslate) {\n            swiper.touches[swiper.isHorizontal() ? 'startX' : 'startY'] += diff;\n          }\n        }\n      } else {\n        if (setTranslate) {\n          swiper.slideToLoop(slideRealIndex, 0, false, true);\n        }\n      }\n    } else if (appendSlidesIndexes.length > 0 && isNext) {\n      if (typeof slideRealIndex === 'undefined') {\n        const currentSlideTranslate = swiper.slidesGrid[activeIndex];\n        const newSlideTranslate = swiper.slidesGrid[activeIndex - slidesAppended];\n        const diff = newSlideTranslate - currentSlideTranslate;\n        if (byMousewheel) {\n          swiper.setTranslate(swiper.translate - diff);\n        } else {\n          swiper.slideTo(activeIndex - slidesAppended, 0, false, true);\n          if (setTranslate) {\n            swiper.touches[swiper.isHorizontal() ? 'startX' : 'startY'] += diff;\n          }\n        }\n      } else {\n        swiper.slideToLoop(slideRealIndex, 0, false, true);\n      }\n    }\n  }\n  swiper.allowSlidePrev = allowSlidePrev;\n  swiper.allowSlideNext = allowSlideNext;\n  if (swiper.controller && swiper.controller.control && !byController) {\n    const loopParams = {\n      slideRealIndex,\n      slideTo: false,\n      direction,\n      setTranslate,\n      activeSlideIndex,\n      byController: true\n    };\n    if (Array.isArray(swiper.controller.control)) {\n      swiper.controller.control.forEach(c => {\n        if (!c.destroyed && c.params.loop) c.loopFix(loopParams);\n      });\n    } else if (swiper.controller.control instanceof swiper.constructor && swiper.controller.control.params.loop) {\n      swiper.controller.control.loopFix(loopParams);\n    }\n  }\n  swiper.emit('loopFix');\n}\n\nfunction loopDestroy() {\n  const swiper = this;\n  const {\n    params,\n    slidesEl\n  } = swiper;\n  if (!params.loop || swiper.virtual && swiper.params.virtual.enabled) return;\n  swiper.recalcSlides();\n  const newSlidesOrder = [];\n  swiper.slides.forEach(slideEl => {\n    const index = typeof slideEl.swiperSlideIndex === 'undefined' ? slideEl.getAttribute('data-swiper-slide-index') * 1 : slideEl.swiperSlideIndex;\n    newSlidesOrder[index] = slideEl;\n  });\n  swiper.slides.forEach(slideEl => {\n    slideEl.removeAttribute('data-swiper-slide-index');\n  });\n  newSlidesOrder.forEach(slideEl => {\n    slidesEl.append(slideEl);\n  });\n  swiper.recalcSlides();\n  swiper.slideTo(swiper.realIndex, 0);\n}\n\nvar loop = {\n  loopCreate,\n  loopFix,\n  loopDestroy\n};\n\nfunction setGrabCursor(moving) {\n  const swiper = this;\n  if (!swiper.params.simulateTouch || swiper.params.watchOverflow && swiper.isLocked || swiper.params.cssMode) return;\n  const el = swiper.params.touchEventsTarget === 'container' ? swiper.el : swiper.wrapperEl;\n  if (swiper.isElement) {\n    swiper.__preventObserver__ = true;\n  }\n  el.style.cursor = 'move';\n  el.style.cursor = moving ? 'grabbing' : 'grab';\n  if (swiper.isElement) {\n    requestAnimationFrame(() => {\n      swiper.__preventObserver__ = false;\n    });\n  }\n}\n\nfunction unsetGrabCursor() {\n  const swiper = this;\n  if (swiper.params.watchOverflow && swiper.isLocked || swiper.params.cssMode) {\n    return;\n  }\n  if (swiper.isElement) {\n    swiper.__preventObserver__ = true;\n  }\n  swiper[swiper.params.touchEventsTarget === 'container' ? 'el' : 'wrapperEl'].style.cursor = '';\n  if (swiper.isElement) {\n    requestAnimationFrame(() => {\n      swiper.__preventObserver__ = false;\n    });\n  }\n}\n\nvar grabCursor = {\n  setGrabCursor,\n  unsetGrabCursor\n};\n\n// Modified from https://stackoverflow.com/questions/54520554/custom-element-getrootnode-closest-function-crossing-multiple-parent-shadowd\nfunction closestElement(selector, base) {\n  if (base === void 0) {\n    base = this;\n  }\n  function __closestFrom(el) {\n    if (!el || el === (0,_ssr_window_esm_mjs__WEBPACK_IMPORTED_MODULE_0__.g)() || el === (0,_ssr_window_esm_mjs__WEBPACK_IMPORTED_MODULE_0__.a)()) return null;\n    if (el.assignedSlot) el = el.assignedSlot;\n    const found = el.closest(selector);\n    if (!found && !el.getRootNode) {\n      return null;\n    }\n    return found || __closestFrom(el.getRootNode().host);\n  }\n  return __closestFrom(base);\n}\nfunction onTouchStart(event) {\n  const swiper = this;\n  const document = (0,_ssr_window_esm_mjs__WEBPACK_IMPORTED_MODULE_0__.g)();\n  const window = (0,_ssr_window_esm_mjs__WEBPACK_IMPORTED_MODULE_0__.a)();\n  const data = swiper.touchEventsData;\n  data.evCache.push(event);\n  const {\n    params,\n    touches,\n    enabled\n  } = swiper;\n  if (!enabled) return;\n  if (!params.simulateTouch && event.pointerType === 'mouse') return;\n  if (swiper.animating && params.preventInteractionOnTransition) {\n    return;\n  }\n  if (!swiper.animating && params.cssMode && params.loop) {\n    swiper.loopFix();\n  }\n  let e = event;\n  if (e.originalEvent) e = e.originalEvent;\n  let targetEl = e.target;\n  if (params.touchEventsTarget === 'wrapper') {\n    if (!swiper.wrapperEl.contains(targetEl)) return;\n  }\n  if ('which' in e && e.which === 3) return;\n  if ('button' in e && e.button > 0) return;\n  if (data.isTouched && data.isMoved) return;\n\n  // change target el for shadow root component\n  const swipingClassHasValue = !!params.noSwipingClass && params.noSwipingClass !== '';\n  // eslint-disable-next-line\n  const eventPath = event.composedPath ? event.composedPath() : event.path;\n  if (swipingClassHasValue && e.target && e.target.shadowRoot && eventPath) {\n    targetEl = eventPath[0];\n  }\n  const noSwipingSelector = params.noSwipingSelector ? params.noSwipingSelector : `.${params.noSwipingClass}`;\n  const isTargetShadow = !!(e.target && e.target.shadowRoot);\n\n  // use closestElement for shadow root element to get the actual closest for nested shadow root element\n  if (params.noSwiping && (isTargetShadow ? closestElement(noSwipingSelector, targetEl) : targetEl.closest(noSwipingSelector))) {\n    swiper.allowClick = true;\n    return;\n  }\n  if (params.swipeHandler) {\n    if (!targetEl.closest(params.swipeHandler)) return;\n  }\n  touches.currentX = e.pageX;\n  touches.currentY = e.pageY;\n  const startX = touches.currentX;\n  const startY = touches.currentY;\n\n  // Do NOT start if iOS edge swipe is detected. Otherwise iOS app cannot swipe-to-go-back anymore\n\n  const edgeSwipeDetection = params.edgeSwipeDetection || params.iOSEdgeSwipeDetection;\n  const edgeSwipeThreshold = params.edgeSwipeThreshold || params.iOSEdgeSwipeThreshold;\n  if (edgeSwipeDetection && (startX <= edgeSwipeThreshold || startX >= window.innerWidth - edgeSwipeThreshold)) {\n    if (edgeSwipeDetection === 'prevent') {\n      event.preventDefault();\n    } else {\n      return;\n    }\n  }\n  Object.assign(data, {\n    isTouched: true,\n    isMoved: false,\n    allowTouchCallbacks: true,\n    isScrolling: undefined,\n    startMoving: undefined\n  });\n  touches.startX = startX;\n  touches.startY = startY;\n  data.touchStartTime = (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.d)();\n  swiper.allowClick = true;\n  swiper.updateSize();\n  swiper.swipeDirection = undefined;\n  if (params.threshold > 0) data.allowThresholdMove = false;\n  let preventDefault = true;\n  if (targetEl.matches(data.focusableElements)) {\n    preventDefault = false;\n    if (targetEl.nodeName === 'SELECT') {\n      data.isTouched = false;\n    }\n  }\n  if (document.activeElement && document.activeElement.matches(data.focusableElements) && document.activeElement !== targetEl) {\n    document.activeElement.blur();\n  }\n  const shouldPreventDefault = preventDefault && swiper.allowTouchMove && params.touchStartPreventDefault;\n  if ((params.touchStartForcePreventDefault || shouldPreventDefault) && !targetEl.isContentEditable) {\n    e.preventDefault();\n  }\n  if (params.freeMode && params.freeMode.enabled && swiper.freeMode && swiper.animating && !params.cssMode) {\n    swiper.freeMode.onTouchStart();\n  }\n  swiper.emit('touchStart', e);\n}\n\nfunction onTouchMove(event) {\n  const document = (0,_ssr_window_esm_mjs__WEBPACK_IMPORTED_MODULE_0__.g)();\n  const swiper = this;\n  const data = swiper.touchEventsData;\n  const {\n    params,\n    touches,\n    rtlTranslate: rtl,\n    enabled\n  } = swiper;\n  if (!enabled) return;\n  if (!params.simulateTouch && event.pointerType === 'mouse') return;\n  let e = event;\n  if (e.originalEvent) e = e.originalEvent;\n  if (!data.isTouched) {\n    if (data.startMoving && data.isScrolling) {\n      swiper.emit('touchMoveOpposite', e);\n    }\n    return;\n  }\n  const pointerIndex = data.evCache.findIndex(cachedEv => cachedEv.pointerId === e.pointerId);\n  if (pointerIndex >= 0) data.evCache[pointerIndex] = e;\n  const targetTouch = data.evCache.length > 1 ? data.evCache[0] : e;\n  const pageX = targetTouch.pageX;\n  const pageY = targetTouch.pageY;\n  if (e.preventedByNestedSwiper) {\n    touches.startX = pageX;\n    touches.startY = pageY;\n    return;\n  }\n  if (!swiper.allowTouchMove) {\n    if (!e.target.matches(data.focusableElements)) {\n      swiper.allowClick = false;\n    }\n    if (data.isTouched) {\n      Object.assign(touches, {\n        startX: pageX,\n        startY: pageY,\n        prevX: swiper.touches.currentX,\n        prevY: swiper.touches.currentY,\n        currentX: pageX,\n        currentY: pageY\n      });\n      data.touchStartTime = (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.d)();\n    }\n    return;\n  }\n  if (params.touchReleaseOnEdges && !params.loop) {\n    if (swiper.isVertical()) {\n      // Vertical\n      if (pageY < touches.startY && swiper.translate <= swiper.maxTranslate() || pageY > touches.startY && swiper.translate >= swiper.minTranslate()) {\n        data.isTouched = false;\n        data.isMoved = false;\n        return;\n      }\n    } else if (pageX < touches.startX && swiper.translate <= swiper.maxTranslate() || pageX > touches.startX && swiper.translate >= swiper.minTranslate()) {\n      return;\n    }\n  }\n  if (document.activeElement) {\n    if (e.target === document.activeElement && e.target.matches(data.focusableElements)) {\n      data.isMoved = true;\n      swiper.allowClick = false;\n      return;\n    }\n  }\n  if (data.allowTouchCallbacks) {\n    swiper.emit('touchMove', e);\n  }\n  if (e.targetTouches && e.targetTouches.length > 1) return;\n  touches.currentX = pageX;\n  touches.currentY = pageY;\n  const diffX = touches.currentX - touches.startX;\n  const diffY = touches.currentY - touches.startY;\n  if (swiper.params.threshold && Math.sqrt(diffX ** 2 + diffY ** 2) < swiper.params.threshold) return;\n  if (typeof data.isScrolling === 'undefined') {\n    let touchAngle;\n    if (swiper.isHorizontal() && touches.currentY === touches.startY || swiper.isVertical() && touches.currentX === touches.startX) {\n      data.isScrolling = false;\n    } else {\n      // eslint-disable-next-line\n      if (diffX * diffX + diffY * diffY >= 25) {\n        touchAngle = Math.atan2(Math.abs(diffY), Math.abs(diffX)) * 180 / Math.PI;\n        data.isScrolling = swiper.isHorizontal() ? touchAngle > params.touchAngle : 90 - touchAngle > params.touchAngle;\n      }\n    }\n  }\n  if (data.isScrolling) {\n    swiper.emit('touchMoveOpposite', e);\n  }\n  if (typeof data.startMoving === 'undefined') {\n    if (touches.currentX !== touches.startX || touches.currentY !== touches.startY) {\n      data.startMoving = true;\n    }\n  }\n  if (data.isScrolling || swiper.zoom && swiper.params.zoom && swiper.params.zoom.enabled && data.evCache.length > 1) {\n    data.isTouched = false;\n    return;\n  }\n  if (!data.startMoving) {\n    return;\n  }\n  swiper.allowClick = false;\n  if (!params.cssMode && e.cancelable) {\n    e.preventDefault();\n  }\n  if (params.touchMoveStopPropagation && !params.nested) {\n    e.stopPropagation();\n  }\n  let diff = swiper.isHorizontal() ? diffX : diffY;\n  let touchesDiff = swiper.isHorizontal() ? touches.currentX - touches.previousX : touches.currentY - touches.previousY;\n  if (params.oneWayMovement) {\n    diff = Math.abs(diff) * (rtl ? 1 : -1);\n    touchesDiff = Math.abs(touchesDiff) * (rtl ? 1 : -1);\n  }\n  touches.diff = diff;\n  diff *= params.touchRatio;\n  if (rtl) {\n    diff = -diff;\n    touchesDiff = -touchesDiff;\n  }\n  const prevTouchesDirection = swiper.touchesDirection;\n  swiper.swipeDirection = diff > 0 ? 'prev' : 'next';\n  swiper.touchesDirection = touchesDiff > 0 ? 'prev' : 'next';\n  const isLoop = swiper.params.loop && !params.cssMode;\n  if (!data.isMoved) {\n    if (isLoop) {\n      swiper.loopFix({\n        direction: swiper.swipeDirection\n      });\n    }\n    data.startTranslate = swiper.getTranslate();\n    swiper.setTransition(0);\n    if (swiper.animating) {\n      const evt = new window.CustomEvent('transitionend', {\n        bubbles: true,\n        cancelable: true\n      });\n      swiper.wrapperEl.dispatchEvent(evt);\n    }\n    data.allowMomentumBounce = false;\n    // Grab Cursor\n    if (params.grabCursor && (swiper.allowSlideNext === true || swiper.allowSlidePrev === true)) {\n      swiper.setGrabCursor(true);\n    }\n    swiper.emit('sliderFirstMove', e);\n  }\n  let loopFixed;\n  if (data.isMoved && prevTouchesDirection !== swiper.touchesDirection && isLoop && Math.abs(diff) >= 1) {\n    // need another loop fix\n    swiper.loopFix({\n      direction: swiper.swipeDirection,\n      setTranslate: true\n    });\n    loopFixed = true;\n  }\n  swiper.emit('sliderMove', e);\n  data.isMoved = true;\n  data.currentTranslate = diff + data.startTranslate;\n  let disableParentSwiper = true;\n  let resistanceRatio = params.resistanceRatio;\n  if (params.touchReleaseOnEdges) {\n    resistanceRatio = 0;\n  }\n  if (diff > 0) {\n    if (isLoop && !loopFixed && data.currentTranslate > (params.centeredSlides ? swiper.minTranslate() - swiper.size / 2 : swiper.minTranslate())) {\n      swiper.loopFix({\n        direction: 'prev',\n        setTranslate: true,\n        activeSlideIndex: 0\n      });\n    }\n    if (data.currentTranslate > swiper.minTranslate()) {\n      disableParentSwiper = false;\n      if (params.resistance) {\n        data.currentTranslate = swiper.minTranslate() - 1 + (-swiper.minTranslate() + data.startTranslate + diff) ** resistanceRatio;\n      }\n    }\n  } else if (diff < 0) {\n    if (isLoop && !loopFixed && data.currentTranslate < (params.centeredSlides ? swiper.maxTranslate() + swiper.size / 2 : swiper.maxTranslate())) {\n      swiper.loopFix({\n        direction: 'next',\n        setTranslate: true,\n        activeSlideIndex: swiper.slides.length - (params.slidesPerView === 'auto' ? swiper.slidesPerViewDynamic() : Math.ceil(parseFloat(params.slidesPerView, 10)))\n      });\n    }\n    if (data.currentTranslate < swiper.maxTranslate()) {\n      disableParentSwiper = false;\n      if (params.resistance) {\n        data.currentTranslate = swiper.maxTranslate() + 1 - (swiper.maxTranslate() - data.startTranslate - diff) ** resistanceRatio;\n      }\n    }\n  }\n  if (disableParentSwiper) {\n    e.preventedByNestedSwiper = true;\n  }\n\n  // Directions locks\n  if (!swiper.allowSlideNext && swiper.swipeDirection === 'next' && data.currentTranslate < data.startTranslate) {\n    data.currentTranslate = data.startTranslate;\n  }\n  if (!swiper.allowSlidePrev && swiper.swipeDirection === 'prev' && data.currentTranslate > data.startTranslate) {\n    data.currentTranslate = data.startTranslate;\n  }\n  if (!swiper.allowSlidePrev && !swiper.allowSlideNext) {\n    data.currentTranslate = data.startTranslate;\n  }\n\n  // Threshold\n  if (params.threshold > 0) {\n    if (Math.abs(diff) > params.threshold || data.allowThresholdMove) {\n      if (!data.allowThresholdMove) {\n        data.allowThresholdMove = true;\n        touches.startX = touches.currentX;\n        touches.startY = touches.currentY;\n        data.currentTranslate = data.startTranslate;\n        touches.diff = swiper.isHorizontal() ? touches.currentX - touches.startX : touches.currentY - touches.startY;\n        return;\n      }\n    } else {\n      data.currentTranslate = data.startTranslate;\n      return;\n    }\n  }\n  if (!params.followFinger || params.cssMode) return;\n\n  // Update active index in free mode\n  if (params.freeMode && params.freeMode.enabled && swiper.freeMode || params.watchSlidesProgress) {\n    swiper.updateActiveIndex();\n    swiper.updateSlidesClasses();\n  }\n  if (params.freeMode && params.freeMode.enabled && swiper.freeMode) {\n    swiper.freeMode.onTouchMove();\n  }\n  // Update progress\n  swiper.updateProgress(data.currentTranslate);\n  // Update translate\n  swiper.setTranslate(data.currentTranslate);\n}\n\nfunction onTouchEnd(event) {\n  const swiper = this;\n  const data = swiper.touchEventsData;\n  const pointerIndex = data.evCache.findIndex(cachedEv => cachedEv.pointerId === event.pointerId);\n  if (pointerIndex >= 0) {\n    data.evCache.splice(pointerIndex, 1);\n  }\n  if (['pointercancel', 'pointerout', 'pointerleave'].includes(event.type)) {\n    const proceed = event.type === 'pointercancel' && (swiper.browser.isSafari || swiper.browser.isWebView);\n    if (!proceed) {\n      return;\n    }\n  }\n  const {\n    params,\n    touches,\n    rtlTranslate: rtl,\n    slidesGrid,\n    enabled\n  } = swiper;\n  if (!enabled) return;\n  if (!params.simulateTouch && event.pointerType === 'mouse') return;\n  let e = event;\n  if (e.originalEvent) e = e.originalEvent;\n  if (data.allowTouchCallbacks) {\n    swiper.emit('touchEnd', e);\n  }\n  data.allowTouchCallbacks = false;\n  if (!data.isTouched) {\n    if (data.isMoved && params.grabCursor) {\n      swiper.setGrabCursor(false);\n    }\n    data.isMoved = false;\n    data.startMoving = false;\n    return;\n  }\n  // Return Grab Cursor\n  if (params.grabCursor && data.isMoved && data.isTouched && (swiper.allowSlideNext === true || swiper.allowSlidePrev === true)) {\n    swiper.setGrabCursor(false);\n  }\n\n  // Time diff\n  const touchEndTime = (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.d)();\n  const timeDiff = touchEndTime - data.touchStartTime;\n\n  // Tap, doubleTap, Click\n  if (swiper.allowClick) {\n    const pathTree = e.path || e.composedPath && e.composedPath();\n    swiper.updateClickedSlide(pathTree && pathTree[0] || e.target);\n    swiper.emit('tap click', e);\n    if (timeDiff < 300 && touchEndTime - data.lastClickTime < 300) {\n      swiper.emit('doubleTap doubleClick', e);\n    }\n  }\n  data.lastClickTime = (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.d)();\n  (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.n)(() => {\n    if (!swiper.destroyed) swiper.allowClick = true;\n  });\n  if (!data.isTouched || !data.isMoved || !swiper.swipeDirection || touches.diff === 0 || data.currentTranslate === data.startTranslate) {\n    data.isTouched = false;\n    data.isMoved = false;\n    data.startMoving = false;\n    return;\n  }\n  data.isTouched = false;\n  data.isMoved = false;\n  data.startMoving = false;\n  let currentPos;\n  if (params.followFinger) {\n    currentPos = rtl ? swiper.translate : -swiper.translate;\n  } else {\n    currentPos = -data.currentTranslate;\n  }\n  if (params.cssMode) {\n    return;\n  }\n  if (params.freeMode && params.freeMode.enabled) {\n    swiper.freeMode.onTouchEnd({\n      currentPos\n    });\n    return;\n  }\n\n  // Find current slide\n  let stopIndex = 0;\n  let groupSize = swiper.slidesSizesGrid[0];\n  for (let i = 0; i < slidesGrid.length; i += i < params.slidesPerGroupSkip ? 1 : params.slidesPerGroup) {\n    const increment = i < params.slidesPerGroupSkip - 1 ? 1 : params.slidesPerGroup;\n    if (typeof slidesGrid[i + increment] !== 'undefined') {\n      if (currentPos >= slidesGrid[i] && currentPos < slidesGrid[i + increment]) {\n        stopIndex = i;\n        groupSize = slidesGrid[i + increment] - slidesGrid[i];\n      }\n    } else if (currentPos >= slidesGrid[i]) {\n      stopIndex = i;\n      groupSize = slidesGrid[slidesGrid.length - 1] - slidesGrid[slidesGrid.length - 2];\n    }\n  }\n  let rewindFirstIndex = null;\n  let rewindLastIndex = null;\n  if (params.rewind) {\n    if (swiper.isBeginning) {\n      rewindLastIndex = params.virtual && params.virtual.enabled && swiper.virtual ? swiper.virtual.slides.length - 1 : swiper.slides.length - 1;\n    } else if (swiper.isEnd) {\n      rewindFirstIndex = 0;\n    }\n  }\n  // Find current slide size\n  const ratio = (currentPos - slidesGrid[stopIndex]) / groupSize;\n  const increment = stopIndex < params.slidesPerGroupSkip - 1 ? 1 : params.slidesPerGroup;\n  if (timeDiff > params.longSwipesMs) {\n    // Long touches\n    if (!params.longSwipes) {\n      swiper.slideTo(swiper.activeIndex);\n      return;\n    }\n    if (swiper.swipeDirection === 'next') {\n      if (ratio >= params.longSwipesRatio) swiper.slideTo(params.rewind && swiper.isEnd ? rewindFirstIndex : stopIndex + increment);else swiper.slideTo(stopIndex);\n    }\n    if (swiper.swipeDirection === 'prev') {\n      if (ratio > 1 - params.longSwipesRatio) {\n        swiper.slideTo(stopIndex + increment);\n      } else if (rewindLastIndex !== null && ratio < 0 && Math.abs(ratio) > params.longSwipesRatio) {\n        swiper.slideTo(rewindLastIndex);\n      } else {\n        swiper.slideTo(stopIndex);\n      }\n    }\n  } else {\n    // Short swipes\n    if (!params.shortSwipes) {\n      swiper.slideTo(swiper.activeIndex);\n      return;\n    }\n    const isNavButtonTarget = swiper.navigation && (e.target === swiper.navigation.nextEl || e.target === swiper.navigation.prevEl);\n    if (!isNavButtonTarget) {\n      if (swiper.swipeDirection === 'next') {\n        swiper.slideTo(rewindFirstIndex !== null ? rewindFirstIndex : stopIndex + increment);\n      }\n      if (swiper.swipeDirection === 'prev') {\n        swiper.slideTo(rewindLastIndex !== null ? rewindLastIndex : stopIndex);\n      }\n    } else if (e.target === swiper.navigation.nextEl) {\n      swiper.slideTo(stopIndex + increment);\n    } else {\n      swiper.slideTo(stopIndex);\n    }\n  }\n}\n\nfunction onResize() {\n  const swiper = this;\n  const {\n    params,\n    el\n  } = swiper;\n  if (el && el.offsetWidth === 0) return;\n\n  // Breakpoints\n  if (params.breakpoints) {\n    swiper.setBreakpoint();\n  }\n\n  // Save locks\n  const {\n    allowSlideNext,\n    allowSlidePrev,\n    snapGrid\n  } = swiper;\n  const isVirtual = swiper.virtual && swiper.params.virtual.enabled;\n\n  // Disable locks on resize\n  swiper.allowSlideNext = true;\n  swiper.allowSlidePrev = true;\n  swiper.updateSize();\n  swiper.updateSlides();\n  swiper.updateSlidesClasses();\n  const isVirtualLoop = isVirtual && params.loop;\n  if ((params.slidesPerView === 'auto' || params.slidesPerView > 1) && swiper.isEnd && !swiper.isBeginning && !swiper.params.centeredSlides && !isVirtualLoop) {\n    swiper.slideTo(swiper.slides.length - 1, 0, false, true);\n  } else {\n    if (swiper.params.loop && !isVirtual) {\n      swiper.slideToLoop(swiper.realIndex, 0, false, true);\n    } else {\n      swiper.slideTo(swiper.activeIndex, 0, false, true);\n    }\n  }\n  if (swiper.autoplay && swiper.autoplay.running && swiper.autoplay.paused) {\n    clearTimeout(swiper.autoplay.resizeTimeout);\n    swiper.autoplay.resizeTimeout = setTimeout(() => {\n      if (swiper.autoplay && swiper.autoplay.running && swiper.autoplay.paused) {\n        swiper.autoplay.resume();\n      }\n    }, 500);\n  }\n  // Return locks after resize\n  swiper.allowSlidePrev = allowSlidePrev;\n  swiper.allowSlideNext = allowSlideNext;\n  if (swiper.params.watchOverflow && snapGrid !== swiper.snapGrid) {\n    swiper.checkOverflow();\n  }\n}\n\nfunction onClick(e) {\n  const swiper = this;\n  if (!swiper.enabled) return;\n  if (!swiper.allowClick) {\n    if (swiper.params.preventClicks) e.preventDefault();\n    if (swiper.params.preventClicksPropagation && swiper.animating) {\n      e.stopPropagation();\n      e.stopImmediatePropagation();\n    }\n  }\n}\n\nfunction onScroll() {\n  const swiper = this;\n  const {\n    wrapperEl,\n    rtlTranslate,\n    enabled\n  } = swiper;\n  if (!enabled) return;\n  swiper.previousTranslate = swiper.translate;\n  if (swiper.isHorizontal()) {\n    swiper.translate = -wrapperEl.scrollLeft;\n  } else {\n    swiper.translate = -wrapperEl.scrollTop;\n  }\n  // eslint-disable-next-line\n  if (swiper.translate === 0) swiper.translate = 0;\n  swiper.updateActiveIndex();\n  swiper.updateSlidesClasses();\n  let newProgress;\n  const translatesDiff = swiper.maxTranslate() - swiper.minTranslate();\n  if (translatesDiff === 0) {\n    newProgress = 0;\n  } else {\n    newProgress = (swiper.translate - swiper.minTranslate()) / translatesDiff;\n  }\n  if (newProgress !== swiper.progress) {\n    swiper.updateProgress(rtlTranslate ? -swiper.translate : swiper.translate);\n  }\n  swiper.emit('setTranslate', swiper.translate, false);\n}\n\nfunction onLoad(e) {\n  const swiper = this;\n  processLazyPreloader(swiper, e.target);\n  if (swiper.params.cssMode || swiper.params.slidesPerView !== 'auto' && !swiper.params.autoHeight) {\n    return;\n  }\n  swiper.update();\n}\n\nlet dummyEventAttached = false;\nfunction dummyEventListener() {}\nconst events = (swiper, method) => {\n  const document = (0,_ssr_window_esm_mjs__WEBPACK_IMPORTED_MODULE_0__.g)();\n  const {\n    params,\n    el,\n    wrapperEl,\n    device\n  } = swiper;\n  const capture = !!params.nested;\n  const domMethod = method === 'on' ? 'addEventListener' : 'removeEventListener';\n  const swiperMethod = method;\n\n  // Touch Events\n  el[domMethod]('pointerdown', swiper.onTouchStart, {\n    passive: false\n  });\n  document[domMethod]('pointermove', swiper.onTouchMove, {\n    passive: false,\n    capture\n  });\n  document[domMethod]('pointerup', swiper.onTouchEnd, {\n    passive: true\n  });\n  document[domMethod]('pointercancel', swiper.onTouchEnd, {\n    passive: true\n  });\n  document[domMethod]('pointerout', swiper.onTouchEnd, {\n    passive: true\n  });\n  document[domMethod]('pointerleave', swiper.onTouchEnd, {\n    passive: true\n  });\n\n  // Prevent Links Clicks\n  if (params.preventClicks || params.preventClicksPropagation) {\n    el[domMethod]('click', swiper.onClick, true);\n  }\n  if (params.cssMode) {\n    wrapperEl[domMethod]('scroll', swiper.onScroll);\n  }\n\n  // Resize handler\n  if (params.updateOnWindowResize) {\n    swiper[swiperMethod](device.ios || device.android ? 'resize orientationchange observerUpdate' : 'resize observerUpdate', onResize, true);\n  } else {\n    swiper[swiperMethod]('observerUpdate', onResize, true);\n  }\n\n  // Images loader\n  el[domMethod]('load', swiper.onLoad, {\n    capture: true\n  });\n};\nfunction attachEvents() {\n  const swiper = this;\n  const document = (0,_ssr_window_esm_mjs__WEBPACK_IMPORTED_MODULE_0__.g)();\n  const {\n    params\n  } = swiper;\n  swiper.onTouchStart = onTouchStart.bind(swiper);\n  swiper.onTouchMove = onTouchMove.bind(swiper);\n  swiper.onTouchEnd = onTouchEnd.bind(swiper);\n  if (params.cssMode) {\n    swiper.onScroll = onScroll.bind(swiper);\n  }\n  swiper.onClick = onClick.bind(swiper);\n  swiper.onLoad = onLoad.bind(swiper);\n  if (!dummyEventAttached) {\n    document.addEventListener('touchstart', dummyEventListener);\n    dummyEventAttached = true;\n  }\n  events(swiper, 'on');\n}\nfunction detachEvents() {\n  const swiper = this;\n  events(swiper, 'off');\n}\nvar events$1 = {\n  attachEvents,\n  detachEvents\n};\n\nconst isGridEnabled = (swiper, params) => {\n  return swiper.grid && params.grid && params.grid.rows > 1;\n};\nfunction setBreakpoint() {\n  const swiper = this;\n  const {\n    realIndex,\n    initialized,\n    params,\n    el\n  } = swiper;\n  const breakpoints = params.breakpoints;\n  if (!breakpoints || breakpoints && Object.keys(breakpoints).length === 0) return;\n\n  // Get breakpoint for window width and update parameters\n  const breakpoint = swiper.getBreakpoint(breakpoints, swiper.params.breakpointsBase, swiper.el);\n  if (!breakpoint || swiper.currentBreakpoint === breakpoint) return;\n  const breakpointOnlyParams = breakpoint in breakpoints ? breakpoints[breakpoint] : undefined;\n  const breakpointParams = breakpointOnlyParams || swiper.originalParams;\n  const wasMultiRow = isGridEnabled(swiper, params);\n  const isMultiRow = isGridEnabled(swiper, breakpointParams);\n  const wasEnabled = params.enabled;\n  if (wasMultiRow && !isMultiRow) {\n    el.classList.remove(`${params.containerModifierClass}grid`, `${params.containerModifierClass}grid-column`);\n    swiper.emitContainerClasses();\n  } else if (!wasMultiRow && isMultiRow) {\n    el.classList.add(`${params.containerModifierClass}grid`);\n    if (breakpointParams.grid.fill && breakpointParams.grid.fill === 'column' || !breakpointParams.grid.fill && params.grid.fill === 'column') {\n      el.classList.add(`${params.containerModifierClass}grid-column`);\n    }\n    swiper.emitContainerClasses();\n  }\n\n  // Toggle navigation, pagination, scrollbar\n  ['navigation', 'pagination', 'scrollbar'].forEach(prop => {\n    if (typeof breakpointParams[prop] === 'undefined') return;\n    const wasModuleEnabled = params[prop] && params[prop].enabled;\n    const isModuleEnabled = breakpointParams[prop] && breakpointParams[prop].enabled;\n    if (wasModuleEnabled && !isModuleEnabled) {\n      swiper[prop].disable();\n    }\n    if (!wasModuleEnabled && isModuleEnabled) {\n      swiper[prop].enable();\n    }\n  });\n  const directionChanged = breakpointParams.direction && breakpointParams.direction !== params.direction;\n  const needsReLoop = params.loop && (breakpointParams.slidesPerView !== params.slidesPerView || directionChanged);\n  if (directionChanged && initialized) {\n    swiper.changeDirection();\n  }\n  (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.q)(swiper.params, breakpointParams);\n  const isEnabled = swiper.params.enabled;\n  Object.assign(swiper, {\n    allowTouchMove: swiper.params.allowTouchMove,\n    allowSlideNext: swiper.params.allowSlideNext,\n    allowSlidePrev: swiper.params.allowSlidePrev\n  });\n  if (wasEnabled && !isEnabled) {\n    swiper.disable();\n  } else if (!wasEnabled && isEnabled) {\n    swiper.enable();\n  }\n  swiper.currentBreakpoint = breakpoint;\n  swiper.emit('_beforeBreakpoint', breakpointParams);\n  if (needsReLoop && initialized) {\n    swiper.loopDestroy();\n    swiper.loopCreate(realIndex);\n    swiper.updateSlides();\n  }\n  swiper.emit('breakpoint', breakpointParams);\n}\n\nfunction getBreakpoint(breakpoints, base, containerEl) {\n  if (base === void 0) {\n    base = 'window';\n  }\n  if (!breakpoints || base === 'container' && !containerEl) return undefined;\n  let breakpoint = false;\n  const window = (0,_ssr_window_esm_mjs__WEBPACK_IMPORTED_MODULE_0__.a)();\n  const currentHeight = base === 'window' ? window.innerHeight : containerEl.clientHeight;\n  const points = Object.keys(breakpoints).map(point => {\n    if (typeof point === 'string' && point.indexOf('@') === 0) {\n      const minRatio = parseFloat(point.substr(1));\n      const value = currentHeight * minRatio;\n      return {\n        value,\n        point\n      };\n    }\n    return {\n      value: point,\n      point\n    };\n  });\n  points.sort((a, b) => parseInt(a.value, 10) - parseInt(b.value, 10));\n  for (let i = 0; i < points.length; i += 1) {\n    const {\n      point,\n      value\n    } = points[i];\n    if (base === 'window') {\n      if (window.matchMedia(`(min-width: ${value}px)`).matches) {\n        breakpoint = point;\n      }\n    } else if (value <= containerEl.clientWidth) {\n      breakpoint = point;\n    }\n  }\n  return breakpoint || 'max';\n}\n\nvar breakpoints = {\n  setBreakpoint,\n  getBreakpoint\n};\n\nfunction prepareClasses(entries, prefix) {\n  const resultClasses = [];\n  entries.forEach(item => {\n    if (typeof item === 'object') {\n      Object.keys(item).forEach(classNames => {\n        if (item[classNames]) {\n          resultClasses.push(prefix + classNames);\n        }\n      });\n    } else if (typeof item === 'string') {\n      resultClasses.push(prefix + item);\n    }\n  });\n  return resultClasses;\n}\nfunction addClasses() {\n  const swiper = this;\n  const {\n    classNames,\n    params,\n    rtl,\n    el,\n    device\n  } = swiper;\n  // prettier-ignore\n  const suffixes = prepareClasses(['initialized', params.direction, {\n    'free-mode': swiper.params.freeMode && params.freeMode.enabled\n  }, {\n    'autoheight': params.autoHeight\n  }, {\n    'rtl': rtl\n  }, {\n    'grid': params.grid && params.grid.rows > 1\n  }, {\n    'grid-column': params.grid && params.grid.rows > 1 && params.grid.fill === 'column'\n  }, {\n    'android': device.android\n  }, {\n    'ios': device.ios\n  }, {\n    'css-mode': params.cssMode\n  }, {\n    'centered': params.cssMode && params.centeredSlides\n  }, {\n    'watch-progress': params.watchSlidesProgress\n  }], params.containerModifierClass);\n  classNames.push(...suffixes);\n  el.classList.add(...classNames);\n  swiper.emitContainerClasses();\n}\n\nfunction removeClasses() {\n  const swiper = this;\n  const {\n    el,\n    classNames\n  } = swiper;\n  el.classList.remove(...classNames);\n  swiper.emitContainerClasses();\n}\n\nvar classes = {\n  addClasses,\n  removeClasses\n};\n\nfunction checkOverflow() {\n  const swiper = this;\n  const {\n    isLocked: wasLocked,\n    params\n  } = swiper;\n  const {\n    slidesOffsetBefore\n  } = params;\n  if (slidesOffsetBefore) {\n    const lastSlideIndex = swiper.slides.length - 1;\n    const lastSlideRightEdge = swiper.slidesGrid[lastSlideIndex] + swiper.slidesSizesGrid[lastSlideIndex] + slidesOffsetBefore * 2;\n    swiper.isLocked = swiper.size > lastSlideRightEdge;\n  } else {\n    swiper.isLocked = swiper.snapGrid.length === 1;\n  }\n  if (params.allowSlideNext === true) {\n    swiper.allowSlideNext = !swiper.isLocked;\n  }\n  if (params.allowSlidePrev === true) {\n    swiper.allowSlidePrev = !swiper.isLocked;\n  }\n  if (wasLocked && wasLocked !== swiper.isLocked) {\n    swiper.isEnd = false;\n  }\n  if (wasLocked !== swiper.isLocked) {\n    swiper.emit(swiper.isLocked ? 'lock' : 'unlock');\n  }\n}\nvar checkOverflow$1 = {\n  checkOverflow\n};\n\nvar defaults = {\n  init: true,\n  direction: 'horizontal',\n  oneWayMovement: false,\n  touchEventsTarget: 'wrapper',\n  initialSlide: 0,\n  speed: 300,\n  cssMode: false,\n  updateOnWindowResize: true,\n  resizeObserver: true,\n  nested: false,\n  createElements: false,\n  enabled: true,\n  focusableElements: 'input, select, option, textarea, button, video, label',\n  // Overrides\n  width: null,\n  height: null,\n  //\n  preventInteractionOnTransition: false,\n  // ssr\n  userAgent: null,\n  url: null,\n  // To support iOS's swipe-to-go-back gesture (when being used in-app).\n  edgeSwipeDetection: false,\n  edgeSwipeThreshold: 20,\n  // Autoheight\n  autoHeight: false,\n  // Set wrapper width\n  setWrapperSize: false,\n  // Virtual Translate\n  virtualTranslate: false,\n  // Effects\n  effect: 'slide',\n  // 'slide' or 'fade' or 'cube' or 'coverflow' or 'flip'\n\n  // Breakpoints\n  breakpoints: undefined,\n  breakpointsBase: 'window',\n  // Slides grid\n  spaceBetween: 0,\n  slidesPerView: 1,\n  slidesPerGroup: 1,\n  slidesPerGroupSkip: 0,\n  slidesPerGroupAuto: false,\n  centeredSlides: false,\n  centeredSlidesBounds: false,\n  slidesOffsetBefore: 0,\n  // in px\n  slidesOffsetAfter: 0,\n  // in px\n  normalizeSlideIndex: true,\n  centerInsufficientSlides: false,\n  // Disable swiper and hide navigation when container not overflow\n  watchOverflow: true,\n  // Round length\n  roundLengths: false,\n  // Touches\n  touchRatio: 1,\n  touchAngle: 45,\n  simulateTouch: true,\n  shortSwipes: true,\n  longSwipes: true,\n  longSwipesRatio: 0.5,\n  longSwipesMs: 300,\n  followFinger: true,\n  allowTouchMove: true,\n  threshold: 5,\n  touchMoveStopPropagation: false,\n  touchStartPreventDefault: true,\n  touchStartForcePreventDefault: false,\n  touchReleaseOnEdges: false,\n  // Unique Navigation Elements\n  uniqueNavElements: true,\n  // Resistance\n  resistance: true,\n  resistanceRatio: 0.85,\n  // Progress\n  watchSlidesProgress: false,\n  // Cursor\n  grabCursor: false,\n  // Clicks\n  preventClicks: true,\n  preventClicksPropagation: true,\n  slideToClickedSlide: false,\n  // loop\n  loop: false,\n  loopedSlides: null,\n  loopPreventsSliding: true,\n  // rewind\n  rewind: false,\n  // Swiping/no swiping\n  allowSlidePrev: true,\n  allowSlideNext: true,\n  swipeHandler: null,\n  // '.swipe-handler',\n  noSwiping: true,\n  noSwipingClass: 'swiper-no-swiping',\n  noSwipingSelector: null,\n  // Passive Listeners\n  passiveListeners: true,\n  maxBackfaceHiddenSlides: 10,\n  // NS\n  containerModifierClass: 'swiper-',\n  // NEW\n  slideClass: 'swiper-slide',\n  slideActiveClass: 'swiper-slide-active',\n  slideVisibleClass: 'swiper-slide-visible',\n  slideNextClass: 'swiper-slide-next',\n  slidePrevClass: 'swiper-slide-prev',\n  wrapperClass: 'swiper-wrapper',\n  lazyPreloaderClass: 'swiper-lazy-preloader',\n  lazyPreloadPrevNext: 0,\n  // Callbacks\n  runCallbacksOnInit: true,\n  // Internals\n  _emitClasses: false\n};\n\nfunction moduleExtendParams(params, allModulesParams) {\n  return function extendParams(obj) {\n    if (obj === void 0) {\n      obj = {};\n    }\n    const moduleParamName = Object.keys(obj)[0];\n    const moduleParams = obj[moduleParamName];\n    if (typeof moduleParams !== 'object' || moduleParams === null) {\n      (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.q)(allModulesParams, obj);\n      return;\n    }\n    if (['navigation', 'pagination', 'scrollbar'].indexOf(moduleParamName) >= 0 && params[moduleParamName] === true) {\n      params[moduleParamName] = {\n        auto: true\n      };\n    }\n    if (!(moduleParamName in params && 'enabled' in moduleParams)) {\n      (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.q)(allModulesParams, obj);\n      return;\n    }\n    if (params[moduleParamName] === true) {\n      params[moduleParamName] = {\n        enabled: true\n      };\n    }\n    if (typeof params[moduleParamName] === 'object' && !('enabled' in params[moduleParamName])) {\n      params[moduleParamName].enabled = true;\n    }\n    if (!params[moduleParamName]) params[moduleParamName] = {\n      enabled: false\n    };\n    (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.q)(allModulesParams, obj);\n  };\n}\n\n/* eslint no-param-reassign: \"off\" */\nconst prototypes = {\n  eventsEmitter,\n  update,\n  translate,\n  transition,\n  slide,\n  loop,\n  grabCursor,\n  events: events$1,\n  breakpoints,\n  checkOverflow: checkOverflow$1,\n  classes\n};\nconst extendedDefaults = {};\nclass Swiper {\n  constructor() {\n    let el;\n    let params;\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n    if (args.length === 1 && args[0].constructor && Object.prototype.toString.call(args[0]).slice(8, -1) === 'Object') {\n      params = args[0];\n    } else {\n      [el, params] = args;\n    }\n    if (!params) params = {};\n    params = (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.q)({}, params);\n    if (el && !params.el) params.el = el;\n    const document = (0,_ssr_window_esm_mjs__WEBPACK_IMPORTED_MODULE_0__.g)();\n    if (params.el && typeof params.el === 'string' && document.querySelectorAll(params.el).length > 1) {\n      const swipers = [];\n      document.querySelectorAll(params.el).forEach(containerEl => {\n        const newParams = (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.q)({}, params, {\n          el: containerEl\n        });\n        swipers.push(new Swiper(newParams));\n      });\n      // eslint-disable-next-line no-constructor-return\n      return swipers;\n    }\n\n    // Swiper Instance\n    const swiper = this;\n    swiper.__swiper__ = true;\n    swiper.support = getSupport();\n    swiper.device = getDevice({\n      userAgent: params.userAgent\n    });\n    swiper.browser = getBrowser();\n    swiper.eventsListeners = {};\n    swiper.eventsAnyListeners = [];\n    swiper.modules = [...swiper.__modules__];\n    if (params.modules && Array.isArray(params.modules)) {\n      swiper.modules.push(...params.modules);\n    }\n    const allModulesParams = {};\n    swiper.modules.forEach(mod => {\n      mod({\n        params,\n        swiper,\n        extendParams: moduleExtendParams(params, allModulesParams),\n        on: swiper.on.bind(swiper),\n        once: swiper.once.bind(swiper),\n        off: swiper.off.bind(swiper),\n        emit: swiper.emit.bind(swiper)\n      });\n    });\n\n    // Extend defaults with modules params\n    const swiperParams = (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.q)({}, defaults, allModulesParams);\n\n    // Extend defaults with passed params\n    swiper.params = (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.q)({}, swiperParams, extendedDefaults, params);\n    swiper.originalParams = (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.q)({}, swiper.params);\n    swiper.passedParams = (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.q)({}, params);\n\n    // add event listeners\n    if (swiper.params && swiper.params.on) {\n      Object.keys(swiper.params.on).forEach(eventName => {\n        swiper.on(eventName, swiper.params.on[eventName]);\n      });\n    }\n    if (swiper.params && swiper.params.onAny) {\n      swiper.onAny(swiper.params.onAny);\n    }\n\n    // Extend Swiper\n    Object.assign(swiper, {\n      enabled: swiper.params.enabled,\n      el,\n      // Classes\n      classNames: [],\n      // Slides\n      slides: [],\n      slidesGrid: [],\n      snapGrid: [],\n      slidesSizesGrid: [],\n      // isDirection\n      isHorizontal() {\n        return swiper.params.direction === 'horizontal';\n      },\n      isVertical() {\n        return swiper.params.direction === 'vertical';\n      },\n      // Indexes\n      activeIndex: 0,\n      realIndex: 0,\n      //\n      isBeginning: true,\n      isEnd: false,\n      // Props\n      translate: 0,\n      previousTranslate: 0,\n      progress: 0,\n      velocity: 0,\n      animating: false,\n      cssOverflowAdjustment() {\n        // Returns 0 unless `translate` is > 2**23\n        // Should be subtracted from css values to prevent overflow\n        return Math.trunc(this.translate / 2 ** 23) * 2 ** 23;\n      },\n      // Locks\n      allowSlideNext: swiper.params.allowSlideNext,\n      allowSlidePrev: swiper.params.allowSlidePrev,\n      // Touch Events\n      touchEventsData: {\n        isTouched: undefined,\n        isMoved: undefined,\n        allowTouchCallbacks: undefined,\n        touchStartTime: undefined,\n        isScrolling: undefined,\n        currentTranslate: undefined,\n        startTranslate: undefined,\n        allowThresholdMove: undefined,\n        // Form elements to match\n        focusableElements: swiper.params.focusableElements,\n        // Last click time\n        lastClickTime: 0,\n        clickTimeout: undefined,\n        // Velocities\n        velocities: [],\n        allowMomentumBounce: undefined,\n        startMoving: undefined,\n        evCache: []\n      },\n      // Clicks\n      allowClick: true,\n      // Touches\n      allowTouchMove: swiper.params.allowTouchMove,\n      touches: {\n        startX: 0,\n        startY: 0,\n        currentX: 0,\n        currentY: 0,\n        diff: 0\n      },\n      // Images\n      imagesToLoad: [],\n      imagesLoaded: 0\n    });\n    swiper.emit('_swiper');\n\n    // Init\n    if (swiper.params.init) {\n      swiper.init();\n    }\n\n    // Return app instance\n    // eslint-disable-next-line no-constructor-return\n    return swiper;\n  }\n  getSlideIndex(slideEl) {\n    const {\n      slidesEl,\n      params\n    } = this;\n    const slides = (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.e)(slidesEl, `.${params.slideClass}, swiper-slide`);\n    const firstSlideIndex = (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.g)(slides[0]);\n    return (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.g)(slideEl) - firstSlideIndex;\n  }\n  getSlideIndexByData(index) {\n    return this.getSlideIndex(this.slides.filter(slideEl => slideEl.getAttribute('data-swiper-slide-index') * 1 === index)[0]);\n  }\n  recalcSlides() {\n    const swiper = this;\n    const {\n      slidesEl,\n      params\n    } = swiper;\n    swiper.slides = (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.e)(slidesEl, `.${params.slideClass}, swiper-slide`);\n  }\n  enable() {\n    const swiper = this;\n    if (swiper.enabled) return;\n    swiper.enabled = true;\n    if (swiper.params.grabCursor) {\n      swiper.setGrabCursor();\n    }\n    swiper.emit('enable');\n  }\n  disable() {\n    const swiper = this;\n    if (!swiper.enabled) return;\n    swiper.enabled = false;\n    if (swiper.params.grabCursor) {\n      swiper.unsetGrabCursor();\n    }\n    swiper.emit('disable');\n  }\n  setProgress(progress, speed) {\n    const swiper = this;\n    progress = Math.min(Math.max(progress, 0), 1);\n    const min = swiper.minTranslate();\n    const max = swiper.maxTranslate();\n    const current = (max - min) * progress + min;\n    swiper.translateTo(current, typeof speed === 'undefined' ? 0 : speed);\n    swiper.updateActiveIndex();\n    swiper.updateSlidesClasses();\n  }\n  emitContainerClasses() {\n    const swiper = this;\n    if (!swiper.params._emitClasses || !swiper.el) return;\n    const cls = swiper.el.className.split(' ').filter(className => {\n      return className.indexOf('swiper') === 0 || className.indexOf(swiper.params.containerModifierClass) === 0;\n    });\n    swiper.emit('_containerClasses', cls.join(' '));\n  }\n  getSlideClasses(slideEl) {\n    const swiper = this;\n    if (swiper.destroyed) return '';\n    return slideEl.className.split(' ').filter(className => {\n      return className.indexOf('swiper-slide') === 0 || className.indexOf(swiper.params.slideClass) === 0;\n    }).join(' ');\n  }\n  emitSlidesClasses() {\n    const swiper = this;\n    if (!swiper.params._emitClasses || !swiper.el) return;\n    const updates = [];\n    swiper.slides.forEach(slideEl => {\n      const classNames = swiper.getSlideClasses(slideEl);\n      updates.push({\n        slideEl,\n        classNames\n      });\n      swiper.emit('_slideClass', slideEl, classNames);\n    });\n    swiper.emit('_slideClasses', updates);\n  }\n  slidesPerViewDynamic(view, exact) {\n    if (view === void 0) {\n      view = 'current';\n    }\n    if (exact === void 0) {\n      exact = false;\n    }\n    const swiper = this;\n    const {\n      params,\n      slides,\n      slidesGrid,\n      slidesSizesGrid,\n      size: swiperSize,\n      activeIndex\n    } = swiper;\n    let spv = 1;\n    if (params.centeredSlides) {\n      let slideSize = slides[activeIndex] ? slides[activeIndex].swiperSlideSize : 0;\n      let breakLoop;\n      for (let i = activeIndex + 1; i < slides.length; i += 1) {\n        if (slides[i] && !breakLoop) {\n          slideSize += slides[i].swiperSlideSize;\n          spv += 1;\n          if (slideSize > swiperSize) breakLoop = true;\n        }\n      }\n      for (let i = activeIndex - 1; i >= 0; i -= 1) {\n        if (slides[i] && !breakLoop) {\n          slideSize += slides[i].swiperSlideSize;\n          spv += 1;\n          if (slideSize > swiperSize) breakLoop = true;\n        }\n      }\n    } else {\n      // eslint-disable-next-line\n      if (view === 'current') {\n        for (let i = activeIndex + 1; i < slides.length; i += 1) {\n          const slideInView = exact ? slidesGrid[i] + slidesSizesGrid[i] - slidesGrid[activeIndex] < swiperSize : slidesGrid[i] - slidesGrid[activeIndex] < swiperSize;\n          if (slideInView) {\n            spv += 1;\n          }\n        }\n      } else {\n        // previous\n        for (let i = activeIndex - 1; i >= 0; i -= 1) {\n          const slideInView = slidesGrid[activeIndex] - slidesGrid[i] < swiperSize;\n          if (slideInView) {\n            spv += 1;\n          }\n        }\n      }\n    }\n    return spv;\n  }\n  update() {\n    const swiper = this;\n    if (!swiper || swiper.destroyed) return;\n    const {\n      snapGrid,\n      params\n    } = swiper;\n    // Breakpoints\n    if (params.breakpoints) {\n      swiper.setBreakpoint();\n    }\n    [...swiper.el.querySelectorAll('[loading=\"lazy\"]')].forEach(imageEl => {\n      if (imageEl.complete) {\n        processLazyPreloader(swiper, imageEl);\n      }\n    });\n    swiper.updateSize();\n    swiper.updateSlides();\n    swiper.updateProgress();\n    swiper.updateSlidesClasses();\n    function setTranslate() {\n      const translateValue = swiper.rtlTranslate ? swiper.translate * -1 : swiper.translate;\n      const newTranslate = Math.min(Math.max(translateValue, swiper.maxTranslate()), swiper.minTranslate());\n      swiper.setTranslate(newTranslate);\n      swiper.updateActiveIndex();\n      swiper.updateSlidesClasses();\n    }\n    let translated;\n    if (params.freeMode && params.freeMode.enabled && !params.cssMode) {\n      setTranslate();\n      if (params.autoHeight) {\n        swiper.updateAutoHeight();\n      }\n    } else {\n      if ((params.slidesPerView === 'auto' || params.slidesPerView > 1) && swiper.isEnd && !params.centeredSlides) {\n        const slides = swiper.virtual && params.virtual.enabled ? swiper.virtual.slides : swiper.slides;\n        translated = swiper.slideTo(slides.length - 1, 0, false, true);\n      } else {\n        translated = swiper.slideTo(swiper.activeIndex, 0, false, true);\n      }\n      if (!translated) {\n        setTranslate();\n      }\n    }\n    if (params.watchOverflow && snapGrid !== swiper.snapGrid) {\n      swiper.checkOverflow();\n    }\n    swiper.emit('update');\n  }\n  changeDirection(newDirection, needUpdate) {\n    if (needUpdate === void 0) {\n      needUpdate = true;\n    }\n    const swiper = this;\n    const currentDirection = swiper.params.direction;\n    if (!newDirection) {\n      // eslint-disable-next-line\n      newDirection = currentDirection === 'horizontal' ? 'vertical' : 'horizontal';\n    }\n    if (newDirection === currentDirection || newDirection !== 'horizontal' && newDirection !== 'vertical') {\n      return swiper;\n    }\n    swiper.el.classList.remove(`${swiper.params.containerModifierClass}${currentDirection}`);\n    swiper.el.classList.add(`${swiper.params.containerModifierClass}${newDirection}`);\n    swiper.emitContainerClasses();\n    swiper.params.direction = newDirection;\n    swiper.slides.forEach(slideEl => {\n      if (newDirection === 'vertical') {\n        slideEl.style.width = '';\n      } else {\n        slideEl.style.height = '';\n      }\n    });\n    swiper.emit('changeDirection');\n    if (needUpdate) swiper.update();\n    return swiper;\n  }\n  changeLanguageDirection(direction) {\n    const swiper = this;\n    if (swiper.rtl && direction === 'rtl' || !swiper.rtl && direction === 'ltr') return;\n    swiper.rtl = direction === 'rtl';\n    swiper.rtlTranslate = swiper.params.direction === 'horizontal' && swiper.rtl;\n    if (swiper.rtl) {\n      swiper.el.classList.add(`${swiper.params.containerModifierClass}rtl`);\n      swiper.el.dir = 'rtl';\n    } else {\n      swiper.el.classList.remove(`${swiper.params.containerModifierClass}rtl`);\n      swiper.el.dir = 'ltr';\n    }\n    swiper.update();\n  }\n  mount(element) {\n    const swiper = this;\n    if (swiper.mounted) return true;\n\n    // Find el\n    let el = element || swiper.params.el;\n    if (typeof el === 'string') {\n      el = document.querySelector(el);\n    }\n    if (!el) {\n      return false;\n    }\n    el.swiper = swiper;\n    if (el.parentNode && el.parentNode.host) {\n      swiper.isElement = true;\n    }\n    const getWrapperSelector = () => {\n      return `.${(swiper.params.wrapperClass || '').trim().split(' ').join('.')}`;\n    };\n    const getWrapper = () => {\n      if (el && el.shadowRoot && el.shadowRoot.querySelector) {\n        const res = el.shadowRoot.querySelector(getWrapperSelector());\n        // Children needs to return slot items\n        return res;\n      }\n      return (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.e)(el, getWrapperSelector())[0];\n    };\n    // Find Wrapper\n    let wrapperEl = getWrapper();\n    if (!wrapperEl && swiper.params.createElements) {\n      wrapperEl = (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.c)('div', swiper.params.wrapperClass);\n      el.append(wrapperEl);\n      (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.e)(el, `.${swiper.params.slideClass}`).forEach(slideEl => {\n        wrapperEl.append(slideEl);\n      });\n    }\n    Object.assign(swiper, {\n      el,\n      wrapperEl,\n      slidesEl: swiper.isElement ? el.parentNode.host : wrapperEl,\n      hostEl: swiper.isElement ? el.parentNode.host : el,\n      mounted: true,\n      // RTL\n      rtl: el.dir.toLowerCase() === 'rtl' || (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.l)(el, 'direction') === 'rtl',\n      rtlTranslate: swiper.params.direction === 'horizontal' && (el.dir.toLowerCase() === 'rtl' || (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.l)(el, 'direction') === 'rtl'),\n      wrongRTL: (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.l)(wrapperEl, 'display') === '-webkit-box'\n    });\n    return true;\n  }\n  init(el) {\n    const swiper = this;\n    if (swiper.initialized) return swiper;\n    const mounted = swiper.mount(el);\n    if (mounted === false) return swiper;\n    swiper.emit('beforeInit');\n\n    // Set breakpoint\n    if (swiper.params.breakpoints) {\n      swiper.setBreakpoint();\n    }\n\n    // Add Classes\n    swiper.addClasses();\n\n    // Update size\n    swiper.updateSize();\n\n    // Update slides\n    swiper.updateSlides();\n    if (swiper.params.watchOverflow) {\n      swiper.checkOverflow();\n    }\n\n    // Set Grab Cursor\n    if (swiper.params.grabCursor && swiper.enabled) {\n      swiper.setGrabCursor();\n    }\n\n    // Slide To Initial Slide\n    if (swiper.params.loop && swiper.virtual && swiper.params.virtual.enabled) {\n      swiper.slideTo(swiper.params.initialSlide + swiper.virtual.slidesBefore, 0, swiper.params.runCallbacksOnInit, false, true);\n    } else {\n      swiper.slideTo(swiper.params.initialSlide, 0, swiper.params.runCallbacksOnInit, false, true);\n    }\n\n    // Create loop\n    if (swiper.params.loop) {\n      swiper.loopCreate();\n    }\n\n    // Attach events\n    swiper.attachEvents();\n    [...swiper.el.querySelectorAll('[loading=\"lazy\"]')].forEach(imageEl => {\n      if (imageEl.complete) {\n        processLazyPreloader(swiper, imageEl);\n      } else {\n        imageEl.addEventListener('load', e => {\n          processLazyPreloader(swiper, e.target);\n        });\n      }\n    });\n    preload(swiper);\n\n    // Init Flag\n    swiper.initialized = true;\n    preload(swiper);\n\n    // Emit\n    swiper.emit('init');\n    swiper.emit('afterInit');\n    return swiper;\n  }\n  destroy(deleteInstance, cleanStyles) {\n    if (deleteInstance === void 0) {\n      deleteInstance = true;\n    }\n    if (cleanStyles === void 0) {\n      cleanStyles = true;\n    }\n    const swiper = this;\n    const {\n      params,\n      el,\n      wrapperEl,\n      slides\n    } = swiper;\n    if (typeof swiper.params === 'undefined' || swiper.destroyed) {\n      return null;\n    }\n    swiper.emit('beforeDestroy');\n\n    // Init Flag\n    swiper.initialized = false;\n\n    // Detach events\n    swiper.detachEvents();\n\n    // Destroy loop\n    if (params.loop) {\n      swiper.loopDestroy();\n    }\n\n    // Cleanup styles\n    if (cleanStyles) {\n      swiper.removeClasses();\n      el.removeAttribute('style');\n      wrapperEl.removeAttribute('style');\n      if (slides && slides.length) {\n        slides.forEach(slideEl => {\n          slideEl.classList.remove(params.slideVisibleClass, params.slideActiveClass, params.slideNextClass, params.slidePrevClass);\n          slideEl.removeAttribute('style');\n          slideEl.removeAttribute('data-swiper-slide-index');\n        });\n      }\n    }\n    swiper.emit('destroy');\n\n    // Detach emitter events\n    Object.keys(swiper.eventsListeners).forEach(eventName => {\n      swiper.off(eventName);\n    });\n    if (deleteInstance !== false) {\n      swiper.el.swiper = null;\n      (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.r)(swiper);\n    }\n    swiper.destroyed = true;\n    return null;\n  }\n  static extendDefaults(newDefaults) {\n    (0,_utils_mjs__WEBPACK_IMPORTED_MODULE_1__.q)(extendedDefaults, newDefaults);\n  }\n  static get extendedDefaults() {\n    return extendedDefaults;\n  }\n  static get defaults() {\n    return defaults;\n  }\n  static installModule(mod) {\n    if (!Swiper.prototype.__modules__) Swiper.prototype.__modules__ = [];\n    const modules = Swiper.prototype.__modules__;\n    if (typeof mod === 'function' && modules.indexOf(mod) < 0) {\n      modules.push(mod);\n    }\n  }\n  static use(module) {\n    if (Array.isArray(module)) {\n      module.forEach(m => Swiper.installModule(m));\n      return Swiper;\n    }\n    Swiper.installModule(module);\n    return Swiper;\n  }\n}\nObject.keys(prototypes).forEach(prototypeGroup => {\n  Object.keys(prototypes[prototypeGroup]).forEach(protoMethod => {\n    Swiper.prototype[protoMethod] = prototypes[prototypeGroup][protoMethod];\n  });\n});\nSwiper.use([Resize, Observer]);\n\n\n\n\n//# sourceURL=webpack://brainwave/./node_modules/swiper/shared/swiper-core.mjs?");

/***/ }),

/***/ "./node_modules/swiper/shared/utils.min.mjs":
/*!**************************************************!*\
  !*** ./node_modules/swiper/shared/utils.min.mjs ***!
  \**************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   a: function() { return /* binding */ elementParents; },\n/* harmony export */   b: function() { return /* binding */ elementOffset; },\n/* harmony export */   c: function() { return /* binding */ createElement; },\n/* harmony export */   d: function() { return /* binding */ now; },\n/* harmony export */   e: function() { return /* binding */ elementChildren; },\n/* harmony export */   f: function() { return /* binding */ elementOuterSize; },\n/* harmony export */   g: function() { return /* binding */ elementIndex; },\n/* harmony export */   h: function() { return /* binding */ getTranslate; },\n/* harmony export */   i: function() { return /* binding */ elementTransitionEnd; },\n/* harmony export */   j: function() { return /* binding */ isObject; },\n/* harmony export */   k: function() { return /* binding */ getSlideTransformEl; },\n/* harmony export */   l: function() { return /* binding */ elementStyle; },\n/* harmony export */   m: function() { return /* binding */ elementNextAll; },\n/* harmony export */   n: function() { return /* binding */ nextTick; },\n/* harmony export */   o: function() { return /* binding */ elementPrevAll; },\n/* harmony export */   p: function() { return /* binding */ animateCSSModeScroll; },\n/* harmony export */   q: function() { return /* binding */ extend; },\n/* harmony export */   r: function() { return /* binding */ deleteProps; },\n/* harmony export */   s: function() { return /* binding */ setCSSProperty; }\n/* harmony export */ });\n/* harmony import */ var _ssr_window_esm_min_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ssr-window.esm.min.mjs */ \"./node_modules/swiper/shared/ssr-window.esm.min.mjs\");\nfunction deleteProps(e){const t=e;Object.keys(t).forEach((e=>{try{t[e]=null}catch(e){}try{delete t[e]}catch(e){}}))}function nextTick(e,t){return void 0===t&&(t=0),setTimeout(e,t)}function now(){return Date.now()}function getComputedStyle(e){const t=(0,_ssr_window_esm_min_mjs__WEBPACK_IMPORTED_MODULE_0__.a)();let n;return t.getComputedStyle&&(n=t.getComputedStyle(e,null)),!n&&e.currentStyle&&(n=e.currentStyle),n||(n=e.style),n}function getTranslate(e,t){void 0===t&&(t=\"x\");const n=(0,_ssr_window_esm_min_mjs__WEBPACK_IMPORTED_MODULE_0__.a)();let r,o,l;const s=getComputedStyle(e);return n.WebKitCSSMatrix?(o=s.transform||s.webkitTransform,o.split(\",\").length>6&&(o=o.split(\", \").map((e=>e.replace(\",\",\".\"))).join(\", \")),l=new n.WebKitCSSMatrix(\"none\"===o?\"\":o)):(l=s.MozTransform||s.OTransform||s.MsTransform||s.msTransform||s.transform||s.getPropertyValue(\"transform\").replace(\"translate(\",\"matrix(1, 0, 0, 1,\"),r=l.toString().split(\",\")),\"x\"===t&&(o=n.WebKitCSSMatrix?l.m41:16===r.length?parseFloat(r[12]):parseFloat(r[4])),\"y\"===t&&(o=n.WebKitCSSMatrix?l.m42:16===r.length?parseFloat(r[13]):parseFloat(r[5])),o||0}function isObject(e){return\"object\"==typeof e&&null!==e&&e.constructor&&\"Object\"===Object.prototype.toString.call(e).slice(8,-1)}function isNode(e){return\"undefined\"!=typeof window&&void 0!==window.HTMLElement?e instanceof HTMLElement:e&&(1===e.nodeType||11===e.nodeType)}function extend(){const e=Object(arguments.length<=0?void 0:arguments[0]),t=[\"__proto__\",\"constructor\",\"prototype\"];for(let n=1;n<arguments.length;n+=1){const r=n<0||arguments.length<=n?void 0:arguments[n];if(null!=r&&!isNode(r)){const n=Object.keys(Object(r)).filter((e=>t.indexOf(e)<0));for(let t=0,o=n.length;t<o;t+=1){const o=n[t],l=Object.getOwnPropertyDescriptor(r,o);void 0!==l&&l.enumerable&&(isObject(e[o])&&isObject(r[o])?r[o].__swiper__?e[o]=r[o]:extend(e[o],r[o]):!isObject(e[o])&&isObject(r[o])?(e[o]={},r[o].__swiper__?e[o]=r[o]:extend(e[o],r[o])):e[o]=r[o])}}}return e}function setCSSProperty(e,t,n){e.style.setProperty(t,n)}function animateCSSModeScroll(e){let{swiper:t,targetPosition:n,side:r}=e;const o=(0,_ssr_window_esm_min_mjs__WEBPACK_IMPORTED_MODULE_0__.a)(),l=-t.translate;let s,i=null;const a=t.params.speed;t.wrapperEl.style.scrollSnapType=\"none\",o.cancelAnimationFrame(t.cssModeFrameID);const c=n>l?\"next\":\"prev\",m=(e,t)=>\"next\"===c&&e>=t||\"prev\"===c&&e<=t,u=()=>{s=(new Date).getTime(),null===i&&(i=s);const e=Math.max(Math.min((s-i)/a,1),0),c=.5-Math.cos(e*Math.PI)/2;let p=l+c*(n-l);if(m(p,n)&&(p=n),t.wrapperEl.scrollTo({[r]:p}),m(p,n))return t.wrapperEl.style.overflow=\"hidden\",t.wrapperEl.style.scrollSnapType=\"\",setTimeout((()=>{t.wrapperEl.style.overflow=\"\",t.wrapperEl.scrollTo({[r]:p})})),void o.cancelAnimationFrame(t.cssModeFrameID);t.cssModeFrameID=o.requestAnimationFrame(u)};u()}function getSlideTransformEl(e){return e.querySelector(\".swiper-slide-transform\")||e.shadowRoot&&e.shadowRoot.querySelector(\".swiper-slide-transform\")||e}function elementChildren(e,t){return void 0===t&&(t=\"\"),[...e.children].filter((e=>e.matches(t)))}function createElement(e,t){void 0===t&&(t=[]);const n=document.createElement(e);return n.classList.add(...Array.isArray(t)?t:[t]),n}function elementOffset(e){const t=(0,_ssr_window_esm_min_mjs__WEBPACK_IMPORTED_MODULE_0__.a)(),n=(0,_ssr_window_esm_min_mjs__WEBPACK_IMPORTED_MODULE_0__.g)(),r=e.getBoundingClientRect(),o=n.body,l=e.clientTop||o.clientTop||0,s=e.clientLeft||o.clientLeft||0,i=e===t?t.scrollY:e.scrollTop,a=e===t?t.scrollX:e.scrollLeft;return{top:r.top+i-l,left:r.left+a-s}}function elementPrevAll(e,t){const n=[];for(;e.previousElementSibling;){const r=e.previousElementSibling;t?r.matches(t)&&n.push(r):n.push(r),e=r}return n}function elementNextAll(e,t){const n=[];for(;e.nextElementSibling;){const r=e.nextElementSibling;t?r.matches(t)&&n.push(r):n.push(r),e=r}return n}function elementStyle(e,t){return (0,_ssr_window_esm_min_mjs__WEBPACK_IMPORTED_MODULE_0__.a)().getComputedStyle(e,null).getPropertyValue(t)}function elementIndex(e){let t,n=e;if(n){for(t=0;null!==(n=n.previousSibling);)1===n.nodeType&&(t+=1);return t}}function elementParents(e,t){const n=[];let r=e.parentElement;for(;r;)t?r.matches(t)&&n.push(r):n.push(r),r=r.parentElement;return n}function elementTransitionEnd(e,t){t&&e.addEventListener(\"transitionend\",(function n(r){r.target===e&&(t.call(e,r),e.removeEventListener(\"transitionend\",n))}))}function elementOuterSize(e,t,n){const r=(0,_ssr_window_esm_min_mjs__WEBPACK_IMPORTED_MODULE_0__.a)();return n?e[\"width\"===t?\"offsetWidth\":\"offsetHeight\"]+parseFloat(r.getComputedStyle(e,null).getPropertyValue(\"width\"===t?\"margin-right\":\"margin-top\"))+parseFloat(r.getComputedStyle(e,null).getPropertyValue(\"width\"===t?\"margin-left\":\"margin-bottom\")):e.offsetWidth}\n//# sourceMappingURL=utils.mjs.map\n\n//# sourceURL=webpack://brainwave/./node_modules/swiper/shared/utils.min.mjs?");

/***/ }),

/***/ "./node_modules/swiper/shared/utils.mjs":
/*!**********************************************!*\
  !*** ./node_modules/swiper/shared/utils.mjs ***!
  \**********************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   a: function() { return /* binding */ elementParents; },\n/* harmony export */   b: function() { return /* binding */ elementOffset; },\n/* harmony export */   c: function() { return /* binding */ createElement; },\n/* harmony export */   d: function() { return /* binding */ now; },\n/* harmony export */   e: function() { return /* binding */ elementChildren; },\n/* harmony export */   f: function() { return /* binding */ elementOuterSize; },\n/* harmony export */   g: function() { return /* binding */ elementIndex; },\n/* harmony export */   h: function() { return /* binding */ getTranslate; },\n/* harmony export */   i: function() { return /* binding */ elementTransitionEnd; },\n/* harmony export */   j: function() { return /* binding */ isObject; },\n/* harmony export */   k: function() { return /* binding */ getSlideTransformEl; },\n/* harmony export */   l: function() { return /* binding */ elementStyle; },\n/* harmony export */   m: function() { return /* binding */ elementNextAll; },\n/* harmony export */   n: function() { return /* binding */ nextTick; },\n/* harmony export */   o: function() { return /* binding */ elementPrevAll; },\n/* harmony export */   p: function() { return /* binding */ animateCSSModeScroll; },\n/* harmony export */   q: function() { return /* binding */ extend; },\n/* harmony export */   r: function() { return /* binding */ deleteProps; },\n/* harmony export */   s: function() { return /* binding */ setCSSProperty; }\n/* harmony export */ });\n/* harmony import */ var _ssr_window_esm_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ssr-window.esm.mjs */ \"./node_modules/swiper/shared/ssr-window.esm.mjs\");\n\n\nfunction deleteProps(obj) {\n  const object = obj;\n  Object.keys(object).forEach(key => {\n    try {\n      object[key] = null;\n    } catch (e) {\n      // no getter for object\n    }\n    try {\n      delete object[key];\n    } catch (e) {\n      // something got wrong\n    }\n  });\n}\nfunction nextTick(callback, delay) {\n  if (delay === void 0) {\n    delay = 0;\n  }\n  return setTimeout(callback, delay);\n}\nfunction now() {\n  return Date.now();\n}\nfunction getComputedStyle(el) {\n  const window = (0,_ssr_window_esm_mjs__WEBPACK_IMPORTED_MODULE_0__.a)();\n  let style;\n  if (window.getComputedStyle) {\n    style = window.getComputedStyle(el, null);\n  }\n  if (!style && el.currentStyle) {\n    style = el.currentStyle;\n  }\n  if (!style) {\n    style = el.style;\n  }\n  return style;\n}\nfunction getTranslate(el, axis) {\n  if (axis === void 0) {\n    axis = 'x';\n  }\n  const window = (0,_ssr_window_esm_mjs__WEBPACK_IMPORTED_MODULE_0__.a)();\n  let matrix;\n  let curTransform;\n  let transformMatrix;\n  const curStyle = getComputedStyle(el);\n  if (window.WebKitCSSMatrix) {\n    curTransform = curStyle.transform || curStyle.webkitTransform;\n    if (curTransform.split(',').length > 6) {\n      curTransform = curTransform.split(', ').map(a => a.replace(',', '.')).join(', ');\n    }\n    // Some old versions of Webkit choke when 'none' is passed; pass\n    // empty string instead in this case\n    transformMatrix = new window.WebKitCSSMatrix(curTransform === 'none' ? '' : curTransform);\n  } else {\n    transformMatrix = curStyle.MozTransform || curStyle.OTransform || curStyle.MsTransform || curStyle.msTransform || curStyle.transform || curStyle.getPropertyValue('transform').replace('translate(', 'matrix(1, 0, 0, 1,');\n    matrix = transformMatrix.toString().split(',');\n  }\n  if (axis === 'x') {\n    // Latest Chrome and webkits Fix\n    if (window.WebKitCSSMatrix) curTransform = transformMatrix.m41;\n    // Crazy IE10 Matrix\n    else if (matrix.length === 16) curTransform = parseFloat(matrix[12]);\n    // Normal Browsers\n    else curTransform = parseFloat(matrix[4]);\n  }\n  if (axis === 'y') {\n    // Latest Chrome and webkits Fix\n    if (window.WebKitCSSMatrix) curTransform = transformMatrix.m42;\n    // Crazy IE10 Matrix\n    else if (matrix.length === 16) curTransform = parseFloat(matrix[13]);\n    // Normal Browsers\n    else curTransform = parseFloat(matrix[5]);\n  }\n  return curTransform || 0;\n}\nfunction isObject(o) {\n  return typeof o === 'object' && o !== null && o.constructor && Object.prototype.toString.call(o).slice(8, -1) === 'Object';\n}\nfunction isNode(node) {\n  // eslint-disable-next-line\n  if (typeof window !== 'undefined' && typeof window.HTMLElement !== 'undefined') {\n    return node instanceof HTMLElement;\n  }\n  return node && (node.nodeType === 1 || node.nodeType === 11);\n}\nfunction extend() {\n  const to = Object(arguments.length <= 0 ? undefined : arguments[0]);\n  const noExtend = ['__proto__', 'constructor', 'prototype'];\n  for (let i = 1; i < arguments.length; i += 1) {\n    const nextSource = i < 0 || arguments.length <= i ? undefined : arguments[i];\n    if (nextSource !== undefined && nextSource !== null && !isNode(nextSource)) {\n      const keysArray = Object.keys(Object(nextSource)).filter(key => noExtend.indexOf(key) < 0);\n      for (let nextIndex = 0, len = keysArray.length; nextIndex < len; nextIndex += 1) {\n        const nextKey = keysArray[nextIndex];\n        const desc = Object.getOwnPropertyDescriptor(nextSource, nextKey);\n        if (desc !== undefined && desc.enumerable) {\n          if (isObject(to[nextKey]) && isObject(nextSource[nextKey])) {\n            if (nextSource[nextKey].__swiper__) {\n              to[nextKey] = nextSource[nextKey];\n            } else {\n              extend(to[nextKey], nextSource[nextKey]);\n            }\n          } else if (!isObject(to[nextKey]) && isObject(nextSource[nextKey])) {\n            to[nextKey] = {};\n            if (nextSource[nextKey].__swiper__) {\n              to[nextKey] = nextSource[nextKey];\n            } else {\n              extend(to[nextKey], nextSource[nextKey]);\n            }\n          } else {\n            to[nextKey] = nextSource[nextKey];\n          }\n        }\n      }\n    }\n  }\n  return to;\n}\nfunction setCSSProperty(el, varName, varValue) {\n  el.style.setProperty(varName, varValue);\n}\nfunction animateCSSModeScroll(_ref) {\n  let {\n    swiper,\n    targetPosition,\n    side\n  } = _ref;\n  const window = (0,_ssr_window_esm_mjs__WEBPACK_IMPORTED_MODULE_0__.a)();\n  const startPosition = -swiper.translate;\n  let startTime = null;\n  let time;\n  const duration = swiper.params.speed;\n  swiper.wrapperEl.style.scrollSnapType = 'none';\n  window.cancelAnimationFrame(swiper.cssModeFrameID);\n  const dir = targetPosition > startPosition ? 'next' : 'prev';\n  const isOutOfBound = (current, target) => {\n    return dir === 'next' && current >= target || dir === 'prev' && current <= target;\n  };\n  const animate = () => {\n    time = new Date().getTime();\n    if (startTime === null) {\n      startTime = time;\n    }\n    const progress = Math.max(Math.min((time - startTime) / duration, 1), 0);\n    const easeProgress = 0.5 - Math.cos(progress * Math.PI) / 2;\n    let currentPosition = startPosition + easeProgress * (targetPosition - startPosition);\n    if (isOutOfBound(currentPosition, targetPosition)) {\n      currentPosition = targetPosition;\n    }\n    swiper.wrapperEl.scrollTo({\n      [side]: currentPosition\n    });\n    if (isOutOfBound(currentPosition, targetPosition)) {\n      swiper.wrapperEl.style.overflow = 'hidden';\n      swiper.wrapperEl.style.scrollSnapType = '';\n      setTimeout(() => {\n        swiper.wrapperEl.style.overflow = '';\n        swiper.wrapperEl.scrollTo({\n          [side]: currentPosition\n        });\n      });\n      window.cancelAnimationFrame(swiper.cssModeFrameID);\n      return;\n    }\n    swiper.cssModeFrameID = window.requestAnimationFrame(animate);\n  };\n  animate();\n}\nfunction getSlideTransformEl(slideEl) {\n  return slideEl.querySelector('.swiper-slide-transform') || slideEl.shadowRoot && slideEl.shadowRoot.querySelector('.swiper-slide-transform') || slideEl;\n}\nfunction elementChildren(element, selector) {\n  if (selector === void 0) {\n    selector = '';\n  }\n  return [...element.children].filter(el => el.matches(selector));\n}\nfunction createElement(tag, classes) {\n  if (classes === void 0) {\n    classes = [];\n  }\n  const el = document.createElement(tag);\n  el.classList.add(...(Array.isArray(classes) ? classes : [classes]));\n  return el;\n}\nfunction elementOffset(el) {\n  const window = (0,_ssr_window_esm_mjs__WEBPACK_IMPORTED_MODULE_0__.a)();\n  const document = (0,_ssr_window_esm_mjs__WEBPACK_IMPORTED_MODULE_0__.g)();\n  const box = el.getBoundingClientRect();\n  const body = document.body;\n  const clientTop = el.clientTop || body.clientTop || 0;\n  const clientLeft = el.clientLeft || body.clientLeft || 0;\n  const scrollTop = el === window ? window.scrollY : el.scrollTop;\n  const scrollLeft = el === window ? window.scrollX : el.scrollLeft;\n  return {\n    top: box.top + scrollTop - clientTop,\n    left: box.left + scrollLeft - clientLeft\n  };\n}\nfunction elementPrevAll(el, selector) {\n  const prevEls = [];\n  while (el.previousElementSibling) {\n    const prev = el.previousElementSibling; // eslint-disable-line\n    if (selector) {\n      if (prev.matches(selector)) prevEls.push(prev);\n    } else prevEls.push(prev);\n    el = prev;\n  }\n  return prevEls;\n}\nfunction elementNextAll(el, selector) {\n  const nextEls = [];\n  while (el.nextElementSibling) {\n    const next = el.nextElementSibling; // eslint-disable-line\n    if (selector) {\n      if (next.matches(selector)) nextEls.push(next);\n    } else nextEls.push(next);\n    el = next;\n  }\n  return nextEls;\n}\nfunction elementStyle(el, prop) {\n  const window = (0,_ssr_window_esm_mjs__WEBPACK_IMPORTED_MODULE_0__.a)();\n  return window.getComputedStyle(el, null).getPropertyValue(prop);\n}\nfunction elementIndex(el) {\n  let child = el;\n  let i;\n  if (child) {\n    i = 0;\n    // eslint-disable-next-line\n    while ((child = child.previousSibling) !== null) {\n      if (child.nodeType === 1) i += 1;\n    }\n    return i;\n  }\n  return undefined;\n}\nfunction elementParents(el, selector) {\n  const parents = []; // eslint-disable-line\n  let parent = el.parentElement; // eslint-disable-line\n  while (parent) {\n    if (selector) {\n      if (parent.matches(selector)) parents.push(parent);\n    } else {\n      parents.push(parent);\n    }\n    parent = parent.parentElement;\n  }\n  return parents;\n}\nfunction elementTransitionEnd(el, callback) {\n  function fireCallBack(e) {\n    if (e.target !== el) return;\n    callback.call(el, e);\n    el.removeEventListener('transitionend', fireCallBack);\n  }\n  if (callback) {\n    el.addEventListener('transitionend', fireCallBack);\n  }\n}\nfunction elementOuterSize(el, size, includeMargins) {\n  const window = (0,_ssr_window_esm_mjs__WEBPACK_IMPORTED_MODULE_0__.a)();\n  if (includeMargins) {\n    return el[size === 'width' ? 'offsetWidth' : 'offsetHeight'] + parseFloat(window.getComputedStyle(el, null).getPropertyValue(size === 'width' ? 'margin-right' : 'margin-top')) + parseFloat(window.getComputedStyle(el, null).getPropertyValue(size === 'width' ? 'margin-left' : 'margin-bottom'));\n  }\n  return el.offsetWidth;\n}\n\n\n\n\n//# sourceURL=webpack://brainwave/./node_modules/swiper/shared/utils.mjs?");

/***/ }),

/***/ "./node_modules/swiper/swiper.mjs":
/*!****************************************!*\
  !*** ./node_modules/swiper/swiper.mjs ***!
  \****************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Swiper: function() { return /* reexport safe */ _shared_swiper_core_mjs__WEBPACK_IMPORTED_MODULE_0__.S; },\n/* harmony export */   \"default\": function() { return /* reexport safe */ _shared_swiper_core_mjs__WEBPACK_IMPORTED_MODULE_0__.S; }\n/* harmony export */ });\n/* harmony import */ var _shared_swiper_core_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./shared/swiper-core.mjs */ \"./node_modules/swiper/shared/swiper-core.mjs\");\n/**\n * Swiper 10.0.4\n * Most modern mobile touch slider and framework with hardware accelerated transitions\n * https://swiperjs.com\n *\n * Copyright 2014-2023 Vladimir Kharlampidi\n *\n * Released under the MIT License\n *\n * Released on: July 8, 2023\n */\n\n\n\n\n//# sourceURL=webpack://brainwave/./node_modules/swiper/swiper.mjs?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	!function() {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = function(module) {
/******/ 			var getter = module && module.__esModule ?
/******/ 				function() { return module['default']; } :
/******/ 				function() { return module; };
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	!function() {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = function(exports, definition) {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	!function() {
/******/ 		__webpack_require__.o = function(obj, prop) { return Object.prototype.hasOwnProperty.call(obj, prop); }
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	!function() {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = function(exports) {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	}();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("../../../themes/leocar/assets/src/scripts/index.js");
/******/ 	
/******/ })()
;